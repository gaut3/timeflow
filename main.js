/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeFlowPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  version: "1.0.0",
  workPercent: 1,
  baseWorkday: 7.5,
  baseWorkweek: 37.5,
  updateInterval: 3e4,
  clockInterval: 1e3,
  holidaysFilePath: "01. timeflow/timeflow/Fremtidige dager.md",
  dailyNotesFolder: "Daily Notes",
  dailyNotesTemplatePath: "01. timeflow/timeflow/Administrasjon/Templates/Daily Notes Template.md",
  workdaysPerYear: 260,
  workdaysPerMonth: 21,
  workdaysPerWeek: 5,
  consecutiveFlextimeWarningDays: 5,
  defaultExportWeeks: 52,
  heatmapColumns: 48,
  noteTypes: [
    {
      id: "daily",
      label: "Daglig Notat",
      icon: "\u{1F4C5}",
      folder: "Daily Notes",
      template: "01. timeflow/timeflow/Administrasjon/Templates/Daily Notes Template.md",
      tags: [],
      filenamePattern: "{YYYY}-{MM}-{DD}"
    },
    {
      id: "meeting",
      label: "M\xF8tenotat",
      icon: "\u{1F465}",
      folder: "M\xF8ter",
      template: "01. timeflow/timeflow/Administrasjon/Templates/Meeting Note template.md",
      tags: ["#m\xF8te", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} M\xF8te"
    },
    {
      id: "project",
      label: "Prosjektnotat",
      icon: "\u{1F4CB}",
      folder: "Prosjekter",
      template: "01. timeflow/timeflow/Administrasjon/Templates/Project Note template.md",
      tags: ["#prosjekt", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Prosjekt"
    },
    {
      id: "review",
      label: "Ukesoppsummering",
      icon: "\u{1F50D}",
      folder: "Oppsummeringer",
      template: "01. timeflow/timeflow/Administrasjon/Templates/Weekly Review template.md",
      tags: ["#oppsummering", "#uke", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Uke {WEEK}"
    },
    {
      id: "reflection",
      label: "Refleksjonsnotat",
      icon: "\u{1F4AD}",
      folder: "Refleksjoner",
      template: "01. timeflow/timeflow/Administrasjon/Templates/Reflection Note template.md",
      tags: ["#refleksjon", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Refleksjon"
    }
  ]
};
var TimeFlowSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "TimeFlow Settings" });
    containerEl.createEl("h3", { text: "Work Configuration" });
    new import_obsidian.Setting(containerEl).setName("Work Percentage").setDesc("Your employment percentage (1.0 = 100%, 0.8 = 80%, etc.)").addText((text) => text.setPlaceholder("1.0").setValue(this.plugin.settings.workPercent.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0 && num <= 1) {
        this.plugin.settings.workPercent = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Base Workday Hours").setDesc("Standard hours for a full workday").addText((text) => text.setPlaceholder("7.5").setValue(this.plugin.settings.baseWorkday.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.baseWorkday = num;
        this.plugin.settings.baseWorkweek = num * 5;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "File Paths" });
    new import_obsidian.Setting(containerEl).setName("Holidays File Path").setDesc("Path to the file containing future planned days/holidays").addText((text) => text.setPlaceholder("01. timeflow/timeflow/Fremtidige dager.md").setValue(this.plugin.settings.holidaysFilePath).onChange(async (value) => {
      this.plugin.settings.holidaysFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Daily Notes Folder").setDesc("Folder where daily notes are stored").addText((text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
      this.plugin.settings.dailyNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Daily Notes Template Path").setDesc("Path to the template for daily notes").addText((text) => text.setPlaceholder("Templates/Daily Notes Template.md").setValue(this.plugin.settings.dailyNotesTemplatePath).onChange(async (value) => {
      this.plugin.settings.dailyNotesTemplatePath = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Settings" });
    new import_obsidian.Setting(containerEl).setName("Consecutive Flextime Warning Days").setDesc("Number of consecutive days with flextime before showing a warning").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.consecutiveFlextimeWarningDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.consecutiveFlextimeWarningDays = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Heatmap Columns").setDesc("Number of columns in the heatmap view (adjust for your screen width)").addText((text) => text.setPlaceholder("48").setValue(this.plugin.settings.heatmapColumns.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.heatmapColumns = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Update Interval (ms)").setDesc("How often to update the dashboard data (in milliseconds)").addText((text) => text.setPlaceholder("30000").setValue(this.plugin.settings.updateInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.updateInterval = num;
        await this.plugin.saveSettings();
      }
    }));
  }
};

// src/view.ts
var import_obsidian5 = require("obsidian");

// src/dataManager.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var SPECIAL_DAY_COLORS = {
  avspasering: "#ffe0b2",
  ferie: "#b3e5fc",
  velferdspermisjon: "#e1bee7",
  egenmelding: "#c8e6c9",
  kurs: "#f8bbd0",
  studie: "#f8bbd0",
  helligdag: "#ef5350",
  half: "#ffd54f",
  halfday: "#ffd54f",
  "Ingen registrering": "#cccccc"
};
var EMOJI_MAP = {
  avspasering: "\u{1F6CC}",
  kurs: "\u{1F4DA}",
  studie: "\u{1F4DA}",
  ferie: "\u{1F3D6}\uFE0F",
  velferdspermisjon: "\u{1F3E5}",
  egenmelding: "\u{1F912}",
  helligdag: "\u{1F389}",
  jobb: "\u{1F4BC}"
};
var Utils = {
  parseDate: (str) => str ? new Date(str) : null,
  hoursDiff: (start, end) => (end.getTime() - start.getTime()) / 36e5,
  isWeekend: (date) => date ? date.getDay() === 0 || date.getDay() === 6 : false,
  formatHoursToHM: (hours) => {
    const h = Math.floor(hours);
    const m = Math.round((hours - h) * 60);
    return `${h}h ${m.toString().padStart(2, "0")}m`;
  },
  toLocalDateStr: (date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  },
  getWeekNumber: (d) => {
    const date = new Date(d.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    const week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(
      ((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7
    );
  },
  getEmoji: (entry) => {
    const name = entry.name.toLowerCase();
    if (EMOJI_MAP[name])
      return EMOJI_MAP[name];
    if (!entry.endTime)
      return "\u23F3";
    if (Utils.isWeekend(entry.date))
      return "\u{1F319}";
    return "";
  },
  randMsg: (arr) => arr[Math.floor(Math.random() * arr.length)],
  getDayOfYear: (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    return Math.floor(diff / 864e5);
  }
};

// src/dataManager.ts
var DataManager = class {
  constructor(entries, settings, app) {
    this.daily = {};
    this.months = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.holidays = {};
    // Cache for expensive calculations
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries = entries;
    this.settings = settings;
    this.app = app;
    this.workdayHours = settings.baseWorkday * settings.workPercent;
    this.workweekHours = settings.baseWorkweek * settings.workPercent;
  }
  async loadHolidays() {
    const status = { success: false, message: "", count: 0, warning: null };
    try {
      const holidayFile = this.app.vault.getAbstractFileByPath(this.settings.holidaysFilePath);
      if (holidayFile && holidayFile instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(holidayFile);
        const lines = content.split("\n");
        lines.forEach((line) => {
          const match = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*(\w+)(?::half)?:\s*(.+)$/);
          if (match) {
            const [, date, type, description] = match;
            const isHalfDay = line.includes(":half:");
            this.holidays[date] = {
              type: type.trim().toLowerCase(),
              description: description.trim(),
              halfDay: isHalfDay
            };
          }
        });
        status.success = true;
        status.count = Object.keys(this.holidays).length;
        status.message = `Loaded ${status.count} planned days`;
        console.log(`Loaded ${status.count} future days`);
      } else {
        status.warning = `Holiday file not found: ${this.settings.holidaysFilePath}`;
        console.warn(status.warning);
      }
    } catch (error) {
      status.warning = `Error loading holidays: ${error.message}`;
      console.warn("Could not load future days file:", error);
    }
    return status;
  }
  isHoliday(dateStr) {
    return this.holidays.hasOwnProperty(dateStr);
  }
  getHolidayInfo(dateStr) {
    return this.holidays[dateStr] || null;
  }
  getDailyGoal(dateStr) {
    const date = new Date(dateStr);
    const isWeekend = Utils.isWeekend(date);
    if (isWeekend)
      return 0;
    const holidayInfo = this.getHolidayInfo(dateStr);
    if (holidayInfo) {
      if (["ferie", "velferdspermisjon", "helligdag", "egenmelding"].includes(holidayInfo.type)) {
        return 0;
      }
      if (holidayInfo.halfDay) {
        return 4;
      }
    }
    return this.workdayHours;
  }
  processEntries() {
    this.rawEntries.forEach((e) => {
      if (!e.startTime)
        return;
      if (!e.endTime) {
        this.activeEntries.push(e);
        const start2 = Utils.parseDate(e.startTime);
        if (start2) {
          const dayKey2 = Utils.toLocalDateStr(start2);
          if (!this.activeEntriesByDate[dayKey2])
            this.activeEntriesByDate[dayKey2] = [];
          this.activeEntriesByDate[dayKey2].push(e);
        }
        return;
      }
      const start = Utils.parseDate(e.startTime);
      const end = Utils.parseDate(e.endTime);
      if (!start || !end)
        return;
      const duration = Utils.hoursDiff(start, end);
      const dayKey = Utils.toLocalDateStr(start);
      if (!this.daily[dayKey])
        this.daily[dayKey] = [];
      this.daily[dayKey].push({ ...e, duration, date: start });
    });
    this.calculateFlextime();
    this.groupByMonths();
  }
  calculateFlextime() {
    for (let day in this.daily) {
      const dayGoal = this.getDailyGoal(day);
      this.daily[day].forEach((e) => {
        let flextime = 0;
        const name = e.name.toLowerCase();
        if (name === "avspasering") {
          flextime -= e.duration || 0;
        } else if (dayGoal === 0) {
          flextime += e.duration || 0;
        } else {
          if ((e.duration || 0) > dayGoal) {
            flextime += (e.duration || 0) - dayGoal;
          }
        }
        e.flextime = flextime;
      });
    }
  }
  groupByMonths() {
    for (let day of Object.keys(this.daily)) {
      const date = new Date(day);
      const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
      if (!this.months[monthKey])
        this.months[monthKey] = {};
      const weekNum = Math.ceil((date.getDate() - date.getDay() + 1) / 7);
      if (!this.months[monthKey][weekNum])
        this.months[monthKey][weekNum] = [];
      this.months[monthKey][weekNum].push(...this.daily[day]);
    }
  }
  getOngoing() {
    const now = /* @__PURE__ */ new Date();
    return this.activeEntries.reduce((sum, e) => {
      const start = Utils.parseDate(e.startTime);
      return start ? sum + Utils.hoursDiff(start, now) : sum;
    }, 0);
  }
  getBalanceUpToDate(endDate) {
    let balance = 0;
    const startDate = "2025-11-05";
    const sortedDays = Object.keys(this.daily).filter((day) => day >= startDate && day <= endDate).sort();
    for (const day of sortedDays) {
      const dayGoal = this.getDailyGoal(day);
      const dayEntries = this.daily[day] || [];
      let dayWorked = 0;
      let avspaseringHours = 0;
      dayEntries.forEach((e) => {
        if (e.name.toLowerCase() === "avspasering") {
          avspaseringHours += e.duration || 0;
        } else {
          dayWorked += e.duration || 0;
        }
      });
      if (dayGoal === 0) {
        balance += dayWorked;
      } else {
        balance += dayWorked - dayGoal;
      }
      balance -= avspaseringHours;
    }
    return balance;
  }
  getCurrentBalance() {
    const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    return this.getBalanceUpToDate(today);
  }
  getTotalFlextime() {
    return this.getCurrentBalance();
  }
  getCurrentWeekHours(today) {
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    const lastDayOfWeek = new Date(firstDayOfWeek);
    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
    let total = 0;
    for (let d = new Date(firstDayOfWeek); d <= lastDayOfWeek; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "egenmelding" && name !== "velferdspermisjon" && name !== "ferie") {
          total += entry.duration || 0;
        }
      });
    }
    return total + this.getOngoing();
  }
  getTodayHours(today) {
    const todayKey = Utils.toLocalDateStr(today);
    const todayEntries = this.daily[todayKey] || [];
    return todayEntries.reduce((sum, e) => sum + (e.duration || 0), 0) + this.getOngoing();
  }
  getAverages() {
    if (this._cachedAverages) {
      return this._cachedAverages;
    }
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const pastKeys = Object.keys(this.daily).filter((d) => d < todayKey);
    const totalHoursWorked = pastKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const avgDaily = pastKeys.length > 0 ? totalHoursWorked / pastKeys.length : 0;
    const avgWeekly = totalHoursWorked / (pastKeys.length / this.settings.workdaysPerWeek || 1);
    this._cachedAverages = {
      avgDaily,
      avgWeekly,
      totalDaysWorked: pastKeys.length,
      totalHoursWorked
    };
    return this._cachedAverages;
  }
  getStatistics(timeframe = "total") {
    const today = /* @__PURE__ */ new Date();
    let filterFn;
    if (timeframe === "year") {
      const currentYear = today.getFullYear();
      filterFn = (dateStr) => new Date(dateStr).getFullYear() === currentYear;
    } else if (timeframe === "month") {
      const currentYear = today.getFullYear();
      const currentMonth = today.getMonth();
      filterFn = (dateStr) => {
        const d = new Date(dateStr);
        return d.getFullYear() === currentYear && d.getMonth() === currentMonth;
      };
    } else {
      filterFn = () => true;
    }
    const filteredDays = Object.keys(this.daily).filter(filterFn);
    const allEntries = filteredDays.flatMap((day) => this.daily[day]);
    const stats = {
      totalHours: allEntries.reduce((sum, e) => sum + (e.duration || 0), 0),
      totalFlextime: allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0),
      jobb: { count: 0, hours: 0 },
      avspasering: { count: 0, hours: 0, planned: 0 },
      ferie: { count: 0, hours: 0, max: 25, planned: 0 },
      velferdspermisjon: { count: 0, hours: 0, planned: 0 },
      egenmelding: { count: 0, hours: 0, max: 24 },
      studie: { count: 0, hours: 0, planned: 0 },
      kurs: { count: 0, hours: 0, planned: 0 },
      workDays: 0,
      weekendDays: 0,
      avgDailyHours: 0,
      workloadPercent: 0
    };
    const daysByType = {
      jobb: /* @__PURE__ */ new Set(),
      avspasering: /* @__PURE__ */ new Set(),
      ferie: /* @__PURE__ */ new Set(),
      velferdspermisjon: /* @__PURE__ */ new Set(),
      egenmelding: /* @__PURE__ */ new Set(),
      studie: /* @__PURE__ */ new Set(),
      kurs: /* @__PURE__ */ new Set()
    };
    const uniqueDays = /* @__PURE__ */ new Set();
    const weekendDaysSet = /* @__PURE__ */ new Set();
    const workDaysSet = /* @__PURE__ */ new Set();
    filteredDays.forEach((dayKey) => {
      const dayDate = new Date(dayKey);
      const dayEntries = this.daily[dayKey];
      uniqueDays.add(dayKey);
      dayEntries.forEach((e) => {
        const name = e.name.toLowerCase();
        if (e.date && Utils.isWeekend(e.date)) {
          weekendDaysSet.add(dayKey);
        } else {
          workDaysSet.add(dayKey);
        }
        if (name === "jobb" || !["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType.jobb.add(dayKey);
          stats.jobb.hours += e.duration || 0;
        } else if (["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType[name].add(dayKey);
          stats[name].hours += e.duration || 0;
        }
      });
    });
    stats.weekendDays = weekendDaysSet.size;
    stats.workDays = workDaysSet.size;
    stats.jobb.count = daysByType.jobb.size;
    stats.avspasering.count = daysByType.avspasering.size;
    stats.ferie.count = daysByType.ferie.size;
    stats.velferdspermisjon.count = daysByType.velferdspermisjon.size;
    stats.egenmelding.count = daysByType.egenmelding.size;
    stats.studie.count = daysByType.studie.size;
    stats.kurs.count = daysByType.kurs.size;
    Object.keys(this.holidays).forEach((dateStr) => {
      const plannedInfo = this.holidays[dateStr];
      const plannedDate = new Date(dateStr);
      if (filterFn(dateStr) && plannedDate > today) {
        const type = plannedInfo.type;
        if (type === "ferie" && stats.ferie) {
          stats.ferie.planned++;
        } else if (type === "avspasering" && stats.avspasering) {
          stats.avspasering.planned++;
        } else if (type === "velferdspermisjon" && stats.velferdspermisjon) {
          stats.velferdspermisjon.planned++;
        } else if (type === "studie" && stats.studie) {
          stats.studie.planned++;
        } else if (type === "kurs" && stats.kurs) {
          stats.kurs.planned++;
        }
      }
    });
    stats.avgDailyHours = uniqueDays.size > 0 ? stats.totalHours / uniqueDays.size : 0;
    if (timeframe === "year" || timeframe === "month") {
      const expectedWorkdays = timeframe === "year" ? this.settings.workdaysPerYear : this.settings.workdaysPerMonth;
      const expectedHours = expectedWorkdays * this.workdayHours;
      stats.workloadPercent = expectedHours > 0 ? stats.totalHours / expectedHours * 100 : 0;
    }
    return stats;
  }
  getContextualData(today) {
    const todayKey = Utils.toLocalDateStr(today);
    if (this._cachedContextData[todayKey]) {
      return this._cachedContextData[todayKey];
    }
    const weekday = today.getDay();
    let consecutiveFlextimeDays = 0;
    const sortedDays = Object.keys(this.daily).sort().reverse();
    for (let day of sortedDays) {
      if (day >= todayKey)
        continue;
      const dayFlextime = this.daily[day].reduce(
        (sum, e) => sum + (e.flextime || 0),
        0
      );
      if (dayFlextime > 0) {
        consecutiveFlextimeDays++;
      } else {
        break;
      }
    }
    const sameWeekdayKeys = Object.keys(this.daily).filter((d) => {
      const date = new Date(d);
      return date.getDay() === weekday && d < todayKey;
    });
    const sameDayTotal = sameWeekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const sameDayAvg = sameWeekdayKeys.length > 0 ? sameDayTotal / sameWeekdayKeys.length : 0;
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const thisWeekMonday = new Date(today);
    thisWeekMonday.setDate(today.getDate() - daysFromMonday);
    const lastWeekStart = new Date(thisWeekMonday);
    lastWeekStart.setDate(thisWeekMonday.getDate() - 7);
    const lastWeekEnd = new Date(lastWeekStart);
    lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
    let lastWeekHours = 0;
    for (let d = new Date(lastWeekStart); d <= lastWeekEnd; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      lastWeekHours += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
    }
    const result = { consecutiveFlextimeDays, sameDayAvg, lastWeekHours };
    this._cachedContextData[todayKey] = result;
    return result;
  }
  getWeekTotals(numWeeks = 8) {
    const today = /* @__PURE__ */ new Date();
    const weekTotals = [];
    for (let i = numWeeks - 1; i >= 0; i--) {
      const d = new Date(today);
      d.setDate(today.getDate() - i * 7);
      const dayOfWeek = d.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const weekStart = new Date(d);
      weekStart.setDate(d.getDate() - daysFromMonday);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      let weekSum = 0;
      for (let wd = new Date(weekStart); wd <= weekEnd; wd = new Date(wd.getFullYear(), wd.getMonth(), wd.getDate() + 1)) {
        const dayKey = Utils.toLocalDateStr(wd);
        const dayEntries = this.daily[dayKey] || [];
        weekSum += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
      }
      weekTotals.push(weekSum);
    }
    return weekTotals;
  }
  validateData() {
    const issues = {
      errors: [],
      warnings: [],
      info: [],
      stats: {
        totalEntries: 0,
        entriesChecked: 0,
        entriesWithIssues: 0
      }
    };
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const createIssue = (severity, type, description, entry, dayKey) => {
      issues.stats.entriesWithIssues++;
      return {
        severity,
        type,
        description,
        date: dayKey,
        entry: {
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          duration: entry.duration
        }
      };
    };
    for (const dayKey in this.daily) {
      const dayEntries = this.daily[dayKey];
      issues.stats.totalEntries += dayEntries.length;
      dayEntries.forEach((entry) => {
        var _a, _b, _c;
        issues.stats.entriesChecked++;
        if (!entry.name || entry.name.trim() === "") {
          issues.errors.push(createIssue(
            "error",
            "Missing Entry Name",
            "Entry has no name/type",
            entry,
            dayKey
          ));
        }
        if (!entry.startTime) {
          issues.errors.push(createIssue(
            "error",
            "Missing Start Time",
            "Entry has no start time",
            entry,
            dayKey
          ));
          return;
        }
        if ((entry.duration || 0) < 0) {
          issues.errors.push(createIssue(
            "error",
            "Negative Duration",
            `End time is before start time (${(_a = entry.duration) == null ? void 0 : _a.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > 24) {
          issues.errors.push(createIssue(
            "error",
            "Excessive Duration",
            `Entry spans more than 24 hours (${(_b = entry.duration) == null ? void 0 : _b.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > 16 && (entry.duration || 0) <= 24) {
          issues.warnings.push(createIssue(
            "warning",
            "Very Long Session",
            `Entry duration exceeds 16 hours (${(_c = entry.duration) == null ? void 0 : _c.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) === 0) {
          issues.info.push(createIssue(
            "info",
            "Zero Duration",
            "Entry has zero duration",
            entry,
            dayKey
          ));
        }
        if (dayKey > todayStr) {
          issues.info.push(createIssue(
            "info",
            "Future Date",
            "Entry is dated in the future",
            entry,
            dayKey
          ));
        }
      });
    }
    issues.stats.totalEntries += this.activeEntries.length;
    this.activeEntries.forEach((entry) => {
      issues.stats.entriesChecked++;
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        const now = /* @__PURE__ */ new Date();
        const hoursRunning = Utils.hoursDiff(startTime, now);
        if (hoursRunning > 12) {
          issues.warnings.push({
            severity: "warning",
            type: "Long-Running Timer",
            description: `Active timer has been running for ${hoursRunning.toFixed(1)} hours`,
            date: Utils.toLocalDateStr(startTime),
            entry: {
              name: entry.name,
              startTime: entry.startTime,
              duration: hoursRunning
            }
          });
          issues.stats.entriesWithIssues++;
        }
      }
    });
    const currentWeekHours = this.getCurrentWeekHours(today);
    if (currentWeekHours > 60) {
      issues.info.push({
        severity: "info",
        type: "High Weekly Total",
        description: `Current week total exceeds 60 hours (${currentWeekHours.toFixed(1)}h)`,
        date: todayStr
      });
    }
    return {
      hasErrors: issues.errors.length > 0,
      hasWarnings: issues.warnings.length > 0,
      hasInfo: issues.info.length > 0,
      issues,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};

// src/uiBuilder.ts
var import_obsidian4 = require("obsidian");

// src/messageGenerator.ts
var MessageGenerator = class {
  static getDailyMessage(hours, goal, specials, isWeekendDay, avgDaily, context, consecutiveFlextimeWarningDays) {
    if (isWeekendDay) {
      const weekday = (/* @__PURE__ */ new Date()).getDay();
      if (weekday === 6) {
        if (hours === 0)
          return Utils.randMsg([
            "L\xF8rdag \u2013 ingen logg enn\xE5, perfekt for fri \u{1F6CC}",
            "Fri-modus: nyt l\xF8rdagen! \u{1F324}\uFE0F"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "Litt helgeinnsats \u2013 godt gjort!",
            "Rolig l\xF8rdag med litt arbeid \u2013 fin balanse \u2696\uFE0F"
          ]);
        return Utils.randMsg([
          "\u{1F525} Jobbing p\xE5 l\xF8rdagen \u2013 imponerende dedikasjon!",
          "L\xF8rdag med driv \u2013 pass p\xE5 \xE5 hvile litt ogs\xE5 \u{1F486}"
        ]);
      }
      if (weekday === 0) {
        if (hours === 0)
          return Utils.randMsg([
            "S\xF8ndag \u2013 helt fri, slik det skal v\xE6re \u2615",
            "S\xF8ndag \u2013 lade opp til en ny uke \u{1F33F}"
          ]);
        return Utils.randMsg([
          "Litt s\xF8ndagsjobbing \u2013 godt for samvittigheten \u{1F4AA}",
          "Rolig s\xF8ndag med litt innsats \u2013 flott balansert \u{1F31E}"
        ]);
      }
    }
    if (specials.length > 0) {
      const s = specials.join(", ").toLowerCase();
      const now2 = /* @__PURE__ */ new Date();
      const currentHour2 = now2.getHours();
      if (s.includes("ferie")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u2600\uFE0F Feriemorgen \u2013 sov lenge og slapp av!",
            "\u{1F3D6}\uFE0F Ferie \u2013 ingen tidlig start i dag!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u2600\uFE0F Nyt ferien \u2013 du har fortjent det!",
            "\u{1F334} Feriedag \u2013 gj\xF8r noe hyggelig!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Feriekveld \u2013 kos deg!",
          "\u2728 Ferieflyt \u2013 nyt kvelden!"
        ]);
      }
      if (s.includes("velferdspermisjon")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 ta vare p\xE5 deg selv",
            "\u{1F49A} Viktig dag for velv\xE6re \u2013 bruk tiden godt"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 h\xE5per alt g\xE5r bra",
            "\u{1F49A} Ta den tiden du trenger i dag"
          ]);
        return Utils.randMsg([
          "\u{1F319} Velferdspermisjon \u2013 hvil og ta vare p\xE5 deg",
          "\u2728 Viktig \xE5 prioritere eget velv\xE6re"
        ]);
      }
      if (s.includes("avspasering")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F6CC} Avspasering \u2013 perfekt dag for litt ekstra s\xF8vn!",
            "\u{1F634} Fri dag \u2013 du har fortjent denne hvilen!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F6CC} Godt med litt fri \u2013 du har fortjent det!",
            "\u{1F486} Avspasering \u2013 bruk dagen p\xE5 noe du liker!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Avspasering \u2013 slapp av resten av kvelden!",
          "\u2728 Fin fridag \u2013 h\xE5per du har hatt en god dag!"
        ]);
      }
      if (s.includes("egenmelding")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F912} Egenmelding \u2013 hvil og bli frisk!",
            "\u{1F48A} Ta det rolig \u2013 kroppen trenger hvile!"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "\u{1F912} Egenmelding, men du har v\xE6rt litt aktiv \u2013 ikke overdriv!",
            "\u{1F48A} H\xE5per du f\xF8ler deg bedre \u2013 husk \xE5 hvile!"
          ]);
        return Utils.randMsg([
          "\u{1F912} Egenmelding med mye aktivitet \u2013 pass p\xE5 \xE5 ikke presse deg!",
          "\u{1F48A} Ta vare p\xE5 deg selv \u2013 hvil er viktig!"
        ]);
      }
      if (s.includes("studie") || s.includes("kurs")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F4D6} Studiedag \u2013 tid for \xE5 l\xE6re noe nytt!",
            "\u{1F4DA} Studietid \u2013 lykke til med l\xE6ringen!"
          ]);
        if (hours < 3)
          return Utils.randMsg([
            "\u{1F4D6} God start p\xE5 studiedagen \u2013 fortsett s\xE5nn!",
            "\u{1F4DA} Fin studieflyt s\xE5 langt!"
          ]);
        if (hours < 5)
          return Utils.randMsg([
            "\u{1F4D6} Solid studieinnsats \u2013 godt jobbet!",
            "\u{1F4DA} Du l\xE6rer mye i dag \u2013 flott fremgang!"
          ]);
        return Utils.randMsg([
          "\u{1F4D6} Imponerende studieinnsats i dag \u2013 husk pauser!",
          "\u{1F4DA} Dedikert studiedag \u2013 fantastisk innsats!"
        ]);
      }
    }
    const diff = hours - goal;
    const now = /* @__PURE__ */ new Date();
    const currentHour = now.getHours();
    if (context.consecutiveFlextimeDays >= consecutiveFlextimeWarningDays) {
      return `\u26A0\uFE0F ${context.consecutiveFlextimeDays} dager p\xE5 rad med fleksitid \u2013 husk \xE5 ta vare p\xE5 deg selv!`;
    }
    if (context.sameDayAvg > 0) {
      const weekdayName = [
        "s\xF8ndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "l\xF8rdag"
      ][now.getDay()];
      if (hours > context.sameDayAvg + 1) {
        return `Mer aktiv enn vanlig for en ${weekdayName} \u{1F4AA} (snitt: ${context.sameDayAvg.toFixed(1)}t)`;
      }
      if (hours < context.sameDayAvg - 1 && hours > 2) {
        return `Roligere ${weekdayName} enn vanlig (snitt: ${context.sameDayAvg.toFixed(1)}t) \u{1F33F}`;
      }
    }
    if (currentHour < 12 && hours === 0) {
      return "God morgen! Dagen starter rolig \u2615";
    }
    if (currentHour >= 15 && diff < -2) {
      const hoursNeeded = (goal - hours).toFixed(1);
      return `${hoursNeeded}t igjen for \xE5 n\xE5 dagsm\xE5l \u2013 fortsatt mulig! \u{1F3AF}`;
    }
    if (currentHour >= 16 && hours >= goal) {
      return "Dagsm\xE5l n\xE5dd! \u{1F389} Ta en pause eller jobb videre mot fleksitid.";
    }
    if (avgDaily > 0) {
      if (hours > avgDaily + 1)
        return "Du ligger over snittet for de siste dagene \u{1F44D}";
      if (hours < avgDaily - 1)
        return "Litt roligere enn vanlig \u2013 fullt fortjent \u{1F486}";
    }
    if (hours === 0)
      return "Rolig start \u2013 kanskje planlegg dagen?";
    if (diff < -1)
      return "Dagen har s\xE5 vidt begynt \u2013 god tid til \xE5 n\xE5 m\xE5let.";
    if (diff >= -1 && diff <= 1)
      return "Du ligger helt perfekt an i dag \u{1F44C}";
    if (diff > 1 && diff <= 2)
      return "Sterk innsats \u2013 n\xE6rmer deg fleksitid \u{1F4AA}";
    if (diff > 2)
      return "\u{1F680} Ekstra innsats i dag! Husk \xE5 ta deg tid til en pause.";
    return "";
  }
  static getWeeklyMessage(hours, goal, specials, today, context, weekendWorkHours = 0) {
    const ferie = specials.some((s) => s.toLowerCase().includes("ferie"));
    const velferdspermisjon = specials.some((s) => s.toLowerCase().includes("velferdspermisjon"));
    const avsp = specials.some((s) => s.toLowerCase().includes("avspasering"));
    const studie = specials.some((s) => s.toLowerCase().includes("studie") || s.toLowerCase().includes("kurs"));
    if (ferie)
      return "\u{1F3D6}\uFE0F Ukas rytme er preget av ferie \u2013 nyt det! ";
    if (velferdspermisjon)
      return "\u{1F3E5} Velferdspermisjon denne uka \u2013 ta vare p\xE5 deg selv! ";
    if (avsp)
      return "\u{1F60C} Litt fri denne uka \u2013 god balanse. ";
    if (studie)
      return "\u{1F4DA} Denne uka har du prioritert studier \u2013 flott! ";
    const weekday = today.getDay();
    const isWeekendDay = weekday === 6 || weekday === 0;
    const workdaysPassed = Math.min(Math.max(weekday - 1, 0), 5);
    const totalWorkdays = 5;
    const expectedProgress = workdaysPassed / totalWorkdays * goal;
    const diffFromExpected = hours - expectedProgress;
    if (context.lastWeekHours > 0) {
      const diff2 = hours - context.lastWeekHours;
      if (Math.abs(diff2) > 5 && workdaysPassed >= 3) {
        if (diff2 > 0) {
          return `Mer travelt enn forrige uke (+${diff2.toFixed(1)}t) \u{1F4C8} `;
        } else {
          return `Roligere enn forrige uke (${diff2.toFixed(1)}t) \u{1F4C9} `;
        }
      }
    }
    if (isWeekendDay) {
      if (weekendWorkHours === 0)
        return "\u{1F319} Helg! Godt jobbet denne uka \u2013 nyt fritiden. ";
      if (weekendWorkHours < 2)
        return "\u{1F4C5} Litt helgeinnsats \u2013 ikke glem pauser og p\xE5fyll! ";
      if (hours >= goal)
        return "\u{1F525} Jobbing i helga \u2013 imponerende dedikasjon, men pass p\xE5 \xE5 hvile! ";
      return "\u{1F31E} En rolig helg etter en balansert uke. ";
    }
    if (workdaysPassed <= 1) {
      if (hours < expectedProgress)
        return "Uka er i gang \u2013 ta det i eget tempo \u{1F4AA} ";
      if (diffFromExpected >= 1)
        return "Sterk start p\xE5 uka! \u{1F31F} ";
      return "Fin rytme s\xE5 langt \u2013 fortsett s\xE5nn. ";
    }
    if (workdaysPassed >= 2 && workdaysPassed <= 3) {
      if (diffFromExpected < -2)
        return "Du ligger litt bak skjema \u2013 men fortsatt god tid til \xE5 hente inn \u{1F33F} ";
      if (diffFromExpected >= -2 && diffFromExpected <= 2)
        return "Jevn og fin flyt gjennom uka \u{1F44C} ";
      if (diffFromExpected > 2)
        return "Travle dager \u2013 men du h\xE5ndterer det godt \u{1F4AA} ";
    }
    if (weekday === 5) {
      if (hours < goal * 0.8)
        return "Fredag \u2013 snart helg! Du er nesten i m\xE5l \u{1F3AF} ";
      if (hours >= goal && hours <= goal + 3)
        return "\u{1F44D} Uka i boks \u2013 god innsats! ";
      if (hours > goal + 3)
        return "\u{1F525} Ekstra innsats denne uka \u2013 husk \xE5 logge fleksitid! ";
      return "Fredagsflyt \u{1F324}\uFE0F ";
    }
    const diff = hours - goal;
    if (diff < -3)
      return "Du ligger litt bak skjema \u2013 ingen fare, uka er ung! ";
    if (diff >= -3 && diff <= 2)
      return "Fin flyt denne uka \u{1F33F} ";
    if (diff > 2 && diff <= 5)
      return "Travelt, men godt jobbet! ";
    if (diff > 5)
      return "\u{1F525} Ekstra innsats denne uka \u2013 pass p\xE5 hvilen! ";
    return "";
  }
};

// src/importModal.ts
var import_obsidian3 = require("obsidian");
var ImportModal = class extends import_obsidian3.Modal {
  constructor(app, timerManager, onSuccess) {
    super(app);
    this.timerManager = timerManager;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Import Timekeep Data" });
    contentEl.createEl("p", {
      text: "Paste your Timekeep JSON data below. This can be from a timekeep codeblock or exported data.",
      cls: "setting-item-description"
    });
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "15",
        placeholder: '{"entries":[...]}'
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} How to get your data:" });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: "Open your file with Timekeep codeblocks" });
    list.createEl("li", { text: "Copy the entire JSON from inside the timekeep block" });
    list.createEl("li", { text: "Paste it in the text area above" });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const importBtn = buttonDiv.createEl("button", { text: "Import", cls: "mod-cta" });
    importBtn.onclick = async () => {
      const jsonText = textArea.value.trim();
      if (!jsonText) {
        new import_obsidian3.Notice("\u26A0\uFE0F Please paste your Timekeep data");
        return;
      }
      try {
        const data = JSON.parse(jsonText);
        if (!data.entries || !Array.isArray(data.entries)) {
          new import_obsidian3.Notice('\u26A0\uFE0F Invalid format: missing "entries" array');
          return;
        }
        if (data.entries.length > 0) {
          const firstEntry = data.entries[0];
          if (!firstEntry.hasOwnProperty("name") || !firstEntry.hasOwnProperty("startTime")) {
            new import_obsidian3.Notice("\u26A0\uFE0F Invalid entry format: missing required fields (name, startTime)");
            return;
          }
        }
        const success = await this.timerManager.importTimekeepData(jsonText);
        if (success) {
          new import_obsidian3.Notice(`\u2705 Successfully imported ${data.entries.length} entries!`);
          this.close();
          this.onSuccess();
        } else {
          new import_obsidian3.Notice("\u274C Failed to import data");
        }
      } catch (error) {
        if (error instanceof SyntaxError) {
          new import_obsidian3.Notice("\u26A0\uFE0F Invalid JSON format. Please check your data.");
        } else {
          new import_obsidian3.Notice(`\u274C Error: ${error.message}`);
        }
        console.error("Import error:", error);
      }
    };
    const hint = contentEl.createEl("div");
    hint.style.marginTop = "10px";
    hint.style.fontSize = "12px";
    hint.style.color = "var(--text-muted)";
    hint.textContent = '\u{1F4A1} Tip: You can also create "TimeFlow Data.md" manually in your vault root';
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/uiBuilder.ts
var UIBuilder = class {
  constructor(dataManager, systemStatus, settings, app, timerManager) {
    this.intervals = [];
    this.statsTimeframe = "total";
    this.historyView = "list";
    this.currentMonthOffset = 0;
    this.data = dataManager;
    this.systemStatus = systemStatus;
    this.settings = settings;
    this.app = app;
    this.timerManager = timerManager;
    this.container = this.createContainer();
    this.today = /* @__PURE__ */ new Date();
    this.elements = {
      badge: null,
      clock: null,
      dayCard: null,
      weekCard: null,
      statsCard: null,
      monthCard: null,
      timerControls: null
    };
  }
  createContainer() {
    const container = document.createElement("div");
    container.style.fontFamily = "sans-serif";
    container.style.maxWidth = "1200px";
    container.style.margin = "0 auto";
    container.style.padding = "20px";
    return container;
  }
  injectStyles() {
    const styleId = "timeflow-styles";
    if (document.getElementById(styleId))
      return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
			/* TimeFlow Dashboard Styles */
			.timeflow-dashboard {
				font-family: var(--font-text);
				max-width: 1200px;
				margin: 0 auto;
				padding: 20px;
			}

			.timeflow-error, .timeflow-warning {
				padding: 15px;
				border-radius: 5px;
				margin: 10px 0;
			}

			.timeflow-error {
				background: var(--background-modifier-error);
				color: var(--text-error);
			}

			.timeflow-warning {
				background: var(--background-modifier-warning);
				color: var(--text-warning);
			}

			.tf-badge-section {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 20px;
				flex-wrap: wrap;
				gap: 15px;
			}

			.tf-badge {
				padding: 12px 24px;
				border-radius: 8px;
				font-size: 20px;
				font-weight: bold;
				text-align: center;
				min-width: 200px;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			.tf-clock {
				font-size: 24px;
				font-weight: bold;
				color: var(--text-normal);
			}

			.tf-summary-cards {
				display: flex;
				gap: 15px;
				margin-bottom: 20px;
				flex-wrap: wrap;
			}

			.tf-card {
				flex: 1;
				min-width: 280px;
				padding: 20px;
				border-radius: 8px;
				background: var(--background-primary-alt);
				border: 1px solid var(--background-modifier-border);
				box-shadow: 0 2px 8px rgba(0,0,0,0.05);
			}

			.tf-card h3 {
				margin-top: 0;
				margin-bottom: 15px;
				font-size: 18px;
				color: var(--text-normal);
			}

			.tf-progress-bar {
				width: 100%;
				height: 12px;
				background: var(--background-secondary);
				border-radius: 6px;
				overflow: hidden;
				margin: 10px 0;
			}

			.tf-progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #4caf50, #8bc34a);
				transition: width 0.3s ease;
			}

			.tf-month-grid {
				display: grid;
				grid-template-columns: repeat(7, 1fr);
				gap: 8px;
				margin-top: 15px;
			}

			.tf-day-cell {
				aspect-ratio: 1;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 6px;
				font-size: 14px;
				cursor: pointer;
				transition: all 0.2s;
				position: relative;
				border: 2px solid transparent;
			}

			.tf-day-cell:hover {
				transform: scale(1.05);
				box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			}

			.tf-day-cell.today {
				border-color: var(--interactive-accent);
				font-weight: bold;
			}

			.tf-stats-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 15px;
				margin-top: 15px;
			}

			.tf-stat-item {
				padding: 15px;
				background: var(--background-secondary);
				border-radius: 6px;
			}

			.tf-stat-label {
				font-size: 12px;
				color: var(--text-muted);
				margin-bottom: 5px;
			}

			.tf-stat-value {
				font-size: 20px;
				font-weight: bold;
				color: var(--text-normal);
			}

			.tf-tabs {
				display: flex;
				gap: 10px;
				margin-bottom: 15px;
				border-bottom: 2px solid var(--background-modifier-border);
			}

			.tf-tab {
				padding: 8px 16px;
				cursor: pointer;
				border: none;
				background: transparent;
				color: var(--text-muted);
				font-size: 14px;
				transition: all 0.2s;
			}

			.tf-tab.active {
				color: var(--interactive-accent);
				border-bottom: 2px solid var(--interactive-accent);
				margin-bottom: -2px;
			}

			.tf-tab:hover {
				color: var(--text-normal);
			}

			.tf-button {
				padding: 8px 16px;
				border-radius: 6px;
				border: 1px solid var(--background-modifier-border);
				background: var(--interactive-normal);
				color: var(--text-normal);
				cursor: pointer;
				font-size: 14px;
				transition: all 0.2s;
			}

			.tf-button:hover {
				background: var(--interactive-hover);
			}

			.tf-heatmap {
				display: grid;
				gap: 4px;
				margin-top: 15px;
			}

			.tf-heatmap-cell {
				width: 100%;
				aspect-ratio: 1;
				border-radius: 3px;
				cursor: pointer;
				transition: transform 0.2s;
			}

			.tf-heatmap-cell:hover {
				transform: scale(1.2);
			}

			.tf-context-menu {
				position: absolute;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				box-shadow: 0 4px 16px rgba(0,0,0,0.2);
				padding: 8px 0;
				z-index: 1000;
				min-width: 200px;
			}

			.tf-menu-item {
				padding: 8px 16px;
				cursor: pointer;
				transition: background 0.2s;
				display: flex;
				align-items: center;
				gap: 10px;
			}

			.tf-menu-item:hover {
				background: var(--background-modifier-hover);
			}

			.tf-menu-separator {
				height: 1px;
				background: var(--background-modifier-border);
				margin: 4px 0;
			}

			.tf-status-bar {
				margin-top: 20px;
				padding: 15px;
				background: var(--background-secondary-alt);
				border-radius: 6px;
				border-left: 4px solid var(--interactive-accent);
			}

			.tf-collapsible {
				cursor: pointer;
				user-select: none;
			}

			.tf-collapsible-content {
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.3s ease;
			}

			.tf-collapsible-content.open {
				max-height: 1000px;
			}

			@media (max-width: 768px) {
				.tf-summary-cards {
					flex-direction: column;
				}

				.tf-stats-grid {
					grid-template-columns: 1fr;
				}

				.tf-month-grid {
					gap: 4px;
				}
			}
		`;
    document.head.appendChild(style);
  }
  buildBadgeSection() {
    const section = document.createElement("div");
    section.className = "tf-badge-section";
    const badge = document.createElement("div");
    badge.className = "tf-badge";
    this.elements.badge = badge;
    const timerControls = document.createElement("div");
    timerControls.style.display = "flex";
    timerControls.style.gap = "10px";
    timerControls.style.alignItems = "center";
    this.elements.timerControls = timerControls;
    this.updateTimerControls();
    const clock = document.createElement("div");
    clock.className = "tf-clock";
    this.elements.clock = clock;
    section.appendChild(badge);
    section.appendChild(timerControls);
    section.appendChild(clock);
    this.updateBadge();
    this.updateClock();
    return section;
  }
  updateTimerControls() {
    if (!this.elements.timerControls)
      return;
    this.elements.timerControls.innerHTML = "";
    const activeTimers = this.timerManager.getActiveTimers();
    if (activeTimers.length === 0) {
      const startBtn = document.createElement("button");
      startBtn.className = "tf-button";
      startBtn.textContent = "\u25B6\uFE0F Start Timer";
      startBtn.style.background = "#4caf50";
      startBtn.style.color = "white";
      startBtn.style.fontWeight = "bold";
      startBtn.onclick = async () => {
        await this.timerManager.startTimer("jobb");
        this.updateTimerControls();
      };
      this.elements.timerControls.appendChild(startBtn);
    } else {
      activeTimers.forEach((timer) => {
        const timerDisplay = document.createElement("div");
        timerDisplay.style.display = "flex";
        timerDisplay.style.alignItems = "center";
        timerDisplay.style.gap = "8px";
        timerDisplay.style.padding = "8px 12px";
        timerDisplay.style.background = "var(--background-primary-alt)";
        timerDisplay.style.borderRadius = "6px";
        timerDisplay.style.border = "2px solid #4caf50";
        const runningTime = this.timerManager.getRunningTime(timer);
        const timerText = document.createElement("span");
        timerText.textContent = `\u23F1\uFE0F ${timer.name}: ${Utils.formatHoursToHM(runningTime)}`;
        timerText.style.fontWeight = "bold";
        const stopBtn = document.createElement("button");
        stopBtn.className = "tf-button";
        stopBtn.textContent = "\u23F9\uFE0F Stop";
        stopBtn.style.background = "#f44336";
        stopBtn.style.color = "white";
        stopBtn.onclick = async () => {
          await this.timerManager.stopTimer(timer);
          this.updateTimerControls();
        };
        timerDisplay.appendChild(timerText);
        timerDisplay.appendChild(stopBtn);
        this.elements.timerControls.appendChild(timerDisplay);
      });
    }
    const importBtn = document.createElement("button");
    importBtn.className = "tf-button";
    importBtn.textContent = "\u{1F4E5} Import";
    importBtn.style.background = "#2196f3";
    importBtn.style.color = "white";
    importBtn.style.fontWeight = "bold";
    importBtn.style.marginLeft = "8px";
    importBtn.onclick = () => {
      new ImportModal(this.app, this.timerManager, () => {
        new import_obsidian4.Notice("Dashboard oppdatert!");
      }).open();
    };
    this.elements.timerControls.appendChild(importBtn);
  }
  buildSummaryCards() {
    const container = document.createElement("div");
    container.className = "tf-summary-cards";
    container.appendChild(this.createDayCard());
    container.appendChild(this.createWeekCard());
    container.appendChild(this.createMonthCard());
    return container;
  }
  createDayCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    this.elements.dayCard = card;
    this.updateDayCard();
    return card;
  }
  createWeekCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    this.elements.weekCard = card;
    this.updateWeekCard();
    return card;
  }
  createMonthCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "15px";
    const title = document.createElement("h3");
    title.textContent = "M\xE5nedskalender";
    title.style.margin = "0";
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    const prevBtn = document.createElement("button");
    prevBtn.textContent = "\u2190";
    prevBtn.className = "tf-button";
    prevBtn.onclick = () => {
      this.currentMonthOffset--;
      this.updateMonthCard();
    };
    const todayBtn = document.createElement("button");
    todayBtn.textContent = "I dag";
    todayBtn.className = "tf-button";
    todayBtn.onclick = () => {
      this.currentMonthOffset = 0;
      this.updateMonthCard();
    };
    const nextBtn = document.createElement("button");
    nextBtn.textContent = "\u2192";
    nextBtn.className = "tf-button";
    nextBtn.onclick = () => {
      this.currentMonthOffset++;
      this.updateMonthCard();
    };
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const gridContainer = document.createElement("div");
    this.elements.monthCard = gridContainer;
    card.appendChild(gridContainer);
    this.updateMonthCard();
    return card;
  }
  createStatsCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    const header = document.createElement("h3");
    header.textContent = "Statistikk";
    card.appendChild(header);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    const timeframes = ["total", "year", "month"];
    const labels = { total: "Totalt", year: "\xC5r", month: "M\xE5ned" };
    timeframes.forEach((tf) => {
      const tab = document.createElement("button");
      tab.className = `tf-tab ${tf === this.statsTimeframe ? "active" : ""}`;
      tab.textContent = labels[tf];
      tab.onclick = () => {
        this.statsTimeframe = tf;
        this.updateStatsCard();
      };
      tabs.appendChild(tab);
    });
    card.appendChild(tabs);
    const statsContainer = document.createElement("div");
    statsContainer.className = "tf-stats-grid";
    this.elements.statsCard = statsContainer;
    card.appendChild(statsContainer);
    this.updateStatsCard();
    return card;
  }
  buildInfoCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    header.innerHTML = "<h3 style='margin:0'>\u2139\uFE0F Informasjon</h3>";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    content.innerHTML = `
			<div style="margin-top: 15px;">
				<h4>Fargeforklaring</h4>
				<div style="display: grid; gap: 8px;">
					${Object.entries(SPECIAL_DAY_COLORS).map(
      ([key, color]) => `<div style="display: flex; align-items: center; gap: 10px;">
							<div style="width: 20px; height: 20px; background: ${color}; border-radius: 4px;"></div>
							<span>${key}</span>
						</div>`
    ).join("")}
				</div>
			</div>
		`;
    header.onclick = () => {
      content.classList.toggle("open");
    };
    card.appendChild(header);
    card.appendChild(content);
    return card;
  }
  buildHistoryCard() {
    const card = document.createElement("div");
    card.className = "tf-card";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "15px";
    const title = document.createElement("h3");
    title.textContent = "Historikk";
    title.style.margin = "0";
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    const views = [
      { id: "list", label: "Liste" },
      { id: "weekly", label: "Uker" },
      { id: "heatmap", label: "Varmekart" }
    ];
    views.forEach((view) => {
      const btn = document.createElement("button");
      btn.textContent = view.label;
      btn.className = `tf-button ${this.historyView === view.id ? "active" : ""}`;
      btn.onclick = () => {
        this.historyView = view.id;
        this.refreshHistoryView(detailsElement);
      };
      controls.appendChild(btn);
    });
    const exportBtn = document.createElement("button");
    exportBtn.textContent = "\u{1F4E5} Export CSV";
    exportBtn.className = "tf-button";
    exportBtn.onclick = () => this.exportCurrentView();
    controls.appendChild(exportBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const detailsElement = document.createElement("div");
    detailsElement.style.maxHeight = "500px";
    detailsElement.style.overflow = "auto";
    card.appendChild(detailsElement);
    this.refreshHistoryView(detailsElement);
    return card;
  }
  buildStatusBar() {
    var _a, _b, _c, _d, _e, _f;
    const bar = document.createElement("div");
    bar.className = "tf-status-bar";
    const status = this.systemStatus;
    const statusIcon = ((_a = status.validation) == null ? void 0 : _a.hasErrors) ? "\u274C" : ((_b = status.validation) == null ? void 0 : _b.hasWarnings) ? "\u26A0\uFE0F" : "\u2705";
    bar.innerHTML = `
			<div style="display: flex; align-items: center; gap: 10px;">
				<span>${statusIcon}</span>
				<div>
					<div><strong>System Status</strong></div>
					<div style="font-size: 12px; color: var(--text-muted);">
						${((_c = status.holiday) == null ? void 0 : _c.message) || "Holiday data not loaded"} \u2022
						${status.activeTimers || 0} active timer(s) \u2022
						${((_f = (_e = (_d = status.validation) == null ? void 0 : _d.issues) == null ? void 0 : _e.stats) == null ? void 0 : _f.totalEntries) || 0} entries checked
					</div>
				</div>
			</div>
		`;
    return bar;
  }
  updateClock() {
    if (!this.elements.clock)
      return;
    const now = /* @__PURE__ */ new Date();
    this.elements.clock.textContent = now.toLocaleTimeString("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  updateBadge() {
    if (!this.elements.badge)
      return;
    const balance = this.data.getCurrentBalance();
    const formatted = Utils.formatHoursToHM(Math.abs(balance));
    const sign = balance >= 0 ? "+" : "-";
    let color = "#4caf50";
    if (balance < -15 || balance > 95) {
      color = "#f44336";
    } else if (balance < 0 || balance > 80) {
      color = "#ff9800";
    }
    this.elements.badge.style.background = color;
    this.elements.badge.style.color = "white";
    this.elements.badge.textContent = `\u23F1\uFE0F Timesaldo: ${sign}${formatted}`;
  }
  updateDayCard() {
    if (!this.elements.dayCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    const goal = this.data.getDailyGoal(todayKey);
    const isWeekendDay = Utils.isWeekend(today);
    const context = this.data.getContextualData(today);
    const { avgDaily } = this.data.getAverages();
    const specials = [];
    const holidayInfo = this.data.getHolidayInfo(todayKey);
    if (holidayInfo) {
      specials.push(holidayInfo.type);
    }
    const message = MessageGenerator.getDailyMessage(
      todayHours,
      goal,
      specials,
      isWeekendDay,
      avgDaily,
      context,
      this.settings.consecutiveFlextimeWarningDays
    );
    const progress = goal > 0 ? Math.min(todayHours / goal * 100, 100) : 0;
    this.elements.dayCard.innerHTML = `
			<h3>\u{1F4C5} I dag</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(todayHours)}
			</div>
			<div style="font-size: 14px; color: var(--text-muted); margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(goal)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%"></div>
			</div>
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		`;
  }
  updateWeekCard() {
    if (!this.elements.weekCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const weekHours = this.data.getCurrentWeekHours(today);
    const baseGoal = this.settings.baseWorkweek * this.settings.workPercent;
    const context = this.data.getContextualData(today);
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    let adjustedGoal = 0;
    let specials = [];
    let weekendWorkHours = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(firstDayOfWeek);
      d.setDate(firstDayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayGoal = this.data.getDailyGoal(dayKey);
      adjustedGoal += dayGoal;
      const holidayInfo = this.data.getHolidayInfo(dayKey);
      if (holidayInfo) {
        specials.push(holidayInfo.type);
      }
      if (Utils.isWeekend(d)) {
        const dayEntries = this.data.daily[dayKey] || [];
        weekendWorkHours += dayEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
      }
    }
    const message = MessageGenerator.getWeeklyMessage(
      weekHours,
      adjustedGoal,
      specials,
      today,
      context,
      weekendWorkHours
    );
    const progress = adjustedGoal > 0 ? Math.min(weekHours / adjustedGoal * 100, 100) : 0;
    this.elements.weekCard.innerHTML = `
			<h3>\u{1F4CA} Denne uken</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(weekHours)}
			</div>
			<div style="font-size: 14px; color: var(--text-muted); margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(adjustedGoal)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%"></div>
			</div>
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		`;
  }
  updateStatsCard() {
    var _a;
    if (!this.elements.statsCard)
      return;
    const stats = this.data.getStatistics(this.statsTimeframe);
    const balance = this.data.getCurrentBalance();
    this.elements.statsCard.innerHTML = `
			<div class="tf-stat-item">
				<div class="tf-stat-label">Timesaldo</div>
				<div class="tf-stat-value">${Utils.formatHoursToHM(Math.abs(balance))}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">Totale timer</div>
				<div class="tf-stat-value">${Utils.formatHoursToHM(stats.totalHours)}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">Gjennomsnitt per dag</div>
				<div class="tf-stat-value">${Utils.formatHoursToHM(stats.avgDailyHours)}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">Arbeidsdager</div>
				<div class="tf-stat-value">${stats.jobb.count}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">Ferie (brukt/planlagt)</div>
				<div class="tf-stat-value">${stats.ferie.count} / ${stats.ferie.planned}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">Avspasering</div>
				<div class="tf-stat-value">${stats.avspasering.count}</div>
			</div>
		`;
    const tabs = (_a = this.elements.statsCard.parentElement) == null ? void 0 : _a.querySelectorAll(".tf-tab");
    tabs == null ? void 0 : tabs.forEach((tab) => {
      var _a2;
      const timeframe = (_a2 = tab.textContent) == null ? void 0 : _a2.toLowerCase();
      if (timeframe === "totalt" && this.statsTimeframe === "total" || timeframe === "\xE5r" && this.statsTimeframe === "year" || timeframe === "m\xE5ned" && this.statsTimeframe === "month") {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
  }
  updateMonthCard() {
    if (!this.elements.monthCard)
      return;
    const displayDate = new Date(this.today);
    displayDate.setMonth(this.today.getMonth() + this.currentMonthOffset);
    const grid = this.createMonthGrid(displayDate);
    this.elements.monthCard.innerHTML = "";
    this.elements.monthCard.appendChild(grid);
  }
  createMonthGrid(displayDate) {
    const year = displayDate.getFullYear();
    const month = displayDate.getMonth();
    const monthName = displayDate.toLocaleDateString("nb-NO", { month: "long", year: "numeric" });
    const container = document.createElement("div");
    const monthTitle = document.createElement("div");
    monthTitle.textContent = monthName;
    monthTitle.style.textAlign = "center";
    monthTitle.style.fontWeight = "bold";
    monthTitle.style.marginBottom = "10px";
    container.appendChild(monthTitle);
    const grid = document.createElement("div");
    grid.className = "tf-month-grid";
    const dayNames = ["Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r", "S\xF8n"];
    dayNames.forEach((name) => {
      const header = document.createElement("div");
      header.textContent = name;
      header.style.textAlign = "center";
      header.style.fontWeight = "bold";
      header.style.fontSize = "12px";
      header.style.color = "var(--text-muted)";
      grid.appendChild(header);
    });
    const firstDay = new Date(year, month, 1);
    let firstDayOfWeek = firstDay.getDay() - 1;
    if (firstDayOfWeek === -1)
      firstDayOfWeek = 6;
    for (let i = 0; i < firstDayOfWeek; i++) {
      const emptyCell = document.createElement("div");
      grid.appendChild(emptyCell);
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const todayKey = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-day-cell";
      cell.textContent = day.toString();
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      if (holidayInfo) {
        cell.style.background = SPECIAL_DAY_COLORS[holidayInfo.type] || "#eee";
      } else if (this.data.daily[dateKey]) {
        const dayFlextime = this.data.daily[dateKey].reduce((sum, e) => sum + (e.flextime || 0), 0);
        cell.style.background = this.flextimeColor(dayFlextime);
      } else if (Utils.isWeekend(date)) {
        cell.style.background = "#f5f5f5";
      } else {
        cell.style.background = "#fff";
      }
      if (dateKey === todayKey) {
        cell.classList.add("today");
      }
      cell.onclick = (e) => {
        this.showNoteTypeMenu(e, date);
      };
      grid.appendChild(cell);
    }
    container.appendChild(grid);
    return container;
  }
  flextimeColor(val) {
    if (val === 0)
      return "#fff";
    if (val > 0) {
      const intensity = Math.min(val / 6, 1);
      const green = Math.floor(200 + intensity * 55);
      const other = Math.floor(240 - intensity * 90);
      return `rgb(${other}, ${green}, ${other})`;
    } else {
      const intensity = Math.min(Math.abs(val) / 6, 1);
      const red = Math.floor(200 + intensity * 55);
      const other = Math.floor(240 - intensity * 90);
      return `rgb(${red}, ${other}, ${other})`;
    }
  }
  showNoteTypeMenu(event, dateObj) {
    const existingMenu = document.querySelector(".tf-context-menu");
    if (existingMenu)
      existingMenu.remove();
    const menu = document.createElement("div");
    menu.className = "tf-context-menu";
    menu.style.left = `${event.clientX}px`;
    menu.style.top = `${event.clientY}px`;
    this.settings.noteTypes.forEach((noteType) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.innerHTML = `<span>${noteType.icon}</span><span>${noteType.label}</span>`;
      item.onclick = async () => {
        await this.createNoteFromType(dateObj, noteType);
        menu.remove();
      };
      menu.appendChild(item);
    });
    const separator = document.createElement("div");
    separator.className = "tf-menu-separator";
    menu.appendChild(separator);
    const specialDayItem = document.createElement("div");
    specialDayItem.className = "tf-menu-item";
    specialDayItem.textContent = "\u{1F4C5} Registrer spesialdag";
    specialDayItem.onclick = () => {
      new import_obsidian4.Notice("Special day registration not yet implemented");
      menu.remove();
    };
    menu.appendChild(specialDayItem);
    document.body.appendChild(menu);
    setTimeout(() => {
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  async createNoteFromType(dateObj, noteType) {
    try {
      const dateStr = Utils.toLocalDateStr(dateObj);
      const weekNum = Utils.getWeekNumber(dateObj);
      let filename = noteType.filenamePattern.replace("{YYYY}", dateObj.getFullYear().toString()).replace("{MM}", (dateObj.getMonth() + 1).toString().padStart(2, "0")).replace("{DD}", dateObj.getDate().toString().padStart(2, "0")).replace("{WEEK}", weekNum.toString());
      const filePath = `${noteType.folder}/${filename}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        await this.app.workspace.getLeaf(false).openFile(existingFile);
        new import_obsidian4.Notice(`Opened existing note: ${filename}`);
        return;
      }
      const folderPath = noteType.folder;
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      let content = "";
      const templateFile = this.app.vault.getAbstractFileByPath(noteType.template);
      if (templateFile && templateFile instanceof import_obsidian4.TFile) {
        content = await this.app.vault.read(templateFile);
      }
      content = content.replace(/{date}/g, dateStr).replace(/{time}/g, (/* @__PURE__ */ new Date()).toLocaleTimeString("nb-NO")).replace(/{week}/g, weekNum.toString());
      if (noteType.tags && noteType.tags.length > 0) {
        content += `

${noteType.tags.join(" ")}`;
      }
      const file = await this.app.vault.create(filePath, content);
      await this.app.workspace.getLeaf(false).openFile(file);
      new import_obsidian4.Notice(`Created note: ${filename}`);
    } catch (error) {
      new import_obsidian4.Notice(`Error creating note: ${error.message}`);
      console.error("Error creating note:", error);
    }
  }
  refreshHistoryView(container) {
    container.innerHTML = "";
    const years = {};
    Object.keys(this.data.daily).sort().reverse().forEach((dateKey) => {
      const year = dateKey.split("-")[0];
      if (!years[year])
        years[year] = {};
      const month = dateKey.split("-")[1];
      if (!years[year][month])
        years[year][month] = [];
      years[year][month].push(...this.data.daily[dateKey]);
    });
    if (this.historyView === "list") {
      this.renderListView(container, years);
    } else if (this.historyView === "weekly") {
      this.renderWeeklyView(container, years);
    } else if (this.historyView === "heatmap") {
      this.renderHeatmapView(container, years);
    }
  }
  renderListView(container, years) {
    Object.keys(years).forEach((year) => {
      const yearDiv = document.createElement("div");
      yearDiv.innerHTML = `<h4>${year}</h4>`;
      Object.keys(years[year]).forEach((month) => {
        const monthEntries = years[year][month];
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginBottom = "15px";
        table.innerHTML = `
					<thead>
						<tr style="background: var(--background-secondary);">
							<th style="padding: 8px;">Dato</th>
							<th style="padding: 8px;">Type</th>
							<th style="padding: 8px;">Timer</th>
							<th style="padding: 8px;">Fleksitid</th>
						</tr>
					</thead>
					<tbody>
						${monthEntries.map((e) => `
							<tr style="border-bottom: 1px solid var(--background-modifier-border);">
								<td style="padding: 8px;">${Utils.toLocalDateStr(e.date)}</td>
								<td style="padding: 8px;">${e.name}</td>
								<td style="padding: 8px;">${Utils.formatHoursToHM(e.duration || 0)}</td>
								<td style="padding: 8px;">${Utils.formatHoursToHM(e.flextime || 0)}</td>
							</tr>
						`).join("")}
					</tbody>
				`;
        yearDiv.appendChild(table);
      });
      container.appendChild(yearDiv);
    });
  }
  renderWeeklyView(container, years) {
    container.innerHTML = '<div style="padding: 20px; text-align: center;">Weekly view - Coming soon</div>';
  }
  renderHeatmapView(container, years) {
    const heatmap = document.createElement("div");
    heatmap.className = "tf-heatmap";
    heatmap.style.gridTemplateColumns = `repeat(${this.settings.heatmapColumns}, 1fr)`;
    const today = /* @__PURE__ */ new Date();
    const daysToShow = this.settings.heatmapColumns * 8;
    for (let i = daysToShow; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-heatmap-cell";
      cell.title = dateKey;
      const dayEntries = this.data.daily[dateKey];
      if (dayEntries) {
        const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
        cell.style.background = this.flextimeColor(dayFlextime);
      } else {
        cell.style.background = "#eee";
      }
      heatmap.appendChild(cell);
    }
    container.appendChild(heatmap);
  }
  exportCurrentView() {
    const rows = [["Date", "Type", "Hours", "Flextime"]];
    Object.keys(this.data.daily).sort().forEach((dateKey) => {
      this.data.daily[dateKey].forEach((entry) => {
        rows.push([
          dateKey,
          entry.name,
          (entry.duration || 0).toFixed(2),
          (entry.flextime || 0).toFixed(2)
        ]);
      });
    });
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian4.Notice("Exported to CSV");
  }
  startUpdates() {
    const clockInterval = window.setInterval(() => {
      this.updateClock();
    }, this.settings.clockInterval);
    this.intervals.push(clockInterval);
    const dataInterval = window.setInterval(() => {
      this.updateAll();
    }, this.settings.updateInterval);
    this.intervals.push(dataInterval);
  }
  updateAll() {
    this.updateBadge();
    this.updateTimerControls();
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  cleanup() {
    this.intervals.forEach((interval) => clearInterval(interval));
    this.intervals = [];
  }
  build() {
    this.injectStyles();
    this.container.appendChild(this.buildBadgeSection());
    this.container.appendChild(this.buildSummaryCards());
    this.container.appendChild(this.createStatsCard());
    this.container.appendChild(this.buildInfoCard());
    this.container.appendChild(this.buildHistoryCard());
    this.container.appendChild(this.buildStatusBar());
    return this.container;
  }
};

// src/view.ts
var VIEW_TYPE_TIMEFLOW = "timeflow-view";
var TimeFlowView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dataManager = null;
    this.uiBuilder = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TIMEFLOW;
  }
  getDisplayText() {
    return "TimeFlow Dashboard";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeflow-dashboard");
    await this.loadDashboard(container);
  }
  async onClose() {
    if (this.uiBuilder) {
      this.uiBuilder.cleanup();
    }
  }
  async loadDashboard(container) {
    try {
      const allEntries = this.plugin.timerManager.convertToTimeEntries();
      if (allEntries.length === 0) {
        container.createDiv({
          text: "No timer data yet. Start a timer to begin tracking!",
          cls: "timeflow-warning"
        });
      }
      this.dataManager = new DataManager(allEntries, this.plugin.settings, this.app);
      const holidayStatus = await this.dataManager.loadHolidays();
      this.dataManager.processEntries();
      const validationResults = this.dataManager.validateData();
      const systemStatus = {
        holiday: holidayStatus,
        validation: validationResults,
        activeTimers: this.dataManager.activeEntries.length
      };
      this.uiBuilder = new UIBuilder(
        this.dataManager,
        systemStatus,
        this.plugin.settings,
        this.app,
        this.plugin.timerManager
      );
      this.plugin.timerManager.onTimerChange = () => {
        this.refresh();
      };
      const dashboardEl = this.uiBuilder.build();
      container.empty();
      container.appendChild(dashboardEl);
      this.uiBuilder.startUpdates();
    } catch (error) {
      console.error("Error loading TimeFlow dashboard:", error);
      container.createDiv({
        text: `Error loading dashboard: ${error.message}`,
        cls: "timeflow-error"
      });
    }
  }
  // Method to refresh the dashboard
  async refresh() {
    const container = this.containerEl.children[1];
    await this.loadDashboard(container);
  }
};

// src/timerManager.ts
var import_obsidian6 = require("obsidian");
var TimerManager = class {
  constructor(app, settings) {
    this.dataFile = "TimeFlow Data.md";
    this.app = app;
    this.settings = settings;
    this.data = { entries: [] };
  }
  async load() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.dataFile);
      if (file && file instanceof import_obsidian6.TFile) {
        const content = await this.app.vault.read(file);
        const parsed = this.parseTimekeepData(content);
        if (parsed) {
          this.data = parsed;
        }
      } else {
        await this.createDataFile();
      }
    } catch (error) {
      console.error("Error loading timer data:", error);
      this.data = { entries: [] };
    }
  }
  async createDataFile() {
    const content = `# TimeFlow Data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data)}
\`\`\`
`;
    await this.app.vault.create(this.dataFile, content);
  }
  parseTimekeepData(content) {
    try {
      const match = content.match(/```timekeep\s*\n([\s\S]*?)\n```/);
      if (match && match[1]) {
        return JSON.parse(match[1]);
      }
    } catch (error) {
      console.error("Error parsing timekeep data:", error);
    }
    return null;
  }
  async save() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.dataFile);
      const content = `# TimeFlow Data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data, null, 2)}
\`\`\`
`;
      if (file && file instanceof import_obsidian6.TFile) {
        await this.app.vault.modify(file, content);
      } else {
        await this.app.vault.create(this.dataFile, content);
      }
    } catch (error) {
      console.error("Error saving timer data:", error);
    }
  }
  async startTimer(name = "Jobb") {
    const timer = {
      name,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      endTime: null,
      subEntries: null
    };
    this.data.entries.push(timer);
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    new import_obsidian6.Notice(`\u23F1\uFE0F Timer started: ${name}`);
    return timer;
  }
  async stopTimer(timer) {
    if (!timer.startTime || timer.endTime) {
      return null;
    }
    timer.endTime = (/* @__PURE__ */ new Date()).toISOString();
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    const duration = Utils.hoursDiff(
      new Date(timer.startTime),
      new Date(timer.endTime)
    );
    new import_obsidian6.Notice(`\u2705 Timer stopped: ${timer.name} (${Utils.formatHoursToHM(duration)})`);
    return timer;
  }
  async stopAllTimers() {
    const activeTimers = this.getActiveTimers();
    for (const timer of activeTimers) {
      await this.stopTimer(timer);
    }
  }
  async deleteTimer(timer) {
    const index = this.data.entries.indexOf(timer);
    if (index !== -1) {
      this.data.entries.splice(index, 1);
      await this.save();
      if (this.onTimerChange) {
        this.onTimerChange();
      }
      new import_obsidian6.Notice("Timer deleted");
      return true;
    }
    return false;
  }
  getActiveTimers() {
    return this.data.entries.filter((e) => e.startTime && !e.endTime && !e.collapsed);
  }
  getCompletedTimers() {
    return this.data.entries.filter((e) => e.startTime && e.endTime);
  }
  getAllTimers() {
    return this.data.entries;
  }
  // Flatten all entries including subEntries for DataManager
  convertToTimeEntries() {
    const flatEntries = [];
    const flattenEntry = (entry) => {
      if (entry.collapsed && entry.subEntries) {
        entry.subEntries.forEach((sub) => flattenEntry(sub));
      } else if (entry.startTime) {
        flatEntries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          subEntries: null
        });
      }
    };
    this.data.entries.forEach((entry) => flattenEntry(entry));
    return flatEntries;
  }
  // Get running time for active timer
  getRunningTime(timer) {
    if (!timer.startTime || timer.endTime)
      return 0;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(timer.startTime);
    return Utils.hoursDiff(start, now);
  }
  // Get total running time for all active timers
  getTotalRunningTime() {
    return this.getActiveTimers().reduce((total, timer) => {
      return total + this.getRunningTime(timer);
    }, 0);
  }
  // Load data from multiple sources (daily notes with timekeep codeblocks)
  async loadFromDailyNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const dailyNotesFolder = this.settings.dailyNotesFolder;
      let allEntries = [];
      for (const file of files) {
        if (file.path.startsWith(dailyNotesFolder)) {
          const content = await this.app.vault.read(file);
          const parsed = this.parseTimekeepData(content);
          if (parsed && parsed.entries) {
            allEntries = allEntries.concat(parsed.entries);
          }
        }
      }
      const currentEntries = this.data.entries;
      allEntries.forEach((entry) => {
        const isDuplicate = currentEntries.some(
          (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
        );
        if (!isDuplicate) {
          currentEntries.push(entry);
        }
      });
      this.data.entries = currentEntries;
      await this.save();
    } catch (error) {
      console.error("Error loading from daily notes:", error);
    }
  }
  // Export to Timekeep format for other tools
  exportTimekeepFormat() {
    return JSON.stringify(this.data, null, 2);
  }
  // Import from Timekeep JSON
  async importTimekeepData(jsonData) {
    try {
      const parsed = JSON.parse(jsonData);
      if (parsed && parsed.entries) {
        this.data = parsed;
        await this.save();
        if (this.onTimerChange) {
          this.onTimerChange();
        }
        new import_obsidian6.Notice(`Imported ${parsed.entries.length} entries`);
        return true;
      }
    } catch (error) {
      console.error("Error importing timekeep data:", error);
      new import_obsidian6.Notice("Error importing data");
    }
    return false;
  }
};

// src/main.ts
var TimeFlowPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    console.log("Loading TimeFlow plugin");
    await this.loadSettings();
    this.timerManager = new TimerManager(this.app, this.settings);
    await this.timerManager.load();
    this.registerView(
      VIEW_TYPE_TIMEFLOW,
      (leaf) => new TimeFlowView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open TimeFlow", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-timeflow",
      name: "Open TimeFlow Dashboard",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "start-timer",
      name: "Start Timer",
      callback: async () => {
        await this.timerManager.startTimer("jobb");
      }
    });
    this.addCommand({
      id: "stop-all-timers",
      name: "Stop All Timers",
      callback: async () => {
        await this.timerManager.stopAllTimers();
      }
    });
    this.addCommand({
      id: "import-timekeep-data",
      name: "Import Timekeep Data",
      callback: () => {
        new ImportModal(this.app, this.timerManager, () => {
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
          leaves.forEach((leaf) => {
            const view = leaf.view;
            if (view && view.refresh) {
              view.refresh();
            }
          });
        }).open();
      }
    });
    this.addSettingTab(new TimeFlowSettingTab(this.app, this));
  }
  onunload() {
    console.log("Unloading TimeFlow plugin");
    this.timerManager.stopAllTimers();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TIMEFLOW, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
