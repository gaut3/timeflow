/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeFlowPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var FIXED_DAY_COLORS = {
  helligdag: "#ef5350",
  halfday: "#ffd54f",
  "Ingen registrering": "#cccccc"
};
var FIXED_DAY_TEXT_COLORS = {
  helligdag: "#ffffff",
  halfday: "#000000",
  "Ingen registrering": "#000000"
};
function getSpecialDayColors(settings) {
  const colors = { ...FIXED_DAY_COLORS };
  settings.specialDayBehaviors.forEach((behavior) => {
    colors[behavior.id] = behavior.color;
  });
  if (settings.specialDayColors) {
    Object.assign(colors, settings.specialDayColors);
  }
  return colors;
}
function getSpecialDayTextColors(settings) {
  const colors = { ...FIXED_DAY_TEXT_COLORS };
  settings.specialDayBehaviors.forEach((behavior) => {
    colors[behavior.id] = behavior.textColor || "#000000";
  });
  return colors;
}
var EMOJI_MAP = {
  avspasering: "\u{1F6CC}",
  kurs: "\u{1F4DA}",
  studie: "\u{1F4DA}",
  ferie: "\u{1F3D6}\uFE0F",
  velferdspermisjon: "\u{1F3E5}",
  egenmelding: "\u{1F912}",
  sykemelding: "\u{1F3E5}",
  helligdag: "\u{1F389}",
  jobb: "\u{1F4BC}"
};
var Utils = {
  parseDate: (str) => str ? new Date(str) : null,
  hoursDiff: (start, end) => (end.getTime() - start.getTime()) / 36e5,
  isWeekend: (date, settings) => {
    if (!date)
      return false;
    const day = date.getDay();
    if (!settings)
      return day === 0 || day === 6;
    if (settings.enableAlternatingWeeks) {
      const weekNum = Utils.getWeekNumber(date);
      const isAlternatingWeek = weekNum % 2 === 0;
      const workDays = isAlternatingWeek ? settings.alternatingWeekWorkDays : settings.workDays;
      return !workDays.includes(day);
    }
    return !settings.workDays.includes(day);
  },
  formatHoursToHM: (hours, unit = "h") => {
    const isNegative = hours < 0;
    const absHours = Math.abs(hours);
    let h = Math.floor(absHours);
    let m = Math.round((absHours - h) * 60);
    if (m === 60) {
      h++;
      m = 0;
    }
    return `${isNegative ? "-" : ""}${h}${unit} ${m.toString().padStart(2, "0")}m`;
  },
  toLocalDateStr: (date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  },
  // Create ISO string without Z suffix (interpreted as local time)
  toLocalISOString: (date) => {
    const pad = (n) => n.toString().padStart(2, "0");
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  },
  getWeekNumber: (d) => {
    const date = new Date(d.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    const week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(
      ((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7
    );
  },
  getEmoji: (entry) => {
    const name = entry.name.toLowerCase();
    if (EMOJI_MAP[name])
      return EMOJI_MAP[name];
    if (!entry.endTime)
      return "\u23F3";
    if (Utils.isWeekend(entry.date))
      return "\u{1F319}";
    return "";
  },
  randMsg: (arr) => arr[Math.floor(Math.random() * arr.length)],
  getDayOfYear: (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    return Math.floor(diff / 864e5);
  }
};

// src/importModal.ts
var import_obsidian = require("obsidian");

// src/i18n/index.ts
var currentLanguage = "nb";
function setLanguage(lang) {
  currentLanguage = lang;
}
function getLocale() {
  return currentLanguage === "nb" ? "nb-NO" : "en-GB";
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    value = value == null ? void 0 : value[k];
  }
  return value != null ? value : key;
}
function formatDate(date, format = "short") {
  if (currentLanguage === "en") {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    if (format === "long") {
      return date.toLocaleDateString("en-GB", { day: "numeric", month: "short", year: "numeric" });
    }
    return `${year}-${month}-${day}`;
  }
  if (format === "long") {
    return date.toLocaleDateString("nb-NO", { day: "numeric", month: "short", year: "numeric" });
  }
  return date.toLocaleDateString("nb-NO");
}
function formatTime(date, includeSeconds = false) {
  const options = {
    hour: "2-digit",
    minute: "2-digit"
  };
  if (includeSeconds)
    options.second = "2-digit";
  return date.toLocaleTimeString(getLocale(), options);
}
function getDayNamesShort() {
  return t("dates.dayNamesShort");
}
function getMonthName(date) {
  return date.toLocaleDateString(getLocale(), { month: "long", year: "numeric" });
}
var specialDayTranslationMap = {
  "jobb": "specialDays.work",
  "ferie": "specialDays.vacation",
  "avspasering": "specialDays.flexTimeOff",
  "egenmelding": "specialDays.selfReportedSick",
  "sykemelding": "specialDays.doctorSick",
  "velferdspermisjon": "specialDays.welfareLeave",
  "kurs": "specialDays.course",
  "studie": "specialDays.study",
  "helligdag": "specialDays.publicHoliday"
};
function translateSpecialDayName(id, fallbackLabel) {
  const translationKey = specialDayTranslationMap[id.toLowerCase()];
  if (translationKey) {
    return t(translationKey);
  }
  return fallbackLabel || id;
}
var noteTypeTranslationMap = {
  "daily": "noteTypes.daily",
  "meeting": "noteTypes.meeting",
  "project": "noteTypes.project",
  "review": "noteTypes.review",
  "reflection": "noteTypes.reflection"
};
function translateNoteTypeName(id, fallbackLabel) {
  const translationKey = noteTypeTranslationMap[id.toLowerCase()];
  if (translationKey) {
    return t(translationKey);
  }
  return fallbackLabel || id;
}
var translations = {
  nb: {
    dates: {
      dayNamesShort: ["Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r", "S\xF8n"],
      dayNamesFull: ["S\xF8ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "L\xF8rdag"]
    },
    ui: {
      today: "I dag",
      thisWeek: "Denne uken",
      week: "Uke",
      calendar: "Kalender",
      statistics: "Statistikk",
      history: "Historikk",
      information: "Informasjon",
      flextimeBalance: "Fleksitidsaldo",
      hoursWorked: "Timer arbeidet",
      hoursLogged: "Timer logget",
      hours: "Timer",
      dayGoal: "Dagsm\xE5l",
      weekGoal: "Ukem\xE5l",
      flextime: "Fleksitid",
      activeTimers: "Aktive timer",
      activeTimer: "Aktiv timer (p\xE5g\xE5r)",
      ongoing: "P\xE5g\xE5ende",
      total: "Totalt",
      year: "\xC5r",
      month: "M\xE5ned",
      all: "Alle",
      date: "Dato",
      type: "Type",
      start: "Start",
      end: "Slutt",
      duration: "Varighet",
      comment: "Kommentar",
      optional: "valgfritt",
      days: "dager",
      goal: "M\xE5l",
      expected: "Forventet",
      difference: "Differanse",
      overWeekLimit: "Over ukegrense",
      vsLastWeek: "vs forrige uke",
      upcomingPlannedDays: "Kommende planlagte dager",
      dailyBalance: "Dagssaldo",
      runningBalance: "L\xF8pende saldo",
      noRegistration: "Ingen registrering",
      noDataForDay: "Ingen data for den dagen",
      addNewEntry: "+ Legg til ny oppf\xF8ring",
      restPeriodWarning: "Hviletid: Kun {hours} timer mellom arbeids\xF8kter (minimum {min} timer)",
      restPeriod: "Hviletid",
      minimum: "minimum"
    },
    status: {
      ok: "OK",
      near: "N\xE6r",
      over: "Over",
      onTarget: "P\xE5 m\xE5l",
      overTarget: "Over m\xE5l",
      underTarget: "Under m\xE5l",
      inProgress: "P\xE5g\xE5r",
      allLimitsOk: "Alle grenser er OK.",
      withinLimits: "Innenfor grensene",
      approachingLimits: "N\xE6rmer seg",
      systemStatus: "Systemstatus",
      clickForDetails: "klikk for detaljer",
      holidayNotLoaded: "Helligdagsdata ikke lastet",
      activeTimers: "aktive timer",
      entriesChecked: "oppf\xF8ringer sjekket"
    },
    buttons: {
      cancel: "Avbryt",
      save: "Lagre",
      delete: "Slett",
      edit: "Rediger",
      close: "Lukk",
      add: "Legg til",
      done: "Ferdig",
      start: "Start",
      stop: "Stopp",
      export: "Eksporter",
      import: "Importer",
      preview: "Forh\xE5ndsvis",
      list: "Liste",
      heatmap: "Heatmap",
      moveToMain: "Flytt til hovedomr\xE5de",
      moveToSidebar: "Flytt til sidepanel"
    },
    menu: {
      logWork: "Logg arbeidstimer",
      editWork: "Rediger arbeidstid",
      registerSpecialDay: "Registrer spesialdag",
      addEntry: "Legg til oppf\xF8ring",
      deleteEntry: "Slett oppf\xF8ring",
      selectOption: "Velg et alternativ fra menyen"
    },
    timeframes: {
      total: "Totalt",
      year: "\xC5r",
      month: "M\xE5ned"
    },
    modals: {
      logWorkTitle: "Logg arbeidstimer for",
      editWorkTitle: "Rediger arbeidstid for",
      registerSpecialDayTitle: "Registrer spesialdag",
      addEntryTitle: "Legg til oppf\xF8ring for",
      deleteEntryTitle: "Slett oppf\xF8ring",
      startTime: "Starttid",
      endTime: "Sluttid",
      startTimeFormat: "Starttid (HH:MM):",
      endTimeFormat: "Sluttid (HH:MM):",
      dayType: "Type dag:",
      timePeriod: "Tidsperiode:",
      from: "Fra:",
      to: "Til:",
      commentOptional: "Kommentar (valgfritt):",
      commentPlaceholder: 'F.eks. "Ferie i Spania"'
    },
    validation: {
      endAfterStart: "Sluttid m\xE5 v\xE6re etter starttid",
      invalidTime: "Ugyldig tid (bruk format HH:MM, 00-23:00-59)",
      invalidTimePeriod: "Ugyldig tidsperiode",
      overlappingEntry: "Denne oppf\xF8ringen overlapper med en eksisterende oppf\xF8ring",
      endTimeNextDay: "Sluttid satt til neste dag (f\xF8r starttid)"
    },
    notifications: {
      added: "Lagt til",
      updated: "Oppdatert",
      deleted: "Slettet",
      exported: "Eksportert til CSV",
      saveError: "Feil ved lagring av data"
    },
    confirm: {
      deleteEntry: "Er du sikker p\xE5 at du vil slette denne oppf\xF8ringen?",
      deleteEntryFor: "Slette oppf\xF8ring for",
      overnightShiftTitle: "Nattskift?",
      overnightShift: "Sluttid er f\xF8r starttid. Er dette et nattskift som g\xE5r over midnatt?"
    },
    stats: {
      flextimeBalance: "Fleksitidsaldo",
      hours: "Timer",
      avgPerDay: "Snitt/dag",
      avgPerWeek: "Snitt/uke",
      workIntensity: "Intensitet",
      ofNormalWeek: "av normaluke",
      work: "Jobb",
      weekendDaysWorked: "Helgedager jobbet",
      flexTimeOff: "Avspasering",
      vacation: "Ferie",
      welfareLeave: "Velferdspermisjon",
      selfReportedSick: "Egenmelding",
      doctorSick: "Sykemelding",
      study: "Studiedag",
      course: "Kursdag",
      totalBalance: "Total saldo"
    },
    specialDays: {
      work: "Jobb",
      vacation: "Ferie",
      flexTimeOff: "Avspasering",
      selfReportedSick: "Egenmelding",
      doctorSick: "Sykemelding",
      welfareLeave: "Velferdspermisjon",
      course: "Kursdag",
      study: "Studiedag",
      publicHoliday: "Helligdag"
    },
    import: {
      title: "Importer data",
      description: "Importer tidsdata fra ulike formater. St\xF8tter Timekeep JSON, CSV og JSON-arrays.",
      selectFile: "Velg fil...",
      noFile: "Ingen fil valgt",
      orPasteData: "Eller lim inn data:",
      placeholder: "Lim inn Timekeep JSON, CSV eller JSON-array her...\n\nEksempel CSV (norsk format):\nDato;Start;Slutt;Aktivitet\n25.11.2024;08:00;16:00;jobb\n26.11.2024;09:00;17:00;jobb",
      format: "Format:",
      autoDetect: "Auto-detekter",
      supportedFormats: "St\xF8ttede formater:",
      noEntries: "Ingen oppf\xF8ringer \xE5 importere",
      entriesFound: "oppf\xF8ringer funnet",
      imported: "Importerte",
      entries: "oppf\xF8ringer",
      skippedDuplicates: "hoppet over",
      duplicates: "duplikater",
      andMore: "og",
      more: "flere",
      errors: {
        invalidFormat: "Ugyldig format",
        missingEntries: 'mangler "entries" array',
        missingFields: "Mangler p\xE5krevde felt",
        invalidStartTime: "Ugyldig starttid",
        invalidEndTime: "Ugyldig sluttid",
        csvNeedsHeader: "CSV m\xE5 ha minst en overskriftsrad og en datarad",
        jsonError: "JSON-feil",
        unknownFormat: "Kunne ikke gjenkjenne formatet. St\xF8ttede formater: Timekeep JSON, CSV, JSON Array",
        couldNotFindDateColumn: "Kunne ikke finne dato-kolonne. Forventet: Dato, Date, Dag",
        couldNotFindStartColumn: "Kunne ikke finne starttid-kolonne. Forventet: Start, Starttid, Fra",
        tooFewColumns: "For f\xE5 kolonner",
        missingDateOrTime: "Mangler dato eller starttid",
        invalidDateFormat: "Ugyldig datoformat. Bruk DD.MM.YYYY eller YYYY-MM-DD",
        invalidTimeFormat: "Ugyldig tid. Bruk HH:MM",
        expectedJsonArray: "Forventet en JSON-array",
        couldNotParseDateTime: "Kunne ikke tolke dato/tid",
        entry: "Oppf\xF8ring",
        row: "Rad"
      },
      warnings: "Advarsler",
      errors_label: "Feil",
      tableHeaders: {
        date: "Dato",
        start: "Start",
        end: "Slutt",
        type: "Type"
      }
    },
    settings: {
      language: "Spr\xE5k",
      languageDesc: "Velg spr\xE5k for grensesnittet",
      showWeekNumbers: "Vis ukenummer",
      showWeekNumbersDesc: "Vis ukenummer i kalender og uke-kortet (ISO 8601 ukenummer)",
      importData: "Importer data",
      importDataDesc: "Importer tidsdata fra ulike formater: Timekeep JSON, CSV (norsk/ISO datoformat), eller JSON-arrays"
    },
    compliance: {
      title: "Arbeidstidsgrenser",
      today: "I dag",
      thisWeek: "Denne uken",
      restPeriod: "Hviletid",
      limit: "grense",
      approaching: "n\xE6rmer seg",
      exceeds: "Overstiger",
      ok: "OK",
      near: "N\xE6r",
      over: "Over"
    },
    timer: {
      runningTimers: "P\xE5g\xE5ende timer",
      noActiveTimers: "Ingen aktive timer"
    },
    noteTypes: {
      daily: "Daglig Notat",
      meeting: "M\xF8tenotat",
      project: "Prosjektnotat",
      review: "Ukesoppsummering",
      reflection: "Refleksjonsnotat"
    },
    info: {
      specialDayTypes: "Spesielle dagtyper",
      workDaysGradient: "Arbeidsdager - fargegradient",
      colorShowsFlextime: "Fargen viser fleksitid i forhold til dagens m\xE5l",
      calendarContextMenu: "Kalenderkontekstmeny",
      clickDayFor: "Trykk p\xE5 en dag i kalenderen for:",
      createDailyNote: "Opprett daglig notat",
      editFlextimeManually: "Rediger arbeidstid manuelt",
      registerSpecialDays: "Registrer spesielle dagtyper",
      flextimeBalanceZones: "Fleksitidsaldo - soner",
      green: "Gr\xF8nn",
      yellow: "Gul",
      orange: "Oransje",
      red: "R\xF8d",
      gray: "Gr\xE5",
      to: "til",
      weekNumberCompliance: "Ukenummer - statusfarger",
      reachedGoal: "N\xE5dd m\xE5l",
      overGoal: "Over m\xE5l",
      underGoal: "Under m\xE5l",
      weekInProgress: "Uke p\xE5g\xE5r",
      clickWeekForDetails: "Trykk p\xE5 ukenummer for detaljer.",
      publicHolidayDesc: "Offentlig fridag - p\xE5virker ikke fleksitid",
      halfDayDesc: "Halv arbeidsdag ({hours}t) - reduserer ukem\xE5let med {reduction}t",
      withdrawFromFlextime: "Trekkes fra fleksitid",
      countsAsFlextime: "Teller som fleksitid ved mer enn {hours}t",
      noFlextimeEffect: "P\xE5virker ikke fleksitid",
      workRegisteredOnSpecialDay: "Arbeid registrert p\xE5 {dayType}"
    }
  },
  en: {
    dates: {
      dayNamesShort: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
      dayNamesFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    ui: {
      today: "Today",
      thisWeek: "This Week",
      week: "Week",
      calendar: "Calendar",
      statistics: "Statistics",
      history: "History",
      information: "Information",
      flextimeBalance: "Flextime Balance",
      hoursWorked: "Hours worked",
      hoursLogged: "Hours logged",
      hours: "Hours",
      dayGoal: "Daily Goal",
      weekGoal: "Weekly Goal",
      flextime: "Flextime",
      activeTimers: "Active timers",
      activeTimer: "Active timer (in progress)",
      ongoing: "Ongoing",
      total: "Total",
      year: "Year",
      month: "Month",
      all: "All",
      date: "Date",
      type: "Type",
      start: "Start",
      end: "End",
      duration: "Duration",
      comment: "Comment",
      optional: "optional",
      days: "days",
      goal: "Goal",
      expected: "Expected",
      difference: "Difference",
      overWeekLimit: "Over weekly limit",
      vsLastWeek: "vs last week",
      upcomingPlannedDays: "Upcoming planned days",
      dailyBalance: "Daily balance",
      runningBalance: "Running balance",
      noRegistration: "No registration",
      noDataForDay: "No data for this day",
      addNewEntry: "+ Add new entry",
      restPeriodWarning: "Rest period: Only {hours} hours between work sessions (minimum {min} hours)",
      restPeriod: "Rest period",
      minimum: "minimum"
    },
    status: {
      ok: "OK",
      near: "Near",
      over: "Over",
      onTarget: "On target",
      overTarget: "Over target",
      underTarget: "Under target",
      inProgress: "In progress",
      allLimitsOk: "All limits are OK.",
      withinLimits: "Within limits",
      approachingLimits: "Approaching",
      systemStatus: "System Status",
      clickForDetails: "click for details",
      holidayNotLoaded: "Holiday data not loaded",
      activeTimers: "active timers",
      entriesChecked: "entries checked"
    },
    buttons: {
      cancel: "Cancel",
      save: "Save",
      delete: "Delete",
      edit: "Edit",
      close: "Close",
      add: "Add",
      done: "Done",
      start: "Start",
      stop: "Stop",
      export: "Export",
      import: "Import",
      preview: "Preview",
      list: "List",
      heatmap: "Heatmap",
      moveToMain: "Move to main area",
      moveToSidebar: "Move to sidebar"
    },
    menu: {
      logWork: "Log work hours",
      editWork: "Edit work time",
      registerSpecialDay: "Register special day",
      addEntry: "Add entry",
      deleteEntry: "Delete entry",
      selectOption: "Select an option from the menu"
    },
    timeframes: {
      total: "Total",
      year: "Year",
      month: "Month"
    },
    modals: {
      logWorkTitle: "Log work hours for",
      editWorkTitle: "Edit work time for",
      registerSpecialDayTitle: "Register special day",
      addEntryTitle: "Add entry for",
      deleteEntryTitle: "Delete entry",
      startTime: "Start time",
      endTime: "End time",
      startTimeFormat: "Start time (HH:MM):",
      endTimeFormat: "End time (HH:MM):",
      dayType: "Day type:",
      timePeriod: "Time period:",
      from: "From:",
      to: "To:",
      commentOptional: "Comment (optional):",
      commentPlaceholder: 'E.g. "Vacation in Spain"'
    },
    validation: {
      endAfterStart: "End time must be after start time",
      invalidTime: "Invalid time (use format HH:MM, 00-23:00-59)",
      invalidTimePeriod: "Invalid time period",
      overlappingEntry: "This entry overlaps with an existing entry",
      endTimeNextDay: "End time set to next day (before start time)"
    },
    notifications: {
      added: "Added",
      updated: "Updated",
      deleted: "Deleted",
      exported: "Exported to CSV",
      saveError: "Error saving data"
    },
    confirm: {
      deleteEntry: "Are you sure you want to delete this entry?",
      deleteEntryFor: "Delete entry for",
      overnightShiftTitle: "Overnight shift?",
      overnightShift: "End time is before start time. Is this an overnight shift that crosses midnight?"
    },
    stats: {
      flextimeBalance: "Flextime Balance",
      hours: "Hours",
      avgPerDay: "Avg/day",
      avgPerWeek: "Avg/week",
      workIntensity: "Workload",
      ofNormalWeek: "of normal week",
      work: "Work",
      weekendDaysWorked: "Weekend days worked",
      flexTimeOff: "Comp time",
      vacation: "Vacation",
      welfareLeave: "Welfare leave",
      selfReportedSick: "Sick day (self-reported)",
      doctorSick: "Certified sick leave",
      study: "Study",
      course: "Course",
      totalBalance: "Total balance"
    },
    specialDays: {
      work: "Work",
      vacation: "Vacation",
      flexTimeOff: "Comp time",
      selfReportedSick: "Sick day (self-reported)",
      doctorSick: "Certified sick leave",
      welfareLeave: "Welfare leave",
      course: "Course",
      study: "Study",
      publicHoliday: "Public holiday"
    },
    import: {
      title: "Import data",
      description: "Import time data from various formats. Supports Timekeep JSON, CSV and JSON arrays.",
      selectFile: "Select file...",
      noFile: "No file selected",
      orPasteData: "Or paste data:",
      placeholder: "Paste Timekeep JSON, CSV or JSON array here...\n\nExample CSV:\nDate;Start;End;Activity\n2024-11-25;08:00;16:00;work\n2024-11-26;09:00;17:00;work",
      format: "Format:",
      autoDetect: "Auto-detect",
      supportedFormats: "Supported formats:",
      noEntries: "No entries to import",
      entriesFound: "entries found",
      imported: "Imported",
      entries: "entries",
      skippedDuplicates: "skipped",
      duplicates: "duplicates",
      andMore: "and",
      more: "more",
      errors: {
        invalidFormat: "Invalid format",
        missingEntries: 'missing "entries" array',
        missingFields: "Missing required fields",
        invalidStartTime: "Invalid start time",
        invalidEndTime: "Invalid end time",
        csvNeedsHeader: "CSV must have at least a header row and a data row",
        jsonError: "JSON error",
        unknownFormat: "Could not recognize format. Supported formats: Timekeep JSON, CSV, JSON Array",
        couldNotFindDateColumn: "Could not find date column. Expected: Date, Dato, Day",
        couldNotFindStartColumn: "Could not find start time column. Expected: Start, From",
        tooFewColumns: "Too few columns",
        missingDateOrTime: "Missing date or start time",
        invalidDateFormat: "Invalid date format. Use DD.MM.YYYY or YYYY-MM-DD",
        invalidTimeFormat: "Invalid time. Use HH:MM",
        expectedJsonArray: "Expected a JSON array",
        couldNotParseDateTime: "Could not parse date/time",
        entry: "Entry",
        row: "Row"
      },
      warnings: "Warnings",
      errors_label: "Errors",
      tableHeaders: {
        date: "Date",
        start: "Start",
        end: "End",
        type: "Type"
      }
    },
    settings: {
      language: "Language",
      languageDesc: "Choose interface language",
      showWeekNumbers: "Show week numbers",
      showWeekNumbersDesc: "Show week numbers in calendar and week card (ISO 8601 week numbers)",
      importData: "Import data",
      importDataDesc: "Import time data from various formats: Timekeep JSON, CSV (Norwegian/ISO date format), or JSON arrays"
    },
    compliance: {
      title: "Work time limits",
      today: "Today",
      thisWeek: "This week",
      restPeriod: "Rest period",
      limit: "limit",
      approaching: "approaching",
      exceeds: "Exceeds",
      ok: "OK",
      near: "Near",
      over: "Over"
    },
    timer: {
      runningTimers: "Running timers",
      noActiveTimers: "No active timers"
    },
    noteTypes: {
      daily: "Daily Note",
      meeting: "Meeting Note",
      project: "Project Note",
      review: "Weekly Review",
      reflection: "Reflection Note"
    },
    info: {
      specialDayTypes: "Special day types",
      workDaysGradient: "Work days - color gradient",
      colorShowsFlextime: "Color shows flextime relative to daily goal",
      calendarContextMenu: "Calendar context menu",
      clickDayFor: "Click on a day in the calendar for:",
      createDailyNote: "Create daily note",
      editFlextimeManually: "Edit flextime manually",
      registerSpecialDays: "Register special day types",
      flextimeBalanceZones: "Flextime balance - zones",
      green: "Green",
      yellow: "Yellow",
      orange: "Orange",
      red: "Red",
      gray: "Gray",
      to: "to",
      weekNumberCompliance: "Week number - status colors",
      reachedGoal: "Reached goal",
      overGoal: "Over goal",
      underGoal: "Under goal",
      weekInProgress: "Week in progress",
      clickWeekForDetails: "Click on a week number for details.",
      publicHolidayDesc: "Public holiday - does not affect flextime",
      halfDayDesc: "Half work day ({hours}h) - reduces weekly goal by {reduction}h",
      withdrawFromFlextime: "Deducted from flextime balance",
      countsAsFlextime: "Counts as flextime above {hours}h",
      noFlextimeEffect: "Does not affect flextime",
      workRegisteredOnSpecialDay: "Work registered on {dayType}"
    }
  }
};

// src/importParsers.ts
var TimekeepParser = class {
  constructor() {
    this.name = "Timekeep JSON";
  }
  canParse(content) {
    try {
      const trimmed = content.trim();
      if (!trimmed.startsWith("{"))
        return false;
      const data = JSON.parse(trimmed);
      return data.entries && Array.isArray(data.entries);
    } catch (e) {
      return false;
    }
  }
  parse(content) {
    var _a;
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const data = JSON.parse(content.trim());
      if (!data.entries || !Array.isArray(data.entries)) {
        result.errors.push(`${t("import.errors.invalidFormat")}: ${t("import.errors.missingEntries")}`);
        return result;
      }
      for (let i = 0; i < data.entries.length; i++) {
        const entry = data.entries[i];
        if (!entry.name || !entry.startTime) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.missingFields")} (name, startTime)`);
          continue;
        }
        const startDate = new Date(entry.startTime);
        if (isNaN(startDate.getTime())) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.invalidStartTime")}`);
          continue;
        }
        if (entry.endTime) {
          const endDate = new Date(entry.endTime);
          if (isNaN(endDate.getTime())) {
            result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.invalidEndTime")}`);
            continue;
          }
        }
        result.entries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime || null,
          collapsed: (_a = entry.collapsed) != null ? _a : false,
          subEntries: entry.subEntries || null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`${t("import.errors.jsonError")}: ${error.message}`);
    }
    return result;
  }
};
var CSVParser = class {
  constructor() {
    this.name = "CSV";
  }
  canParse(content) {
    const lines = content.trim().split("\n");
    if (lines.length < 2)
      return false;
    const firstLine = lines[0].toLowerCase();
    const hasDateColumn = firstLine.includes("dato") || firstLine.includes("date");
    const hasTimeColumn = firstLine.includes("start") || firstLine.includes("time") || firstLine.includes("tid");
    return hasDateColumn || hasTimeColumn;
  }
  parse(content) {
    var _a, _b, _c, _d;
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const lines = content.trim().split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
      if (lines.length < 2) {
        result.errors.push(t("import.errors.csvNeedsHeader"));
        return result;
      }
      const delimiter = this.detectDelimiter(lines[0]);
      const headers = this.parseCSVLine(lines[0], delimiter).map((h) => h.toLowerCase().trim());
      const dateCol = this.findColumn(headers, ["dato", "date", "dag", "day"]);
      const startCol = this.findColumn(headers, ["start", "starttid", "start time", "fra", "from"]);
      const endCol = this.findColumn(headers, ["slutt", "end", "sluttid", "end time", "til", "to"]);
      const activityCol = this.findColumn(headers, ["aktivitet", "activity", "type", "navn", "name", "beskrivelse", "description"]);
      if (dateCol === -1) {
        result.errors.push(t("import.errors.couldNotFindDateColumn"));
        return result;
      }
      if (startCol === -1) {
        result.errors.push(t("import.errors.couldNotFindStartColumn"));
        return result;
      }
      for (let i = 1; i < lines.length; i++) {
        const values = this.parseCSVLine(lines[i], delimiter);
        if (values.length <= Math.max(dateCol, startCol)) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.tooFewColumns")}`);
          continue;
        }
        const dateStr = (_a = values[dateCol]) == null ? void 0 : _a.trim();
        const startStr = (_b = values[startCol]) == null ? void 0 : _b.trim();
        const endStr = endCol !== -1 ? (_c = values[endCol]) == null ? void 0 : _c.trim() : "";
        const activity = activityCol !== -1 ? (_d = values[activityCol]) == null ? void 0 : _d.trim() : "jobb";
        if (!dateStr || !startStr) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.missingDateOrTime")}`);
          continue;
        }
        const parsedDate = this.parseDate(dateStr, result.warnings);
        if (!parsedDate) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidDateFormat")} "${dateStr}"`);
          continue;
        }
        const startTime = this.parseTime(startStr);
        if (!startTime) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidTimeFormat")} "${startStr}"`);
          continue;
        }
        const startDateTime = new Date(parsedDate);
        startDateTime.setHours(startTime.hours, startTime.minutes, 0, 0);
        let endDateTime = null;
        if (endStr) {
          const endTime = this.parseTime(endStr);
          if (endTime) {
            endDateTime = new Date(parsedDate);
            endDateTime.setHours(endTime.hours, endTime.minutes, 0, 0);
            if (endDateTime <= startDateTime) {
              endDateTime.setDate(endDateTime.getDate() + 1);
            }
          } else {
            result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidTimeFormat")} "${endStr}"`);
          }
        }
        result.entries.push({
          name: activity.toLowerCase() || "jobb",
          startTime: startDateTime.toISOString(),
          endTime: endDateTime ? endDateTime.toISOString() : null,
          collapsed: false,
          subEntries: null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`CSV ${t("import.errors_label")}: ${error.message}`);
    }
    return result;
  }
  detectDelimiter(line) {
    const semicolonCount = (line.match(/;/g) || []).length;
    const commaCount = (line.match(/,/g) || []).length;
    const tabCount = (line.match(/\t/g) || []).length;
    if (semicolonCount >= commaCount && semicolonCount >= tabCount)
      return ";";
    if (tabCount >= commaCount)
      return "	";
    return ",";
  }
  parseCSVLine(line, delimiter) {
    const result = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === delimiter && !inQuotes) {
        result.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  }
  findColumn(headers, possibleNames) {
    for (const name of possibleNames) {
      const index = headers.findIndex((h) => h.includes(name));
      if (index !== -1)
        return index;
    }
    return -1;
  }
  parseDate(dateStr, warnings) {
    let yearNum, monthNum, dayNum;
    const norwegianMatch = dateStr.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
    if (norwegianMatch) {
      const [, day, month, year] = norwegianMatch;
      dayNum = parseInt(day);
      monthNum = parseInt(month);
      yearNum = parseInt(year);
    } else {
      const isoMatch = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        dayNum = parseInt(day);
        monthNum = parseInt(month);
        yearNum = parseInt(year);
      } else {
        const slashMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (slashMatch) {
          const [, day, month, year] = slashMatch;
          dayNum = parseInt(day);
          monthNum = parseInt(month);
          yearNum = parseInt(year);
        } else {
          return null;
        }
      }
    }
    const date = new Date(yearNum, monthNum - 1, dayNum);
    if (isNaN(date.getTime()))
      return null;
    if (date.getFullYear() !== yearNum || date.getMonth() !== monthNum - 1 || date.getDate() !== dayNum) {
      const correctedStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
      if (warnings) {
        warnings.push(`Invalid date ${dateStr} was auto-corrected to ${correctedStr}`);
      }
    }
    return date;
  }
  parseTime(timeStr) {
    const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
    if (match) {
      const hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
        return { hours, minutes };
      }
    }
    const dotMatch = timeStr.match(/^(\d{1,2})\.(\d{2})$/);
    if (dotMatch) {
      const hours = parseInt(dotMatch[1]);
      const minutes = parseInt(dotMatch[2]);
      if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
        return { hours, minutes };
      }
    }
    return null;
  }
};
var GenericJSONParser = class {
  constructor() {
    this.name = "JSON Array";
  }
  canParse(content) {
    try {
      const trimmed = content.trim();
      if (!trimmed.startsWith("["))
        return false;
      const data = JSON.parse(trimmed);
      return Array.isArray(data) && data.length > 0;
    } catch (e) {
      return false;
    }
  }
  parse(content) {
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const data = JSON.parse(content.trim());
      if (!Array.isArray(data)) {
        result.errors.push(t("import.errors.expectedJsonArray"));
        return result;
      }
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const dateField = item.date || item.dato || item.day || item.dag;
        const startField = item.start || item.startTime || item.starttid || item.fra || item.from;
        const endField = item.end || item.endTime || item.slutt || item.sluttid || item.til || item.to;
        const nameField = item.name || item.navn || item.activity || item.aktivitet || item.type || "jobb";
        if (!dateField && !startField) {
          if (item.startTime && item.startTime.includes("T")) {
            const startDate = new Date(item.startTime);
            if (!isNaN(startDate.getTime())) {
              result.entries.push({
                name: (nameField || "jobb").toLowerCase(),
                startTime: item.startTime,
                endTime: item.endTime || null,
                collapsed: false,
                subEntries: null
              });
              continue;
            }
          }
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.missingDateOrTime")}`);
          continue;
        }
        let startDateTime = null;
        let endDateTime = null;
        if (dateField && startField) {
          startDateTime = this.combineDateAndTime(dateField, startField);
          if (endField) {
            endDateTime = this.combineDateAndTime(dateField, endField);
            if (endDateTime && startDateTime && endDateTime <= startDateTime) {
              endDateTime.setDate(endDateTime.getDate() + 1);
            }
          }
        }
        if (!startDateTime) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.couldNotParseDateTime")}`);
          continue;
        }
        result.entries.push({
          name: (nameField || "jobb").toLowerCase(),
          startTime: startDateTime.toISOString(),
          endTime: endDateTime ? endDateTime.toISOString() : null,
          collapsed: false,
          subEntries: null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`${t("import.errors.jsonError")}: ${error.message}`);
    }
    return result;
  }
  combineDateAndTime(dateStr, timeStr) {
    let date = null;
    if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
      date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
    } else if (dateStr.match(/^\d{1,2}\.\d{1,2}\.\d{4}$/)) {
      const [day, month, year] = dateStr.split(".").map(Number);
      date = new Date(year, month - 1, day);
    }
    if (!date || isNaN(date.getTime()))
      return null;
    const timeMatch = timeStr.match(/^(\d{1,2}):(\d{2})$/);
    if (timeMatch) {
      date.setHours(parseInt(timeMatch[1]), parseInt(timeMatch[2]), 0, 0);
      return date;
    }
    return null;
  }
};
function autoDetectAndParse(content) {
  const parsers = [
    new TimekeepParser(),
    new CSVParser(),
    new GenericJSONParser()
  ];
  for (const parser of parsers) {
    if (parser.canParse(content)) {
      const result = parser.parse(content);
      return { ...result, format: parser.name };
    }
  }
  return {
    success: false,
    entries: [],
    errors: [t("import.errors.unknownFormat")],
    warnings: [],
    format: "?"
  };
}

// src/importModal.ts
var ImportModal = class extends import_obsidian.Modal {
  constructor(app, timerManager, onSuccess) {
    super(app);
    this.selectedFormat = "auto";
    this.parsedEntries = [];
    this.parseWarnings = [];
    this.timerManager = timerManager;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("timeflow-import-modal");
    contentEl.createEl("h2", { text: t("import.title") });
    contentEl.createEl("p", {
      text: t("import.description"),
      cls: "setting-item-description"
    });
    const formatDiv = contentEl.createDiv();
    formatDiv.style.marginBottom = "15px";
    const formatLabel = formatDiv.createEl("label", { text: t("import.format") + " " });
    formatLabel.style.fontWeight = "bold";
    formatLabel.style.marginRight = "10px";
    const formatSelect = formatDiv.createEl("select");
    formatSelect.style.padding = "5px 10px";
    formatSelect.style.borderRadius = "4px";
    const formats = [
      { value: "auto", label: t("import.autoDetect") },
      { value: "timekeep", label: "Timekeep JSON" },
      { value: "csv", label: "CSV" },
      { value: "json", label: "JSON Array" }
    ];
    formats.forEach((f) => {
      const option = formatSelect.createEl("option", { text: f.label, value: f.value });
      if (f.value === this.selectedFormat)
        option.selected = true;
    });
    formatSelect.onchange = () => {
      this.selectedFormat = formatSelect.value;
    };
    const uploadDiv = contentEl.createDiv();
    uploadDiv.style.marginBottom = "15px";
    const fileInput = uploadDiv.createEl("input", {
      type: "file",
      attr: { accept: ".json,.csv,.txt" }
    });
    fileInput.style.display = "none";
    const uploadBtn = uploadDiv.createEl("button", { text: "\u{1F4C1} " + t("import.selectFile") });
    uploadBtn.style.marginRight = "10px";
    uploadBtn.onclick = () => fileInput.click();
    const fileNameSpan = uploadDiv.createEl("span", { text: t("import.noFile") });
    fileNameSpan.style.color = "var(--text-muted)";
    fileNameSpan.style.fontSize = "12px";
    const textAreaLabel = contentEl.createEl("div", { text: t("import.orPasteData") });
    textAreaLabel.style.fontWeight = "bold";
    textAreaLabel.style.marginBottom = "5px";
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "12",
        placeholder: t("import.placeholder")
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    textArea.style.resize = "vertical";
    fileInput.onchange = () => {
      var _a;
      const file = (_a = fileInput.files) == null ? void 0 : _a[0];
      if (file) {
        fileNameSpan.textContent = file.name;
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a2;
          textArea.value = ((_a2 = e.target) == null ? void 0 : _a2.result) || "";
          this.updatePreview(textArea.value, previewDiv, importBtn);
        };
        reader.readAsText(file);
      }
    };
    const previewDiv = contentEl.createDiv();
    previewDiv.style.marginBottom = "15px";
    previewDiv.style.padding = "10px";
    previewDiv.style.background = "var(--background-secondary)";
    previewDiv.style.borderRadius = "5px";
    previewDiv.style.display = "none";
    const parseBtn = contentEl.createEl("button", { text: "\u{1F50D} " + t("buttons.preview") });
    parseBtn.style.marginBottom = "15px";
    parseBtn.onclick = () => {
      this.updatePreview(textArea.value, previewDiv, importBtn);
    };
    let parseTimeout;
    textArea.oninput = () => {
      clearTimeout(parseTimeout);
      parseTimeout = window.setTimeout(() => {
        if (textArea.value.trim().length > 50) {
          this.updatePreview(textArea.value, previewDiv, importBtn);
        }
      }, 500);
    };
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} " + t("import.supportedFormats") });
    const list = infoDiv.createEl("ul");
    list.style.marginBottom = "0";
    list.createEl("li", { text: 'Timekeep JSON: {"entries": [...]}' });
    list.createEl("li", { text: `CSV: ${t("import.tableHeaders.date")};${t("import.tableHeaders.start")};${t("import.tableHeaders.end")};Type` });
    list.createEl("li", { text: 'JSON Array: [{"date": "...", "start": "...", ...}]' });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: t("buttons.cancel") });
    cancelBtn.onclick = () => this.close();
    const importBtn = buttonDiv.createEl("button", { text: t("buttons.import"), cls: "mod-cta" });
    importBtn.disabled = true;
    importBtn.onclick = async () => {
      if (this.parsedEntries.length === 0) {
        new import_obsidian.Notice("\u26A0\uFE0F " + t("import.noEntries"));
        return;
      }
      try {
        const currentEntries = this.timerManager.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        this.parsedEntries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.timerManager.data.entries = currentEntries;
        await this.timerManager.save();
        if (skippedCount > 0) {
          new import_obsidian.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}, ${t("import.skippedDuplicates")} ${skippedCount} ${t("import.duplicates")}`);
        } else {
          new import_obsidian.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}!`);
        }
        this.close();
        this.onSuccess();
      } catch (error) {
        new import_obsidian.Notice(`\u274C ${t("import.errors_label")}: ${error.message}`);
        console.error("Import error:", error);
      }
    };
  }
  updatePreview(content, previewDiv, importBtn) {
    previewDiv.empty();
    this.parsedEntries = [];
    this.parseWarnings = [];
    if (!content.trim()) {
      previewDiv.style.display = "none";
      importBtn.disabled = true;
      return;
    }
    let result;
    if (this.selectedFormat === "auto") {
      result = autoDetectAndParse(content);
    } else {
      let parser;
      switch (this.selectedFormat) {
        case "timekeep":
          parser = new TimekeepParser();
          break;
        case "csv":
          parser = new CSVParser();
          break;
        case "json":
          parser = new GenericJSONParser();
          break;
        default:
          parser = new TimekeepParser();
      }
      result = { ...parser.parse(content), format: parser.name };
    }
    previewDiv.style.display = "block";
    const formatInfo = previewDiv.createEl("div");
    formatInfo.style.marginBottom = "10px";
    formatInfo.createEl("strong", { text: t("import.format") });
    formatInfo.appendText(" " + (result.format || "?"));
    if (result.errors.length > 0) {
      const errorDiv = previewDiv.createEl("div");
      errorDiv.style.color = "var(--text-error)";
      errorDiv.style.marginBottom = "10px";
      errorDiv.createEl("strong", { text: "\u274C " + t("import.errors_label") + ":" });
      const errorList = errorDiv.createEl("ul");
      errorList.style.margin = "5px 0";
      result.errors.forEach((err) => errorList.createEl("li", { text: err }));
    }
    if (result.warnings.length > 0) {
      const warnDiv = previewDiv.createEl("div");
      warnDiv.style.color = "var(--text-warning)";
      warnDiv.style.marginBottom = "10px";
      warnDiv.createEl("strong", { text: "\u26A0\uFE0F " + t("import.warnings") + ":" });
      const warnList = warnDiv.createEl("ul");
      warnList.style.margin = "5px 0";
      result.warnings.slice(0, 5).forEach((warn) => warnList.createEl("li", { text: warn }));
      if (result.warnings.length > 5) {
        warnList.createEl("li", { text: `... ${t("import.andMore")} ${result.warnings.length - 5} ${t("import.more")}` });
      }
    }
    if (result.entries.length > 0) {
      this.parsedEntries = result.entries;
      importBtn.disabled = false;
      const successDiv = previewDiv.createEl("div");
      successDiv.style.color = "var(--text-success)";
      successDiv.createEl("strong", { text: "\u2705 " + result.entries.length + " " + t("import.entriesFound") });
      const previewTable = previewDiv.createEl("table");
      previewTable.style.width = "100%";
      previewTable.style.marginTop = "10px";
      previewTable.style.fontSize = "12px";
      previewTable.style.borderCollapse = "collapse";
      const thead = previewTable.createEl("thead");
      const headerRow = thead.createEl("tr");
      [t("import.tableHeaders.date"), t("import.tableHeaders.start"), t("import.tableHeaders.end"), t("import.tableHeaders.type")].forEach((h) => {
        const th = headerRow.createEl("th", { text: h });
        th.style.textAlign = "left";
        th.style.padding = "4px";
        th.style.borderBottom = "1px solid var(--background-modifier-border)";
      });
      const tbody = previewTable.createEl("tbody");
      result.entries.slice(0, 5).forEach((entry) => {
        const row = tbody.createEl("tr");
        const startDate = new Date(entry.startTime);
        const endDate = entry.endTime ? new Date(entry.endTime) : null;
        const dateStr = formatDate(startDate);
        const startStr = formatTime(startDate);
        const endStr = endDate ? formatTime(endDate) : "-";
        [dateStr, startStr, endStr, entry.name].forEach((val) => {
          const td = row.createEl("td", { text: val });
          td.style.padding = "4px";
        });
      });
      if (result.entries.length > 5) {
        const moreRow = tbody.createEl("tr");
        const moreCell = moreRow.createEl("td", {
          text: `... ${t("import.andMore")} ${result.entries.length - 5} ${t("import.more")}`,
          attr: { colspan: "4" }
        });
        moreCell.style.padding = "4px";
        moreCell.style.fontStyle = "italic";
        moreCell.style.color = "var(--text-muted)";
      }
    } else {
      importBtn.disabled = true;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings.ts
var DEFAULT_SPECIAL_DAY_BEHAVIORS = [
  {
    id: "jobb",
    label: "Jobb",
    icon: "\u{1F4BC}",
    color: "#4caf50",
    // Green for positive flextime (over goal)
    textColor: "#ffffff",
    negativeColor: "#64b5f6",
    // Blue for negative flextime (under goal)
    negativeTextColor: "#000000",
    simpleColor: "#90caf9",
    // Light blue for simple tracking mode
    simpleTextColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true,
    isWorkType: true
  },
  {
    id: "ferie",
    label: "Ferie",
    icon: "\u{1F3D6}\uFE0F",
    color: "#b3e5fc",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true,
    maxDaysPerYear: 25
  },
  {
    id: "avspasering",
    label: "Avspasering",
    icon: "\u{1F6CC}",
    color: "#ffe0b2",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "withdraw",
    includeInStats: true
  },
  {
    id: "egenmelding",
    label: "Egenmelding",
    icon: "\u{1F912}",
    color: "#c8e6c9",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true,
    maxDaysPerYear: 24,
    countingPeriod: "rolling365"
  },
  {
    id: "sykemelding",
    label: "Sykemelding",
    icon: "\u{1F3E5}",
    color: "#c8e6c9",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  },
  {
    id: "velferdspermisjon",
    label: "Velferdspermisjon",
    icon: "\u{1F3E5}",
    color: "#e1bee7",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  },
  {
    id: "kurs",
    label: "Kurs",
    icon: "\u{1F4DA}",
    color: "#f8bbd0",
    textColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true
  },
  {
    id: "studie",
    label: "Studie",
    icon: "\u{1F4D6}",
    color: "#f8bbd0",
    textColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true
  },
  {
    id: "helligdag",
    label: "Helligdag",
    icon: "\u{1F389}",
    color: "#ef5350",
    textColor: "#ffffff",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  }
];
var DEFAULT_SETTINGS = {
  version: "1.0.0",
  language: "nb",
  defaultViewLocation: "sidebar",
  hourUnit: "t",
  showWeekNumbers: true,
  workPercent: 1,
  baseWorkday: 7.5,
  baseWorkweek: 37.5,
  lunchBreakMinutes: 0,
  includeSaturdayInWorkWeek: false,
  // DEPRECATED
  includeSundayInWorkWeek: false,
  // DEPRECATED
  workDays: [1, 2, 3, 4, 5],
  // Monday-Friday by default
  enableAlternatingWeeks: false,
  alternatingWeekWorkDays: [1, 2, 3, 4, 5],
  // Same as workDays by default
  enableGoalTracking: true,
  // NEW: Default to goal-based tracking (current behavior)
  enableWeeklyGoals: true,
  maxEgenmeldingDays: 8,
  maxFerieDays: 25,
  updateInterval: 3e4,
  clockInterval: 1e3,
  dataFilePath: "timeflow/data.md",
  holidaysFilePath: "timeflow/holidays.md",
  dailyNotesFolder: "Daily Notes",
  dailyNotesTemplatePath: "timeflow/templates/daily-notes.md",
  workdaysPerYear: 260,
  workdaysPerMonth: 21,
  workdaysPerWeek: 5,
  consecutiveFlextimeWarningDays: 5,
  defaultExportWeeks: 52,
  heatmapColumns: 48,
  heatmapShowSpecialDayColors: false,
  noteTypes: [
    {
      id: "daily",
      label: "Daily Note",
      icon: "\u{1F4C5}",
      folder: "Daily Notes",
      template: "timeflow/templates/daily-notes.md",
      tags: [],
      filenamePattern: "{YYYY}-{MM}-{DD}"
    },
    {
      id: "meeting",
      label: "Meeting Note",
      icon: "\u{1F465}",
      folder: "Meetings",
      template: "timeflow/templates/meeting-note.md",
      tags: ["#meeting", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Meeting"
    },
    {
      id: "project",
      label: "Project Note",
      icon: "\u{1F4CB}",
      folder: "Projects",
      template: "timeflow/templates/project-note.md",
      tags: ["#project", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Project"
    },
    {
      id: "review",
      label: "Weekly Review",
      icon: "\u{1F50D}",
      folder: "Reviews",
      template: "timeflow/templates/weekly-review.md",
      tags: ["#review", "#weekly", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Week {WEEK}"
    },
    {
      id: "reflection",
      label: "Reflection Note",
      icon: "\u{1F4AD}",
      folder: "Reflections",
      template: "timeflow/templates/reflection-note.md",
      tags: ["#reflection", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Reflection"
    }
  ],
  specialDayBehaviors: DEFAULT_SPECIAL_DAY_BEHAVIORS,
  specialDayColors: {
    avspasering: "#ffe0b2",
    ferie: "#b3e5fc",
    velferdspermisjon: "#e1bee7",
    egenmelding: "#c8e6c9",
    sykemelding: "#c8e6c9",
    kurs: "#f8bbd0",
    studie: "#f8bbd0"
  },
  specialDayLabels: {
    avspasering: "Avspasering",
    ferie: "Ferie",
    velferdspermisjon: "Velferdspermisjon",
    egenmelding: "Egenmelding",
    sykemelding: "Sykemelding",
    kurs: "Kurs",
    studie: "Studie"
  },
  // Advanced configuration settings
  balanceStartDate: "2025-01-01",
  halfDayHours: 4,
  halfDayMode: "fixed",
  balanceThresholds: {
    criticalLow: -15,
    warningLow: 0,
    warningHigh: 80,
    criticalHigh: 95
  },
  validationThresholds: {
    longRunningTimerHours: 12,
    veryLongSessionHours: 16,
    maxDurationHours: 24,
    highWeeklyTotalHours: 50
  },
  // NEW: Custom colors
  customColors: {
    balanceOk: "#4caf50",
    balanceWarning: "#ff9800",
    balanceCritical: "#f44336",
    progressBar: "#4caf50"
  },
  // Norwegian labor law compliance settings
  complianceSettings: {
    enableWarnings: true,
    dailyHoursLimit: 9,
    weeklyHoursLimit: 40,
    minimumRestHours: 11
  },
  // Migration flags
  hasTimestampMigration: false
};
var SpecialDayBehaviorModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, behavior, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.behavior = behavior;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    const { contentEl } = this;
    contentEl.empty();
    const isWorkType = (_b = (_a = this.behavior) == null ? void 0 : _a.isWorkType) != null ? _b : false;
    contentEl.createEl("h2", { text: isWorkType ? "Edit Work Entry Type" : this.behavior ? "Edit Special Day Type" : "Add Special Day Type" });
    if (this.behavior && !isWorkType) {
      const norwegianTerms = {
        "egenmelding": "Norwegian self-reported sick leave (max 8 days/year per Norwegian labor law)",
        "velferdspermisjon": "Norwegian welfare leave for personal/family health matters",
        "avspasering": "Norwegian term: Time off as compensation for accumulated flextime"
      };
      const explanation = norwegianTerms[this.behavior.id];
      if (explanation) {
        const infoBox = contentEl.createDiv({ cls: "setting-item-description" });
        infoBox.style.padding = "10px";
        infoBox.style.marginBottom = "15px";
        infoBox.style.background = "var(--background-secondary)";
        infoBox.style.borderRadius = "5px";
        infoBox.style.fontSize = "0.9em";
        infoBox.createSpan({ text: "\u2139\uFE0F " + explanation });
      }
    }
    if (isWorkType) {
      const infoBox = contentEl.createDiv({ cls: "setting-item-description" });
      infoBox.style.padding = "10px";
      infoBox.style.marginBottom = "15px";
      infoBox.style.background = "var(--background-secondary)";
      infoBox.style.borderRadius = "5px";
      infoBox.style.fontSize = "0.9em";
      infoBox.createSpan({ text: "\u{1F4BC} This is your regular work entry type. Customize its appearance in the calendar." });
    }
    const formData = {
      id: ((_c = this.behavior) == null ? void 0 : _c.id) || "",
      label: ((_d = this.behavior) == null ? void 0 : _d.label) || "",
      icon: ((_e = this.behavior) == null ? void 0 : _e.icon) || "",
      color: ((_f = this.behavior) == null ? void 0 : _f.color) || "#b3e5fc",
      textColor: ((_g = this.behavior) == null ? void 0 : _g.textColor) || "#000000",
      negativeColor: ((_h = this.behavior) == null ? void 0 : _h.negativeColor) || "#64b5f6",
      negativeTextColor: ((_i = this.behavior) == null ? void 0 : _i.negativeTextColor) || "#000000",
      simpleColor: ((_j = this.behavior) == null ? void 0 : _j.simpleColor) || "#90caf9",
      simpleTextColor: ((_k = this.behavior) == null ? void 0 : _k.simpleTextColor) || "#000000",
      noHoursRequired: (_m = (_l = this.behavior) == null ? void 0 : _l.noHoursRequired) != null ? _m : true,
      flextimeEffect: ((_n = this.behavior) == null ? void 0 : _n.flextimeEffect) || "none",
      includeInStats: (_p = (_o = this.behavior) == null ? void 0 : _o.includeInStats) != null ? _p : true,
      maxDaysPerYear: ((_q = this.behavior) == null ? void 0 : _q.maxDaysPerYear) || void 0,
      countingPeriod: ((_r = this.behavior) == null ? void 0 : _r.countingPeriod) || "calendar",
      isWorkType
    };
    if (!isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("ID").setDesc("Unique identifier (lowercase, no spaces). Used in holiday file format.").addText((text) => {
        text.setPlaceholder("ferie").setValue(formData.id).onChange((value) => formData.id = value.toLowerCase().replace(/\s+/g, ""));
        if (this.behavior) {
          text.setDisabled(true);
        }
      });
    }
    new import_obsidian2.Setting(contentEl).setName("Label").setDesc("Display name shown in the dashboard").addText((text) => text.setPlaceholder(isWorkType ? "Jobb" : "Ferie").setValue(formData.label).onChange((value) => formData.label = value));
    new import_obsidian2.Setting(contentEl).setName("Icon").setDesc("Emoji to display").addText((text) => text.setPlaceholder(isWorkType ? "\u{1F4BC}" : "\u{1F3D6}\uFE0F").setValue(formData.icon).onChange((value) => formData.icon = value));
    if (isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("Positive flextime color").setDesc("Background color when hours exceed daily goal (green gradient base)").addColorPicker((color) => color.setValue(formData.color).onChange((value) => formData.color = value));
      new import_obsidian2.Setting(contentEl).setName("Positive flextime text color").setDesc("Text color for positive flextime days").addColorPicker((color) => color.setValue(formData.textColor).onChange((value) => formData.textColor = value));
      new import_obsidian2.Setting(contentEl).setName("Negative flextime color").setDesc("Background color when hours are below daily goal (blue gradient base)").addColorPicker((color) => color.setValue(formData.negativeColor).onChange((value) => formData.negativeColor = value));
      new import_obsidian2.Setting(contentEl).setName("Negative flextime text color").setDesc("Text color for negative flextime days").addColorPicker((color) => color.setValue(formData.negativeTextColor).onChange((value) => formData.negativeTextColor = value));
      contentEl.createEl("h4", { text: "Simple tracking mode colors" });
      contentEl.createDiv({
        cls: "setting-item-description",
        text: "These colors are used when goal tracking is disabled."
      }).style.marginBottom = "10px";
      new import_obsidian2.Setting(contentEl).setName("Work day color").setDesc("Background color for work days in simple tracking mode").addColorPicker((color) => color.setValue(formData.simpleColor).onChange((value) => formData.simpleColor = value));
      new import_obsidian2.Setting(contentEl).setName("Work day text color").setDesc("Text color for work days in simple tracking mode").addColorPicker((color) => color.setValue(formData.simpleTextColor).onChange((value) => formData.simpleTextColor = value));
    } else {
      new import_obsidian2.Setting(contentEl).setName("Color").setDesc("Background color for this day type in calendar").addColorPicker((color) => color.setValue(formData.color).onChange((value) => formData.color = value));
      new import_obsidian2.Setting(contentEl).setName("Text color").setDesc("Text color for this day type (use white for dark backgrounds)").addColorPicker((color) => color.setValue(formData.textColor).onChange((value) => formData.textColor = value));
    }
    if (!isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("No hours required").setDesc("If enabled, you don't need to log any work hours this day (e.g., vacation, sick leave). If disabled, regular workday goal applies.").addToggle((toggle) => toggle.setValue(formData.noHoursRequired).onChange((value) => formData.noHoursRequired = value));
      new import_obsidian2.Setting(contentEl).setName("Flextime effect").setDesc("How this day type affects your flextime balance").addDropdown((dropdown) => dropdown.addOption("none", "No effect (counts as full workday)").addOption("withdraw", "Withdraw (uses flextime balance)").addOption("accumulate", "Accumulate (excess hours add to flextime)").setValue(formData.flextimeEffect).onChange((value) => formData.flextimeEffect = value));
      new import_obsidian2.Setting(contentEl).setName("Include in statistics").setDesc("Show this day type in yearly statistics").addToggle((toggle) => toggle.setValue(formData.includeInStats).onChange((value) => formData.includeInStats = value));
      new import_obsidian2.Setting(contentEl).setName("Max days per year (optional)").setDesc("Yearly limit for this day type (e.g., 25 for vacation). Leave empty for no limit.").addText((text) => {
        var _a2;
        return text.setPlaceholder("25").setValue(((_a2 = formData.maxDaysPerYear) == null ? void 0 : _a2.toString()) || "").onChange((value) => {
          const num = parseInt(value);
          formData.maxDaysPerYear = isNaN(num) ? void 0 : num;
        });
      });
      new import_obsidian2.Setting(contentEl).setName("Counting period").setDesc("How to count the max days limit. Calendar year resets each January 1st. Rolling 365 days counts backwards from today.").addDropdown((dropdown) => dropdown.addOption("calendar", "Calendar year").addOption("rolling365", "Rolling 365 days").setValue(formData.countingPeriod).onChange((value) => formData.countingPeriod = value));
    }
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = () => {
      if (!formData.id) {
        new import_obsidian2.Notice("\u26A0\uFE0F ID is required");
        return;
      }
      if (!formData.label) {
        new import_obsidian2.Notice("\u26A0\uFE0F Label is required");
        return;
      }
      if (!formData.icon) {
        new import_obsidian2.Notice("\u26A0\uFE0F Icon is required");
        return;
      }
      if (!this.behavior || this.behavior.id !== formData.id) {
        const isDuplicate = this.plugin.settings.specialDayBehaviors.some(
          (b, i) => b.id === formData.id && i !== this.index
        );
        if (isDuplicate) {
          new import_obsidian2.Notice("\u26A0\uFE0F A special day type with this ID already exists");
          return;
        }
      }
      const behavior = {
        id: formData.isWorkType ? this.behavior.id : formData.id,
        // Keep original ID for work types
        label: formData.label,
        icon: formData.icon,
        color: formData.color,
        textColor: formData.textColor,
        negativeColor: formData.isWorkType ? formData.negativeColor : void 0,
        negativeTextColor: formData.isWorkType ? formData.negativeTextColor : void 0,
        simpleColor: formData.isWorkType ? formData.simpleColor : void 0,
        simpleTextColor: formData.isWorkType ? formData.simpleTextColor : void 0,
        noHoursRequired: formData.isWorkType ? false : formData.noHoursRequired,
        flextimeEffect: formData.isWorkType ? "accumulate" : formData.flextimeEffect,
        includeInStats: formData.isWorkType ? true : formData.includeInStats,
        maxDaysPerYear: formData.isWorkType ? void 0 : formData.maxDaysPerYear,
        countingPeriod: formData.isWorkType ? void 0 : formData.countingPeriod,
        isWorkType: formData.isWorkType
      };
      this.onSave(behavior, this.index);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TimeFlowSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async refreshView() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("timeflow-view");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && typeof view.refresh === "function") {
        await view.refresh();
      }
    }
  }
  addResetButton(setting, settingKey, defaultValue, refreshCallback) {
    setting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[settingKey] = defaultValue;
        await this.plugin.saveSettings();
        this.display();
        if (refreshCallback) {
          await refreshCallback();
        }
      })
    );
  }
  validateNumber(value, min, max, settingName) {
    const num = parseFloat(value);
    if (isNaN(num)) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Please enter a valid number`);
      return null;
    }
    if (num < min) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Value must be at least ${min}`);
      return null;
    }
    if (num > max) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Value must be at most ${max}`);
      return null;
    }
    return num;
  }
  validateDateFormat(dateStr) {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      new import_obsidian2.Notice("\u274C Balance start date: Format must be YYYY-MM-DD");
      return false;
    }
    const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
    if (isNaN(date.getTime())) {
      new import_obsidian2.Notice("\u274C Balance start date: Invalid date");
      return false;
    }
    if (date > /* @__PURE__ */ new Date()) {
      new import_obsidian2.Notice("\u274C Balance start date: Cannot be in the future");
      return false;
    }
    return true;
  }
  createCollapsibleSubsection(container, title, startOpen = false) {
    const header = container.createDiv({
      cls: startOpen ? "tf-collapsible-subsection open" : "tf-collapsible-subsection"
    });
    header.createSpan({ text: title });
    const content = container.createDiv({
      cls: startOpen ? "tf-collapsible-content open" : "tf-collapsible-content"
    });
    header.onclick = () => {
      header.classList.toggle("open");
      content.classList.toggle("open");
    };
    return { header, content };
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "timeflow Settings" });
    const searchContainer = containerEl.createDiv({ cls: "tf-settings-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u{1F50D} Search settings...",
      cls: "tf-search-input"
    });
    const settingsContainer = containerEl.createDiv({ cls: "tf-settings-container" });
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase();
      const allSettings = settingsContainer.querySelectorAll(".setting-item");
      allSettings.forEach((setting) => {
        var _a, _b, _c, _d;
        const name = ((_b = (_a = setting.querySelector(".setting-item-name")) == null ? void 0 : _a.textContent) == null ? void 0 : _b.toLowerCase()) || "";
        const desc = ((_d = (_c = setting.querySelector(".setting-item-description")) == null ? void 0 : _c.textContent) == null ? void 0 : _d.toLowerCase()) || "";
        if (name.includes(query) || desc.includes(query)) {
          setting.style.display = "";
        } else {
          setting.style.display = "none";
        }
      });
    });
    new import_obsidian2.Setting(settingsContainer).setName("Quick Start").setDesc("Essential settings to get started with timeflow").setHeading();
    const syncInfo = settingsContainer.createDiv();
    syncInfo.style.marginBottom = "15px";
    syncInfo.style.padding = "10px";
    syncInfo.style.background = "var(--background-secondary)";
    syncInfo.style.borderRadius = "5px";
    syncInfo.style.fontSize = "0.9em";
    syncInfo.createEl("strong", { text: "\u{1F4F1} Cross-Device Settings Sync" });
    syncInfo.createEl("br");
    syncInfo.appendText("Settings are automatically saved to ");
    syncInfo.createEl("code", { text: "timeflow/data.md" });
    syncInfo.appendText(" and will sync across devices when using Obsidian Sync or any other vault sync solution. When you open the plugin on another device, your settings will be automatically loaded.");
    new import_obsidian2.Setting(settingsContainer).setName("Language / Spr\xE5k").setDesc("Interface language / Grensesnittspr\xE5k").addDropdown((dropdown) => dropdown.addOption("nb", "Norsk").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      setLanguage(value);
      await this.plugin.saveSettings();
      this.display();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Data file path").setDesc("Path to the file containing timer data and settings").addText((text) => text.setPlaceholder("timeflow/data.md").setValue(this.plugin.settings.dataFilePath).onChange(async (value) => {
      this.plugin.settings.dataFilePath = value;
      await this.plugin.saveSettings();
      this.plugin.timerManager.dataFile = value;
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Holidays file path").setDesc("Path to the file containing future planned days/holidays").addText((text) => text.setPlaceholder("timeflow/holidays.md").setValue(this.plugin.settings.holidaysFilePath).onChange(async (value) => {
      this.plugin.settings.holidaysFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Work Configuration").setDesc("Configure your work schedule and goals").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Enable goal tracking").setDesc("Enable flextime calculations and daily/weekly goals. Disable for simple hour tracking without goals (e.g., shift workers, freelancers).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableGoalTracking).onChange(async (value) => {
      this.plugin.settings.enableGoalTracking = value;
      await this.plugin.saveSettings();
      this.display();
      await this.refreshView();
    }));
    if (this.plugin.settings.enableGoalTracking) {
      new import_obsidian2.Setting(settingsContainer).setName("Base workday hours").setDesc("Standard hours for a full workday (e.g., 7.5 for standard, 6 for 6-hour days)").addText((text) => text.setPlaceholder("7.5").setValue(this.plugin.settings.baseWorkday.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.baseWorkday = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      new import_obsidian2.Setting(settingsContainer).setName("Enable weekly goals").setDesc("Disable if you don't have a specific amount of work each week. This will hide goal progress bars and weekly targets.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWeeklyGoals).onChange(async (value) => {
        this.plugin.settings.enableWeeklyGoals = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableWeeklyGoals) {
        new import_obsidian2.Setting(settingsContainer).setName("Work percentage").setDesc("Your employment percentage. Adjusts weekly work goal. Example: 0.8 (80%) = 30h/week if base is 37.5h").addText((text) => text.setPlaceholder("1.0").setValue(this.plugin.settings.workPercent.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0 && num <= 1) {
            this.plugin.settings.workPercent = num;
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
        new import_obsidian2.Setting(settingsContainer).setName("Base workweek hours").setDesc("Standard hours for a full workweek (e.g., 37.5 for 5 days, 30 for 4 days)").addText((text) => text.setPlaceholder("37.5").setValue(this.plugin.settings.baseWorkweek.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.baseWorkweek = num;
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
      }
      new import_obsidian2.Setting(settingsContainer).setName("Lunch break duration").setDesc("Daily lunch break in minutes (e.g., 30 for 30 minutes). This will be deducted from your work hours automatically.").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.lunchBreakMinutes.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.lunchBreakMinutes = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const workDaysSetting = new import_obsidian2.Setting(settingsContainer).setName("Work days").setDesc("Select which days are part of your work week");
      const workDaysContainer = settingsContainer.createDiv();
      workDaysContainer.style.display = "flex";
      workDaysContainer.style.flexWrap = "wrap";
      workDaysContainer.style.gap = "8px";
      workDaysContainer.style.marginBottom = "15px";
      dayNames.forEach((dayName, dayIndex) => {
        const dayButton = workDaysContainer.createEl("button");
        dayButton.textContent = dayName.substring(0, 3);
        dayButton.className = "tf-day-button";
        dayButton.style.padding = "8px 12px";
        dayButton.style.border = "1px solid var(--background-modifier-border)";
        dayButton.style.borderRadius = "4px";
        dayButton.style.cursor = "pointer";
        dayButton.style.background = this.plugin.settings.workDays.includes(dayIndex) ? "var(--interactive-accent)" : "var(--background-secondary)";
        dayButton.style.color = this.plugin.settings.workDays.includes(dayIndex) ? "var(--text-on-accent)" : "var(--text-normal)";
        dayButton.onclick = async () => {
          const currentWorkDays = [...this.plugin.settings.workDays];
          const index = currentWorkDays.indexOf(dayIndex);
          if (index > -1) {
            currentWorkDays.splice(index, 1);
          } else {
            currentWorkDays.push(dayIndex);
            currentWorkDays.sort((a, b) => a - b);
          }
          this.plugin.settings.workDays = currentWorkDays;
          await this.plugin.saveSettings();
          this.display();
        };
      });
      new import_obsidian2.Setting(settingsContainer).setName("Enable alternating weeks").setDesc("Enable if you have different work days in alternating weeks (e.g., every other weekend)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAlternatingWeeks).onChange(async (value) => {
        this.plugin.settings.enableAlternatingWeeks = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableAlternatingWeeks) {
        const altWorkDaysSetting = new import_obsidian2.Setting(settingsContainer).setName("Alternating week work days").setDesc("Select which days are work days in the alternating week");
        const altWorkDaysContainer = settingsContainer.createDiv();
        altWorkDaysContainer.style.display = "flex";
        altWorkDaysContainer.style.flexWrap = "wrap";
        altWorkDaysContainer.style.gap = "8px";
        altWorkDaysContainer.style.marginBottom = "15px";
        dayNames.forEach((dayName, dayIndex) => {
          const dayButton = altWorkDaysContainer.createEl("button");
          dayButton.textContent = dayName.substring(0, 3);
          dayButton.className = "tf-day-button";
          dayButton.style.padding = "8px 12px";
          dayButton.style.border = "1px solid var(--background-modifier-border)";
          dayButton.style.borderRadius = "4px";
          dayButton.style.cursor = "pointer";
          dayButton.style.background = this.plugin.settings.alternatingWeekWorkDays.includes(dayIndex) ? "var(--interactive-accent)" : "var(--background-secondary)";
          dayButton.style.color = this.plugin.settings.alternatingWeekWorkDays.includes(dayIndex) ? "var(--text-on-accent)" : "var(--text-normal)";
          dayButton.onclick = async () => {
            const currentAltWorkDays = [...this.plugin.settings.alternatingWeekWorkDays];
            const index = currentAltWorkDays.indexOf(dayIndex);
            if (index > -1) {
              currentAltWorkDays.splice(index, 1);
            } else {
              currentAltWorkDays.push(dayIndex);
              currentAltWorkDays.sort((a, b) => a - b);
            }
            this.plugin.settings.alternatingWeekWorkDays = currentAltWorkDays;
            await this.plugin.saveSettings();
            this.display();
          };
        });
      }
    }
    const complianceSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Work Time Limits",
      false
    );
    complianceSection.content.addClass("tf-compliance-settings");
    new import_obsidian2.Setting(complianceSection.content).setName("Enable compliance warnings").setDesc("Show warnings when approaching or exceeding Norwegian labor law limits").addToggle((toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) != null ? _b : true).onChange(async (value) => {
        if (!this.plugin.settings.complianceSettings) {
          this.plugin.settings.complianceSettings = {
            enableWarnings: true,
            dailyHoursLimit: 9,
            weeklyHoursLimit: 40,
            minimumRestHours: 11
          };
        }
        this.plugin.settings.complianceSettings.enableWarnings = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Daily hours limit").setDesc("Maximum hours per day before showing a warning (Norwegian law: 9 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("9").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.dailyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Weekly hours limit").setDesc("Maximum hours per week before showing a warning (Norwegian law: 40 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("40").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.weeklyHoursLimit) != null ? _b : 40).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.weeklyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Minimum rest hours").setDesc("Minimum consecutive hours of rest between work sessions (Norwegian law: 11 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("11").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.minimumRestHours = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    const getBehaviorDescription = (behavior) => {
      const parts = [];
      if (behavior.isWorkType) {
        parts.push("Regular work entry");
      } else {
        parts.push(behavior.noHoursRequired ? "No hours required" : "Regular workday applies");
      }
      if (behavior.flextimeEffect === "withdraw") {
        parts.push("withdraws from flextime");
      } else if (behavior.flextimeEffect === "accumulate") {
        parts.push("excess counts as flextime");
      } else {
        parts.push("no flextime change");
      }
      if (behavior.maxDaysPerYear) {
        parts.push(`max ${behavior.maxDaysPerYear} days/year`);
      }
      return parts.join(", ");
    };
    const workTypes = this.plugin.settings.specialDayBehaviors.filter((b) => b.isWorkType || b.id === "jobb");
    const specialDays = this.plugin.settings.specialDayBehaviors.filter((b) => !b.isWorkType && b.id !== "jobb");
    new import_obsidian2.Setting(settingsContainer).setName("Work Entry Type").setDesc("Configure the appearance of your regular work entries").setHeading();
    workTypes.forEach((behavior) => {
      const index = this.plugin.settings.specialDayBehaviors.findIndex((b) => b.id === behavior.id);
      new import_obsidian2.Setting(settingsContainer).setName(`${behavior.icon} ${behavior.label}`).setDesc(getBehaviorDescription(behavior)).addButton((btn) => btn.setButtonText("Edit").onClick(() => {
        new SpecialDayBehaviorModal(
          this.app,
          this.plugin,
          behavior,
          index,
          async (updatedBehavior, idx) => {
            this.plugin.settings.specialDayBehaviors[idx] = updatedBehavior;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName("Special Day Types").setDesc("Configure how different types of special days affect your workday and flextime balance. These settings determine how days are counted in flextime calculations.").setHeading();
    specialDays.forEach((behavior) => {
      const index = this.plugin.settings.specialDayBehaviors.findIndex((b) => b.id === behavior.id);
      new import_obsidian2.Setting(settingsContainer).setName(`${behavior.icon} ${behavior.label}`).setDesc(getBehaviorDescription(behavior)).addButton((btn) => btn.setButtonText("Edit").onClick(() => {
        new SpecialDayBehaviorModal(
          this.app,
          this.plugin,
          behavior,
          index,
          async (updatedBehavior, idx) => {
            this.plugin.settings.specialDayBehaviors[idx] = updatedBehavior;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      })).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(async () => {
        const confirmation = confirm(
          `Are you sure you want to delete "${behavior.label}"?

Note: Historical data in your holidays file using "${behavior.id}" will no longer be recognized.`
        );
        if (confirmation) {
          this.plugin.settings.specialDayBehaviors.splice(index, 1);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName("Add new special day type").setDesc("Create a custom day type with your own rules").addButton((btn) => btn.setButtonText("+ Add").setCta().onClick(() => {
      new SpecialDayBehaviorModal(
        this.app,
        this.plugin,
        null,
        // New behavior
        this.plugin.settings.specialDayBehaviors.length,
        // Index at end
        async (newBehavior) => {
          this.plugin.settings.specialDayBehaviors.push(newBehavior);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      ).open();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Display & Interface").setDesc("Customize the appearance and behavior of the timeflow interface").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Default view location").setDesc("Choose where timeflow opens by default").addDropdown((dropdown) => dropdown.addOption("sidebar", "Sidebar (right panel)").addOption("main", "Main area (as a tab)").setValue(this.plugin.settings.defaultViewLocation).onChange(async (value) => {
      this.plugin.settings.defaultViewLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Hour unit").setDesc('Choose the unit symbol for displaying hours: "h" for hours or "t" for timer').addDropdown((dropdown) => dropdown.addOption("h", "h (hours)").addOption("t", "t (timer)").setValue(this.plugin.settings.hourUnit).onChange(async (value) => {
      this.plugin.settings.hourUnit = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Show week numbers").setDesc("Show week numbers in calendar and week card (ISO 8601 week numbers)").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.showWeekNumbers) != null ? _a : true).onChange(async (value) => {
        this.plugin.settings.showWeekNumbers = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian2.Setting(settingsContainer).setName("Consecutive flextime warning days").setDesc("Number of consecutive days with flextime before showing a warning").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.consecutiveFlextimeWarningDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.consecutiveFlextimeWarningDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Heatmap columns").setDesc("Number of columns in the heatmap view (adjust for your screen width)").addText((text) => text.setPlaceholder("48").setValue(this.plugin.settings.heatmapColumns.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.heatmapColumns = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Heatmap special day colors").setDesc("Show special day colors (ferie, egenmelding, etc.) instead of flextime gradient in heatmap").addToggle((toggle) => toggle.setValue(this.plugin.settings.heatmapShowSpecialDayColors).onChange(async (value) => {
      this.plugin.settings.heatmapShowSpecialDayColors = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Update interval (ms)").setDesc("How often to update the dashboard data (in milliseconds)").addText((text) => text.setPlaceholder("30000").setValue(this.plugin.settings.updateInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.updateInterval = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("File Paths & Templates").setDesc("Configure file paths and note templates").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Daily notes folder").setDesc("Folder where daily notes are stored").addText((text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
      this.plugin.settings.dailyNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Daily notes template path").setDesc("Path to the template for daily notes").addText((text) => text.setPlaceholder("Templates/Daily Notes Template.md").setValue(this.plugin.settings.dailyNotesTemplatePath).onChange(async (value) => {
      this.plugin.settings.dailyNotesTemplatePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Note types").setDesc("Configure the types of notes available in the calendar context menu. Each note type can have its own template, folder, and filename pattern.").setHeading();
    this.plugin.settings.noteTypes.forEach((noteType, index) => {
      new import_obsidian2.Setting(settingsContainer).setName(`${noteType.icon} ${noteType.label}`).setDesc(`Folder: ${noteType.folder} | Template: ${noteType.template}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        this.showNoteTypeModal(noteType, index);
      })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        this.plugin.settings.noteTypes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.refreshView();
        this.display();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName("Add new note type").setDesc("Create a new note type for the context menu").addButton((button) => button.setButtonText("+ Add note type").setCta().onClick(() => {
      this.showNoteTypeModal(null, -1);
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Data Management").setDesc("Import and export your time tracking data").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Export data to CSV").setDesc("Export all your time tracking data to a CSV file").addButton((button) => button.setButtonText("Export CSV").setCta().onClick(async () => {
      this.exportToCSV();
    }));
    new import_obsidian2.Setting(settingsContainer).setName(t("settings.importData")).setDesc(t("settings.importDataDesc")).addButton((button) => button.setButtonText(t("settings.importData")).setCta().onClick(async () => {
      this.showImportModal();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Advanced Settings").setDesc("Fine-tune balance calculations, thresholds, and visual customization").setHeading();
    const advancedInfo = settingsContainer.createDiv();
    advancedInfo.style.marginBottom = "15px";
    advancedInfo.style.padding = "10px";
    advancedInfo.style.background = "var(--background-secondary)";
    advancedInfo.style.borderRadius = "5px";
    advancedInfo.style.fontSize = "0.9em";
    advancedInfo.createEl("strong", { text: "\u2699\uFE0F Advanced Settings" });
    advancedInfo.createEl("br");
    advancedInfo.appendText("These settings affect balance calculations and visual indicators. Settings sync across devices via your data file.");
    const balanceCalcSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance Calculation",
      false
    );
    new import_obsidian2.Setting(balanceCalcSection.content).setName("Balance start date").setDesc("Set the date from which flextime balance is calculated. Earlier entries are ignored in balance calculations. Format: YYYY-MM-DD").addText((text) => text.setPlaceholder("2025-01-01").setValue(this.plugin.settings.balanceStartDate).onChange(async (value) => {
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          this.plugin.settings.balanceStartDate = value;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }
    }));
    new import_obsidian2.Setting(balanceCalcSection.content).setName("Half-day calculation mode").setDesc("How half-day hours should be calculated").addDropdown((dropdown) => dropdown.addOption("fixed", "Fixed hours (set specific value)").addOption("percentage", "Percentage (half of base workday)").setValue(this.plugin.settings.halfDayMode).onChange(async (value) => {
      this.plugin.settings.halfDayMode = value;
      await this.plugin.saveSettings();
      await this.refreshView();
      this.display();
    }));
    if (this.plugin.settings.halfDayMode === "fixed") {
      new import_obsidian2.Setting(balanceCalcSection.content).setName("Half-day hours").setDesc("Hours counted for a half workday").addText((text) => text.setPlaceholder("4.0").setValue(this.plugin.settings.halfDayHours.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0 && num < this.plugin.settings.baseWorkday) {
          this.plugin.settings.halfDayHours = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
    }
    const balanceThresholdsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance Color Thresholds",
      false
    );
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Balance color thresholds").setDesc("Configure the hour thresholds for balance indicator colors. These control the color-coding of your flextime balance badge: Red = significant under/overtime, Yellow = approaching limits, Green = healthy balance.");
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Critical low threshold (red)").setDesc("Below this many hours = red badge (significant undertime)").addText((text) => text.setPlaceholder("-15").setValue(this.plugin.settings.balanceThresholds.criticalLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num < this.plugin.settings.balanceThresholds.warningLow) {
        this.plugin.settings.balanceThresholds.criticalLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Warning low threshold (yellow)").setDesc("Below this = yellow badge (approaching undertime)").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.balanceThresholds.warningLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.criticalLow && num < this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.warningLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Warning high threshold (yellow)").setDesc("Above this = yellow badge (approaching overtime limit)").addText((text) => text.setPlaceholder("80").setValue(this.plugin.settings.balanceThresholds.warningHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningLow && num < this.plugin.settings.balanceThresholds.criticalHigh) {
        this.plugin.settings.balanceThresholds.warningHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Critical high threshold (red)").setDesc("Above this = red badge (significant overtime accumulation)").addText((text) => text.setPlaceholder("95").setValue(this.plugin.settings.balanceThresholds.criticalHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.criticalHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    const dataValidationSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Data Validation Thresholds",
      false
    );
    new import_obsidian2.Setting(dataValidationSection.content).setName("Data validation thresholds").setDesc("Automatic data quality checks. Adjust these if you frequently work long hours or want stricter validation.");
    new import_obsidian2.Setting(dataValidationSection.content).setName("Long-running timer warning (hours)").setDesc("Warn if a timer runs more than X hours without being stopped (default: 12)").addText((text) => text.setPlaceholder("12").setValue(this.plugin.settings.validationThresholds.longRunningTimerHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.longRunningTimerHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("Very long session warning (hours)").setDesc("Warn if a work session exceeds X hours (default: 16)").addText((text) => text.setPlaceholder("16").setValue(this.plugin.settings.validationThresholds.veryLongSessionHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.veryLongSessionHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("Maximum session duration (hours)").setDesc("Prevent entries longer than X hours - likely a data error (default: 24)").addText((text) => text.setPlaceholder("24").setValue(this.plugin.settings.validationThresholds.maxDurationHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.maxDurationHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("High weekly total info (hours)").setDesc("Show info notice if weekly total exceeds X hours (default: 60)").addText((text) => text.setPlaceholder("60").setValue(this.plugin.settings.validationThresholds.highWeeklyTotalHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.highWeeklyTotalHours = num;
        await this.plugin.saveSettings();
      }
    }));
    const customColorsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Custom Colors",
      false
    );
    const balanceOkSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance OK color").setDesc("Color when flextime balance is in acceptable range").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceOk) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceOkSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = DEFAULT_SETTINGS.customColors.balanceOk;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceWarningSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance warning color").setDesc("Color when flextime balance is approaching limits").addText((text) => {
      var _a;
      return text.setPlaceholder("#ff9800").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceWarning) || "#ff9800").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceWarningSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = DEFAULT_SETTINGS.customColors.balanceWarning;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceCriticalSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance critical color").setDesc("Color when flextime balance is critically out of range").addText((text) => {
      var _a;
      return text.setPlaceholder("#f44336").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceCritical) || "#f44336").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceCriticalSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = DEFAULT_SETTINGS.customColors.balanceCritical;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const progressBarSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Progress bar color").setDesc("Color for progress bars showing daily/weekly completion").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    progressBarSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = DEFAULT_SETTINGS.customColors.progressBar;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
  }
  exportToCSV() {
    const entries = this.plugin.timerManager.convertToTimeEntries();
    const rows = [["Name", "Start Time", "End Time", "Duration (hours)"]];
    entries.forEach((entry) => {
      if (entry.startTime && entry.endTime) {
        const start = new Date(entry.startTime);
        const end = new Date(entry.endTime);
        const durationHours = ((end.getTime() - start.getTime()) / (1e3 * 60 * 60)).toFixed(2);
        rows.push([
          entry.name,
          start.toISOString(),
          end.toISOString(),
          durationHours
        ]);
      }
    });
    const csv = rows.map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian2.Notice("\u2705 Exported to CSV");
  }
  showImportModal() {
    new ImportModal(this.app, this.plugin.timerManager, async () => {
      await this.refreshView();
    }).open();
  }
  showNoteTypeModal(noteType, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(noteType ? "Edit Note Type" : "Add Note Type");
    const { contentEl } = modal;
    const formData = {
      id: (noteType == null ? void 0 : noteType.id) || "",
      label: (noteType == null ? void 0 : noteType.label) || "",
      icon: (noteType == null ? void 0 : noteType.icon) || "\u{1F4C4}",
      folder: (noteType == null ? void 0 : noteType.folder) || "",
      template: (noteType == null ? void 0 : noteType.template) || "",
      tags: (noteType == null ? void 0 : noteType.tags.join(", ")) || "",
      filenamePattern: (noteType == null ? void 0 : noteType.filenamePattern) || "{YYYY}-{MM}-{DD}"
    };
    new import_obsidian2.Setting(contentEl).setName("ID").setDesc("Unique identifier for this note type (lowercase, no spaces)").addText((text) => {
      text.setPlaceholder("meeting").setValue(formData.id).onChange((value) => {
        formData.id = value.toLowerCase().replace(/\s+/g, "-");
      });
      if (noteType) {
        text.inputEl.disabled = true;
      }
    });
    new import_obsidian2.Setting(contentEl).setName("Label").setDesc("Display name shown in the context menu").addText((text) => text.setPlaceholder("M\xF8tenotat").setValue(formData.label).onChange((value) => {
      formData.label = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Icon").setDesc("Emoji or icon to display (single character)").addText((text) => text.setPlaceholder("\u{1F465}").setValue(formData.icon).onChange((value) => {
      formData.icon = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Folder").setDesc("Folder where notes will be created").addText((text) => text.setPlaceholder("M\xF8ter").setValue(formData.folder).onChange((value) => {
      formData.folder = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Template Path").setDesc("Path to the template file (relative to vault root)").addText((text) => text.setPlaceholder("timeflow/templates/meeting-note.md").setValue(formData.template).onChange((value) => {
      formData.template = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Tags").setDesc("Comma-separated tags to add to notes (e.g., #m\xF8te, #timeflow)").addText((text) => text.setPlaceholder("#m\xF8te, #timeflow").setValue(formData.tags).onChange((value) => {
      formData.tags = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Filename Pattern").setDesc("Pattern for note filenames. Available: {YYYY}, {MM}, {DD}, {WEEK}").addText((text) => text.setPlaceholder("{YYYY}-{MM}-{DD} M\xF8te").setValue(formData.filenamePattern).onChange((value) => {
      formData.filenamePattern = value;
    }));
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginTop = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.style.fontSize = "0.9em";
    infoDiv.createEl("strong", { text: "\u{1F4CB} Pattern Variables:" });
    const ul = infoDiv.createEl("ul");
    ul.style.margin = "8px 0 0 20px";
    const patterns = [
      ["{YYYY}", "Four-digit year (e.g., 2025)"],
      ["{MM}", "Two-digit month (e.g., 01)"],
      ["{DD}", "Two-digit day (e.g., 15)"],
      ["{WEEK}", "ISO week number (e.g., 07)"]
    ];
    patterns.forEach(([code, desc]) => {
      const li = ul.createEl("li");
      li.createEl("code", { text: code });
      li.appendText(" - " + desc);
    });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!formData.id || !formData.label || !formData.folder) {
        new import_obsidian2.Notice("\u26A0\uFE0F Please fill in all required fields (ID, Label, Folder)");
        return;
      }
      const tagsArray = formData.tags.split(",").map((t2) => t2.trim()).filter((t2) => t2.length > 0);
      const newNoteType = {
        id: formData.id,
        label: formData.label,
        icon: formData.icon || "\u{1F4C4}",
        folder: formData.folder,
        template: formData.template,
        tags: tagsArray,
        filenamePattern: formData.filenamePattern || "{YYYY}-{MM}-{DD}"
      };
      if (index >= 0) {
        this.plugin.settings.noteTypes[index] = newNoteType;
      } else {
        const existingIndex = this.plugin.settings.noteTypes.findIndex((nt) => nt.id === newNoteType.id);
        if (existingIndex >= 0) {
          new import_obsidian2.Notice("\u26A0\uFE0F A note type with this ID already exists");
          return;
        }
        this.plugin.settings.noteTypes.push(newNoteType);
      }
      await this.plugin.saveSettings();
      await this.refreshView();
      modal.close();
      this.display();
      new import_obsidian2.Notice(`\u2705 Note type ${noteType ? "updated" : "added"} successfully`);
    };
    modal.open();
  }
};

// src/view.ts
var import_obsidian5 = require("obsidian");

// src/dataManager.ts
var import_obsidian3 = require("obsidian");
var DataManager = class {
  constructor(entries, settings, app) {
    this.daily = {};
    this.months = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.holidays = {};
    // Cache for expensive calculations
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries = entries;
    this.settings = settings;
    this.app = app;
    this.workdayHours = settings.baseWorkday * settings.workPercent;
    this.workweekHours = settings.baseWorkweek * settings.workPercent;
  }
  async loadHolidays() {
    const status = { success: false, message: "", count: 0, warning: null };
    try {
      const holidayFile = this.app.vault.getAbstractFileByPath(this.settings.holidaysFilePath);
      if (holidayFile && holidayFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.read(holidayFile);
        const lines = content.split("\n");
        lines.forEach((line) => {
          const match = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*(\w+)(?::(half|\d{2}:\d{2}-\d{2}:\d{2})?)?:\s*(.+)$/);
          if (match) {
            const [, date, type, modifier, description] = match;
            const isHalfDay = modifier === "half";
            let startTime;
            let endTime;
            if (modifier && modifier.includes("-") && modifier.includes(":")) {
              const [start, end] = modifier.split("-");
              startTime = start;
              endTime = end;
            }
            this.holidays[date] = {
              type: type.trim().toLowerCase(),
              description: description.trim(),
              halfDay: isHalfDay,
              startTime,
              endTime
            };
          }
        });
        status.success = true;
        status.count = Object.keys(this.holidays).length;
        status.message = `Loaded ${status.count} planned days`;
      } else {
        status.warning = `Holiday file not found: ${this.settings.holidaysFilePath}`;
        console.warn(status.warning);
      }
    } catch (error) {
      status.warning = `Error loading holidays: ${error.message}`;
      console.warn("Could not load future days file:", error);
    }
    return status;
  }
  isHoliday(dateStr) {
    return this.holidays.hasOwnProperty(dateStr);
  }
  getHolidayInfo(dateStr) {
    return this.holidays[dateStr] || null;
  }
  getSpecialDayBehavior(id) {
    const behavior = this.settings.specialDayBehaviors.find((b) => b.id.toLowerCase() === id.toLowerCase());
    if (!behavior) {
      return {
        id,
        label: id,
        icon: "\u2753",
        color: "#cccccc",
        textColor: "#000000",
        noHoursRequired: false,
        flextimeEffect: "accumulate",
        includeInStats: true
      };
    }
    return behavior;
  }
  getDailyGoal(dateStr) {
    if (!this.settings.enableGoalTracking) {
      return 0;
    }
    const date = new Date(dateStr);
    const isWeekend = Utils.isWeekend(date, this.settings);
    if (isWeekend)
      return 0;
    const holidayInfo = this.getHolidayInfo(dateStr);
    if (holidayInfo) {
      const behavior = this.getSpecialDayBehavior(holidayInfo.type);
      if (behavior && behavior.noHoursRequired) {
        return 0;
      }
      if (holidayInfo.halfDay) {
        const halfDayHours = this.settings.halfDayMode === "percentage" ? this.settings.baseWorkday / 2 : this.settings.halfDayHours;
        return halfDayHours;
      }
    }
    if (this.daily[dateStr]) {
      const specialEntry = this.daily[dateStr].find((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return behavior && (behavior.noHoursRequired || behavior.countsAsWorkday);
      });
      if (specialEntry) {
        return 0;
      }
    }
    return this.workdayHours;
  }
  processEntries() {
    this.daily = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.months = {};
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries.forEach((e) => {
      if (!e.startTime)
        return;
      const start = Utils.parseDate(e.startTime);
      if (!start)
        return;
      const dayKey = Utils.toLocalDateStr(start);
      if (!e.endTime) {
        console.log("TimeFlow: Processing active entry:", e.name, "on", dayKey);
        this.activeEntries.push(e);
        if (!this.activeEntriesByDate[dayKey])
          this.activeEntriesByDate[dayKey] = [];
        this.activeEntriesByDate[dayKey].push(e);
        const now = /* @__PURE__ */ new Date();
        let duration2 = Utils.hoursDiff(start, now);
        if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
          const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
          duration2 = Math.max(0, duration2 - lunchBreakHours);
        }
        if (!this.daily[dayKey])
          this.daily[dayKey] = [];
        this.daily[dayKey].push({ ...e, duration: duration2, date: start, isActive: true });
        return;
      }
      const end = Utils.parseDate(e.endTime);
      if (!end)
        return;
      let duration = Utils.hoursDiff(start, end);
      if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
        const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
        duration = Math.max(0, duration - lunchBreakHours);
      }
      if (!this.daily[dayKey])
        this.daily[dayKey] = [];
      this.daily[dayKey].push({ ...e, duration, date: start });
    });
    this.calculateFlextime();
    this.groupByMonths();
  }
  calculateFlextime() {
    if (!this.settings.enableGoalTracking) {
      for (let day in this.daily) {
        this.daily[day].forEach((e) => {
          e.flextime = 0;
        });
      }
      return;
    }
    for (let day in this.daily) {
      const dayGoal = this.getDailyGoal(day);
      const holidayInfo = this.getHolidayInfo(day);
      this.daily[day].forEach((e) => {
        let flextime = 0;
        const name = e.name.toLowerCase();
        if (holidayInfo) {
          const behavior = this.getSpecialDayBehavior(holidayInfo.type);
          if (behavior) {
            if (behavior.flextimeEffect === "withdraw") {
              flextime -= e.duration || 0;
            } else if (behavior.flextimeEffect === "accumulate") {
              if (dayGoal > 0 && (e.duration || 0) > dayGoal) {
                flextime += (e.duration || 0) - dayGoal;
              }
            } else if (behavior.noHoursRequired && dayGoal === 0) {
              flextime += e.duration || 0;
            }
          }
        } else if (dayGoal === 0) {
          flextime += e.duration || 0;
        } else {
          if ((e.duration || 0) > dayGoal) {
            flextime += (e.duration || 0) - dayGoal;
          }
        }
        e.flextime = flextime;
      });
    }
  }
  groupByMonths() {
    for (let day of Object.keys(this.daily)) {
      const date = new Date(day);
      const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
      if (!this.months[monthKey])
        this.months[monthKey] = {};
      const weekNum = Utils.getWeekNumber(date);
      if (!this.months[monthKey][weekNum])
        this.months[monthKey][weekNum] = [];
      this.months[monthKey][weekNum].push(...this.daily[day]);
    }
  }
  getOngoing() {
    const now = /* @__PURE__ */ new Date();
    return this.activeEntries.reduce((sum, e) => {
      const start = Utils.parseDate(e.startTime);
      return start ? sum + Utils.hoursDiff(start, now) : sum;
    }, 0);
  }
  getBalanceUpToDate(endDate) {
    let balance = 0;
    const startDate = this.settings.balanceStartDate;
    const sortedDays = Object.keys(this.daily).filter((day) => day >= startDate && day <= endDate).sort();
    for (const day of sortedDays) {
      const dayGoal = this.getDailyGoal(day);
      const dayEntries = this.daily[day] || [];
      let dayWorked = 0;
      let avspaseringHours = 0;
      let hasCompletedEntries = false;
      dayEntries.forEach((e) => {
        if (e.isActive)
          return;
        hasCompletedEntries = true;
        const behavior = this.getSpecialDayBehavior(e.name);
        if (behavior && (behavior.noHoursRequired || behavior.countsAsWorkday)) {
          return;
        }
        if (e.name.toLowerCase() === "avspasering") {
          avspaseringHours += e.duration || 0;
        } else {
          dayWorked += e.duration || 0;
        }
      });
      if (!hasCompletedEntries)
        continue;
      if (dayGoal === 0) {
        balance += dayWorked;
      } else {
        balance += dayWorked - dayGoal;
      }
      balance -= avspaseringHours;
    }
    return balance;
  }
  getCurrentBalance() {
    const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    return this.getBalanceUpToDate(today);
  }
  getTotalFlextime() {
    return this.getCurrentBalance();
  }
  getCurrentWeekHours(today) {
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    const lastDayOfWeek = new Date(firstDayOfWeek);
    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
    let total = 0;
    for (let d = new Date(firstDayOfWeek); d <= lastDayOfWeek; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        if (entry.isActive)
          return;
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "egenmelding" && name !== "velferdspermisjon" && name !== "ferie") {
          total += entry.duration || 0;
        }
      });
    }
    return total + this.getOngoing();
  }
  getTodayHours(today) {
    const todayKey = Utils.toLocalDateStr(today);
    const todayEntries = this.daily[todayKey] || [];
    return todayEntries.filter((e) => !e.isActive).reduce((sum, e) => sum + (e.duration || 0), 0) + this.getOngoing();
  }
  getAverages() {
    if (this._cachedAverages) {
      return this._cachedAverages;
    }
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const pastKeys = Object.keys(this.daily).filter((d) => d < todayKey);
    const weekdayKeys = pastKeys.filter((dk) => {
      const date = Utils.parseDate(dk);
      return date && !Utils.isWeekend(date, this.settings);
    });
    const workDayKeys = weekdayKeys.filter((dk) => {
      const entries = this.daily[dk];
      return entries.some((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return (behavior == null ? void 0 : behavior.isWorkType) && (e.duration || 0) > 0;
      });
    });
    const totalHoursWorked = workDayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return s + ((behavior == null ? void 0 : behavior.isWorkType) ? e.duration || 0 : 0);
      }, 0),
      0
    );
    const avgDaily = workDayKeys.length > 0 ? totalHoursWorked / workDayKeys.length : 0;
    const weeksWorked = this.settings.workdaysPerWeek > 0 ? workDayKeys.length / this.settings.workdaysPerWeek : 0;
    const avgWeekly = weeksWorked > 0 ? totalHoursWorked / weeksWorked : 0;
    this._cachedAverages = {
      avgDaily,
      avgWeekly,
      totalDaysWorked: workDayKeys.length,
      totalHoursWorked
    };
    return this._cachedAverages;
  }
  getStatistics(timeframe = "total", year, month) {
    var _a, _b;
    const today = /* @__PURE__ */ new Date();
    let filterFn;
    if (timeframe === "year") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      filterFn = (dateStr) => new Date(dateStr).getFullYear() === targetYear;
    } else if (timeframe === "month") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      const targetMonth = month !== void 0 ? month : today.getMonth();
      filterFn = (dateStr) => {
        const d = new Date(dateStr);
        return d.getFullYear() === targetYear && d.getMonth() === targetMonth;
      };
    } else {
      filterFn = () => true;
    }
    const filteredDays = Object.keys(this.daily).filter(filterFn);
    const allEntries = filteredDays.flatMap((day) => this.daily[day]);
    const stats = {
      totalHours: allEntries.reduce((sum, e) => sum + (e.duration || 0), 0),
      totalFlextime: allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0),
      jobb: { count: 0, hours: 0 },
      avspasering: { count: 0, hours: 0, planned: 0 },
      ferie: { count: 0, hours: 0, max: ((_a = this.getSpecialDayBehavior("ferie")) == null ? void 0 : _a.maxDaysPerYear) || this.settings.maxFerieDays, planned: 0 },
      velferdspermisjon: { count: 0, hours: 0, planned: 0 },
      egenmelding: { count: 0, hours: 0, max: ((_b = this.getSpecialDayBehavior("egenmelding")) == null ? void 0 : _b.maxDaysPerYear) || this.settings.maxEgenmeldingDays },
      sykemelding: { count: 0, hours: 0 },
      studie: { count: 0, hours: 0, planned: 0 },
      kurs: { count: 0, hours: 0, planned: 0 },
      workDays: 0,
      weekendDays: 0,
      weekendHours: 0,
      avgDailyHours: 0,
      workloadPercent: 0
    };
    const daysByType = {
      jobb: /* @__PURE__ */ new Set(),
      avspasering: /* @__PURE__ */ new Set(),
      ferie: /* @__PURE__ */ new Set(),
      velferdspermisjon: /* @__PURE__ */ new Set(),
      egenmelding: /* @__PURE__ */ new Set(),
      sykemelding: /* @__PURE__ */ new Set(),
      studie: /* @__PURE__ */ new Set(),
      kurs: /* @__PURE__ */ new Set()
    };
    const uniqueDays = /* @__PURE__ */ new Set();
    const weekendDaysSet = /* @__PURE__ */ new Set();
    const workDaysSet = /* @__PURE__ */ new Set();
    filteredDays.forEach((dayKey) => {
      const dayDate = new Date(dayKey);
      const dayEntries = this.daily[dayKey];
      uniqueDays.add(dayKey);
      dayEntries.forEach((e) => {
        const name = e.name.toLowerCase();
        if (e.date && Utils.isWeekend(e.date, this.settings)) {
          weekendDaysSet.add(dayKey);
          stats.weekendHours += e.duration || 0;
        } else {
          workDaysSet.add(dayKey);
        }
        if (name === "jobb" || !["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType.jobb.add(dayKey);
          stats.jobb.hours += e.duration || 0;
        } else if (["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType[name].add(dayKey);
          stats[name].hours += e.duration || 0;
        }
      });
    });
    stats.weekendDays = weekendDaysSet.size;
    stats.workDays = workDaysSet.size;
    stats.jobb.count = daysByType.jobb.size;
    stats.avspasering.count = daysByType.avspasering.size;
    stats.ferie.count = daysByType.ferie.size;
    stats.velferdspermisjon.count = daysByType.velferdspermisjon.size;
    stats.egenmelding.count = daysByType.egenmelding.size;
    stats.studie.count = daysByType.studie.size;
    stats.kurs.count = daysByType.kurs.size;
    Object.keys(this.holidays).forEach((dateStr) => {
      const plannedInfo = this.holidays[dateStr];
      const plannedDate = new Date(dateStr);
      if (filterFn(dateStr) && plannedDate > today) {
        const type = plannedInfo.type;
        if (type === "ferie" && stats.ferie) {
          stats.ferie.planned++;
        } else if (type === "avspasering" && stats.avspasering) {
          stats.avspasering.planned++;
        } else if (type === "velferdspermisjon" && stats.velferdspermisjon) {
          stats.velferdspermisjon.planned++;
        } else if (type === "studie" && stats.studie) {
          stats.studie.planned++;
        } else if (type === "kurs" && stats.kurs) {
          stats.kurs.planned++;
        }
      }
    });
    stats.avgDailyHours = uniqueDays.size > 0 ? stats.totalHours / uniqueDays.size : 0;
    if (timeframe === "year" || timeframe === "month") {
      const expectedWorkdays = timeframe === "year" ? this.settings.workdaysPerYear : this.settings.workdaysPerMonth;
      let noHoursRequiredDays = 0;
      filteredDays.forEach((dayKey) => {
        const holidayInfo = this.getHolidayInfo(dayKey);
        if (holidayInfo) {
          const behavior = this.getSpecialDayBehavior(holidayInfo.type);
          if (behavior == null ? void 0 : behavior.noHoursRequired) {
            noHoursRequiredDays++;
          }
        }
      });
      const adjustedWorkdays = Math.max(0, expectedWorkdays - noHoursRequiredDays);
      const expectedHours = adjustedWorkdays * this.workdayHours;
      stats.workloadPercent = expectedHours > 0 ? stats.totalHours / expectedHours * 100 : 0;
    }
    return stats;
  }
  getAvailableYears() {
    const years = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const year = new Date(dateStr).getFullYear();
      years.add(year);
    });
    return Array.from(years).sort((a, b) => b - a);
  }
  getAvailableMonthsForYear(year) {
    const months = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const date = new Date(dateStr);
      if (date.getFullYear() === year) {
        months.add(date.getMonth());
      }
    });
    return Array.from(months).sort((a, b) => a - b);
  }
  getContextualData(today) {
    const todayKey = Utils.toLocalDateStr(today);
    if (this._cachedContextData[todayKey]) {
      return this._cachedContextData[todayKey];
    }
    const weekday = today.getDay();
    let consecutiveFlextimeDays = 0;
    const sortedDays = Object.keys(this.daily).sort().reverse();
    for (let day of sortedDays) {
      if (day >= todayKey)
        continue;
      const dayFlextime = this.daily[day].reduce(
        (sum, e) => sum + (e.flextime || 0),
        0
      );
      if (dayFlextime > 0) {
        consecutiveFlextimeDays++;
      } else {
        break;
      }
    }
    const sameWeekdayKeys = Object.keys(this.daily).filter((d) => {
      const date = new Date(d);
      return date.getDay() === weekday && d < todayKey;
    });
    const sameDayTotal = sameWeekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const sameDayAvg = sameWeekdayKeys.length > 0 ? sameDayTotal / sameWeekdayKeys.length : 0;
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const thisWeekMonday = new Date(today);
    thisWeekMonday.setDate(today.getDate() - daysFromMonday);
    const lastWeekStart = new Date(thisWeekMonday);
    lastWeekStart.setDate(thisWeekMonday.getDate() - 7);
    const lastWeekEnd = new Date(lastWeekStart);
    lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
    let lastWeekHours = 0;
    for (let d = new Date(lastWeekStart); d <= lastWeekEnd; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      lastWeekHours += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
    }
    const result = { consecutiveFlextimeDays, sameDayAvg, lastWeekHours };
    this._cachedContextData[todayKey] = result;
    return result;
  }
  getWeekTotals(numWeeks = 8) {
    const today = /* @__PURE__ */ new Date();
    const weekTotals = [];
    for (let i = numWeeks - 1; i >= 0; i--) {
      const d = new Date(today);
      d.setDate(today.getDate() - i * 7);
      const dayOfWeek = d.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const weekStart = new Date(d);
      weekStart.setDate(d.getDate() - daysFromMonday);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      let weekSum = 0;
      for (let wd = new Date(weekStart); wd <= weekEnd; wd = new Date(wd.getFullYear(), wd.getMonth(), wd.getDate() + 1)) {
        const dayKey = Utils.toLocalDateStr(wd);
        const dayEntries = this.daily[dayKey] || [];
        weekSum += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
      }
      weekTotals.push(weekSum);
    }
    return weekTotals;
  }
  validateData() {
    const issues = {
      errors: [],
      warnings: [],
      info: [],
      stats: {
        totalEntries: 0,
        entriesChecked: 0,
        entriesWithIssues: 0
      }
    };
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const createIssue = (severity, type, description, entry, dayKey) => {
      issues.stats.entriesWithIssues++;
      return {
        severity,
        type,
        description,
        date: dayKey,
        entry: {
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          duration: entry.duration
        }
      };
    };
    for (const dayKey in this.daily) {
      const dayEntries = this.daily[dayKey];
      issues.stats.totalEntries += dayEntries.length;
      dayEntries.forEach((entry) => {
        var _a, _b, _c;
        issues.stats.entriesChecked++;
        if (!entry.name || entry.name.trim() === "") {
          issues.errors.push(createIssue(
            "error",
            "Missing Entry Name",
            "Entry has no name/type",
            entry,
            dayKey
          ));
        }
        if (!entry.startTime) {
          issues.errors.push(createIssue(
            "error",
            "Missing Start Time",
            "Entry has no start time",
            entry,
            dayKey
          ));
          return;
        }
        if ((entry.duration || 0) < 0) {
          issues.errors.push(createIssue(
            "error",
            "Negative Duration",
            `End time is before start time (${(_a = entry.duration) == null ? void 0 : _a.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.maxDurationHours) {
          issues.errors.push(createIssue(
            "error",
            "Excessive Duration",
            `Entry spans more than ${this.settings.validationThresholds.maxDurationHours} hours (${(_b = entry.duration) == null ? void 0 : _b.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.veryLongSessionHours && (entry.duration || 0) <= this.settings.validationThresholds.maxDurationHours) {
          issues.warnings.push(createIssue(
            "warning",
            "Very Long Session",
            `Entry duration exceeds ${this.settings.validationThresholds.veryLongSessionHours} hours (${(_c = entry.duration) == null ? void 0 : _c.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) === 0) {
          issues.info.push(createIssue(
            "info",
            "Zero Duration",
            "Entry has zero duration",
            entry,
            dayKey
          ));
        }
        if (dayKey > todayStr) {
          issues.info.push(createIssue(
            "info",
            "Future Date",
            "Entry is dated in the future",
            entry,
            dayKey
          ));
        }
      });
      if (dayEntries.length > 1) {
        const sortedEntries = [...dayEntries].filter((e) => e.startTime && e.endTime).sort((a, b) => {
          const aStart = new Date(a.startTime);
          const bStart = new Date(b.startTime);
          return aStart.getTime() - bStart.getTime();
        });
        for (let i = 0; i < sortedEntries.length - 1; i++) {
          const current = sortedEntries[i];
          const next = sortedEntries[i + 1];
          if (current.startTime && current.endTime && next.startTime && next.endTime) {
            const currentEnd = new Date(current.endTime);
            const nextStart = new Date(next.startTime);
            if (currentEnd > nextStart) {
              const overlapMinutes = Math.round((currentEnd.getTime() - nextStart.getTime()) / 6e4);
              issues.errors.push({
                severity: "error",
                type: "Overlapping Entries",
                description: `Entries overlap by ${overlapMinutes} minutes`,
                date: dayKey,
                entry: {
                  name: `${current.name} \u2192 ${next.name}`,
                  startTime: current.startTime,
                  endTime: next.endTime
                }
              });
              issues.stats.entriesWithIssues++;
            }
          }
        }
      }
    }
    const allDates = Object.keys(this.daily).sort();
    if (allDates.length > 0) {
      const firstDate = new Date(allDates[0]);
      const lastDate = today;
      for (let d = new Date(firstDate); d <= lastDate; d.setDate(d.getDate() + 1)) {
        const dateStr = Utils.toLocalDateStr(d);
        const isWeekend = Utils.isWeekend(d, this.settings);
        const holidayInfo = this.getHolidayInfo(dateStr);
        const hasEntries = this.daily[dateStr] && this.daily[dateStr].length > 0;
        if (isWeekend)
          continue;
        if (holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type)) {
          continue;
        }
        if (dateStr >= todayStr)
          continue;
        if (!hasEntries) {
          issues.warnings.push({
            severity: "warning",
            type: "Missing Entry",
            description: "No work entries registered for this workday",
            date: dateStr
          });
        }
      }
    }
    issues.stats.totalEntries += this.activeEntries.length;
    this.activeEntries.forEach((entry) => {
      issues.stats.entriesChecked++;
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        const now = /* @__PURE__ */ new Date();
        const hoursRunning = Utils.hoursDiff(startTime, now);
        if (hoursRunning > this.settings.validationThresholds.longRunningTimerHours) {
          issues.warnings.push({
            severity: "warning",
            type: "Long-Running Timer",
            description: `Active timer has been running for ${hoursRunning.toFixed(1)} hours (threshold: ${this.settings.validationThresholds.longRunningTimerHours}h)`,
            date: Utils.toLocalDateStr(startTime),
            entry: {
              name: entry.name,
              startTime: entry.startTime,
              duration: hoursRunning
            }
          });
          issues.stats.entriesWithIssues++;
        }
      }
    });
    const currentWeekHours = this.getCurrentWeekHours(today);
    if (currentWeekHours > this.settings.validationThresholds.highWeeklyTotalHours) {
      issues.info.push({
        severity: "info",
        type: "High Weekly Total",
        description: `Current week total exceeds ${this.settings.validationThresholds.highWeeklyTotalHours} hours (${currentWeekHours.toFixed(1)}h)`,
        date: todayStr
      });
    }
    return {
      hasErrors: issues.errors.length > 0,
      hasWarnings: issues.warnings.length > 0,
      hasInfo: issues.info.length > 0,
      issues,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Check if there's a rest period violation for a given date
   * A violation occurs when the gap between the last work session ending on the previous day
   * and the first work session starting on the given day is less than the minimum rest hours
   */
  checkRestPeriodViolation(dateStr) {
    var _a, _b;
    const minimumRestHours = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11;
    const currentDate = new Date(dateStr);
    const previousDate = new Date(currentDate);
    previousDate.setDate(previousDate.getDate() - 1);
    const previousDayKey = Utils.toLocalDateStr(previousDate);
    const previousDayEntries = this.daily[previousDayKey] || [];
    const currentDayEntries = this.daily[dateStr] || [];
    if (previousDayEntries.length === 0 || currentDayEntries.length === 0) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    let lastEndTimeMs = 0;
    let lastEndTimeStr = "";
    previousDayEntries.forEach((entry) => {
      if (entry.endTime) {
        const endTime = new Date(entry.endTime);
        if (endTime.getTime() > lastEndTimeMs) {
          lastEndTimeMs = endTime.getTime();
          lastEndTimeStr = endTime.toISOString();
        }
      }
    });
    let firstStartTimeMs = Infinity;
    let firstStartTimeStr = "";
    currentDayEntries.forEach((entry) => {
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        if (startTime.getTime() < firstStartTimeMs) {
          firstStartTimeMs = startTime.getTime();
          firstStartTimeStr = startTime.toISOString();
        }
      }
    });
    if (lastEndTimeMs === 0 || firstStartTimeMs === Infinity) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    const restHours = (firstStartTimeMs - lastEndTimeMs) / (1e3 * 60 * 60);
    const violated = restHours < minimumRestHours;
    return {
      violated,
      restHours,
      previousDayEnd: lastEndTimeStr,
      currentDayStart: firstStartTimeStr
    };
  }
  /**
   * Get statistics for a special day type, respecting the counting period setting
   * For historical years, always use calendar year counting
   * For current year, respect the countingPeriod setting
   */
  getSpecialDayStats(typeId, year) {
    const behavior = this.getSpecialDayBehavior(typeId);
    const today = /* @__PURE__ */ new Date();
    const currentYear = today.getFullYear();
    const targetYear = year != null ? year : currentYear;
    const isCurrentYear = targetYear === currentYear;
    const countingPeriod = (behavior == null ? void 0 : behavior.countingPeriod) || "calendar";
    const useRolling = isCurrentYear && countingPeriod === "rolling365";
    let count = 0;
    const daysSeen = /* @__PURE__ */ new Set();
    if (useRolling) {
      const cutoffDate = new Date(today);
      cutoffDate.setDate(cutoffDate.getDate() - 365);
      const cutoffStr = Utils.toLocalDateStr(cutoffDate);
      Object.keys(this.daily).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    } else {
      Object.keys(this.daily).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    }
    return {
      count,
      max: behavior == null ? void 0 : behavior.maxDaysPerYear,
      isRolling: useRolling,
      periodLabel: useRolling ? "365d" : targetYear.toString()
    };
  }
};

// src/uiBuilder.ts
var import_obsidian4 = require("obsidian");
var UIBuilder = class {
  constructor(dataManager, systemStatus, settings, app, timerManager, plugin) {
    this.intervals = [];
    this.statsTimeframe = "total";
    this.historyView = "list";
    this.currentMonthOffset = 0;
    this.historyFilter = [];
    // empty = all, or list of type IDs to filter by
    this.inlineEditMode = false;
    // toggle for inline editing in wide view
    this.isModalOpen = false;
    this.data = dataManager;
    this.systemStatus = systemStatus;
    this.settings = settings;
    this.app = app;
    this.timerManager = timerManager;
    this.plugin = plugin;
    this.container = this.createContainer();
    this.today = /* @__PURE__ */ new Date();
    this.selectedYear = this.today.getFullYear();
    this.selectedMonth = this.today.getMonth();
    this.elements = {
      badge: null,
      complianceBadge: null,
      timerBadge: null,
      clock: null,
      dayCard: null,
      weekCard: null,
      statsCard: null,
      monthCard: null
    };
  }
  getBalanceColor(balance) {
    const t2 = this.settings.balanceThresholds;
    const colors = this.settings.customColors;
    if (balance < t2.criticalLow || balance > t2.criticalHigh)
      return (colors == null ? void 0 : colors.balanceCritical) || "#f44336";
    if (balance < t2.warningLow || balance > t2.warningHigh)
      return (colors == null ? void 0 : colors.balanceWarning) || "#ff9800";
    return (colors == null ? void 0 : colors.balanceOk) || "#4caf50";
  }
  darkenColor(color, percent) {
    const hex = color.replace("#", "");
    const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - percent);
    const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - percent);
    const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - percent);
    return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
  }
  /**
   * Validate time input and parse hours/minutes.
   * Returns null if invalid, otherwise returns { hours, minutes }.
   */
  parseTimeInput(value) {
    if (!value || !value.includes(":"))
      return null;
    const parts = value.split(":");
    if (parts.length !== 2)
      return null;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    if (isNaN(hours) || isNaN(minutes))
      return null;
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59)
      return null;
    return { hours, minutes };
  }
  /**
   * Create a text-based time input with validation (HH:MM format).
   * Uses a regular text input instead of type="time" to avoid clock pickers on mobile.
   */
  createTimeInput(initialValue, onChange) {
    const input = document.createElement("input");
    input.type = "text";
    input.value = initialValue;
    input.placeholder = "HH:MM";
    input.maxLength = 5;
    input.pattern = "[0-2][0-9]:[0-5][0-9]";
    input.inputMode = "numeric";
    input.classList.add("tf-time-input");
    let lastValidValue = initialValue;
    input.oninput = () => {
      let val = input.value.replace(/[^0-9]/g, "");
      if (val.length >= 3) {
        val = val.slice(0, 2) + ":" + val.slice(2, 4);
      }
      if (val.length > 5)
        val = val.slice(0, 5);
      input.value = val;
    };
    input.onblur = () => {
      if (!input.value) {
        input.value = lastValidValue;
        return;
      }
      const parsed = this.parseTimeInput(input.value);
      if (parsed) {
        const formatted = `${parsed.hours.toString().padStart(2, "0")}:${parsed.minutes.toString().padStart(2, "0")}`;
        input.value = formatted;
        lastValidValue = formatted;
        onChange(formatted);
      } else {
        new import_obsidian4.Notice(t("validation.invalidTime"));
        input.value = lastValidValue;
      }
    };
    input.onkeydown = (e) => {
      if (e.key === "Enter") {
        input.blur();
      }
    };
    return input;
  }
  /**
   * Wrapper for timerManager.save() with error handling.
   * Shows a notice on failure and returns false.
   */
  async saveWithErrorHandling() {
    try {
      await this.timerManager.save();
      return true;
    } catch (error) {
      console.error("TimeFlow: Error saving data:", error);
      new import_obsidian4.Notice(t("notifications.saveError"));
      return false;
    }
  }
  createContainer() {
    const container = document.createElement("div");
    container.style.fontFamily = "sans-serif";
    container.style.maxWidth = "1200px";
    container.style.margin = "0 auto";
    container.style.padding = "20px";
    container.style.boxSizing = "border-box";
    return container;
  }
  injectStyles() {
    const styleId = "timeflow-styles";
    if (document.getElementById(styleId))
      return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
			/* timeflow Dashboard Styles */
			.timeflow-dashboard {
				font-family: var(--font-text);
				padding: 20px;
				width: 100%;
			}

			.timeflow-error, .timeflow-warning {
				padding: 15px;
				border-radius: 5px;
				margin: 10px 0;
			}

			.timeflow-error {
				background: var(--background-modifier-error);
				color: var(--text-error);
			}

			.timeflow-warning {
				background: var(--background-modifier-warning);
				color: var(--text-warning);
			}

			/* Pulse animation for active entry indicator */
			@keyframes pulse {
				0%, 100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.6;
					transform: scale(1.1);
				}
			}

			.tf-badge-section {
				display: flex;
				align-items: stretch;
				gap: 12px;
				margin: 16px 0;
				flex-wrap: wrap;
			}

			/* Default flex behavior for all badges */
			.tf-compliance-badge {
				flex: 0 0 auto;
				margin-left: auto;
			}
			.tf-timer-badge {
				flex: 0 1 auto;
			}

			/* At narrower widths: badges split into 2 rows */
			@container dashboard (max-width: 650px) {
				/* Row 1: Timesaldo (50%) and Clock (50%) */
				.tf-badge {
					flex: 1 1 calc(50% - 6px);
				}
				.tf-clock {
					flex: 1 1 calc(50% - 6px);
				}

				/* Row 2: Compliance badge and timer button move down together */
				.tf-compliance-badge {
					margin-left: 0;
					flex: 0 0 auto;
				}
				.tf-timer-badge {
					flex: 1 1 0;
				}
			}

			.tf-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			/* Light theme - Clock badge uses the same gradient as other light elements */
			.tf-clock {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				background: var(--background-primary-alt);
				color: var(--text-normal);
				font-weight: bold;
				font-variant-numeric: tabular-nums;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				border: 1px solid var(--background-modifier-border);
			}

			.tf-timer-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
				white-space: normal;
				text-align: center;
				min-height: 44px;
				min-width: 0;
				cursor: pointer;
				transition: all 0.2s;
				border: none;
				font-family: inherit;
				font-size: inherit;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				/* Background colors are set dynamically based on timer state */
			}

			.tf-timer-badge:hover {
				transform: translateY(-1px);
				box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			}

			.tf-timer-badge:active {
				transform: translateY(0);
			}

			/* Child elements inside timer badge should fill space */
			.tf-timer-badge > div:first-child {
				flex: 1;
			}

			.tf-compliance-badge {
				padding: 10px 14px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				min-height: 44px;
				font-weight: bold;
				font-size: inherit;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				cursor: pointer;
			}

			/* Enable container queries on the dashboard container */
			.timeflow-dashboard {
				container-type: inline-size;
				container-name: dashboard;
			}

			/* Main cards container - wraps summary cards AND stats card for responsive layout */
			.tf-main-cards-wrapper {
				display: grid;
				gap: 15px;
				margin-bottom: 20px;
				width: 100%;
				box-sizing: border-box;
			}

			/* Mobile default: everything stacked */
			.tf-main-cards-wrapper {
				grid-template-columns: 1fr;
			}
			.tf-card-day { grid-column: 1; grid-row: 1; }
			.tf-card-week { grid-column: 1; grid-row: 2; }
			.tf-card-month { grid-column: 1; grid-row: 3; }
			.tf-card-stats { grid-column: 1; grid-row: 4; }

			/* Reduce gap and padding on very narrow containers */
			@container dashboard (max-width: 500px) {
				.tf-main-cards-wrapper { gap: 12px; }
				.tf-card { padding: 16px; }
			}

			/* Reduce side padding on mobile */
			@container dashboard (max-width: 400px) {
				.timeflow-dashboard {
					padding: 12px 8px;
				}
				.tf-card {
					padding: 12px;
				}
				.tf-badge-section {
					gap: 8px;
					margin: 12px 0;
				}
				.tf-badge, .tf-clock, .tf-timer-badge {
					padding: 8px 12px;
					min-height: 40px;
				}
			}

			/* Medium width: Day/Week side by side, Month and Stats stacked full width */
			@container dashboard (min-width: 400px) {
				.tf-main-cards-wrapper {
					grid-template-columns: repeat(2, minmax(0, 1fr));
				}
				.tf-card-day { grid-column: 1; grid-row: 1; }
				.tf-card-week { grid-column: 2; grid-row: 1; }
				.tf-card-month { grid-column: 1 / -1; grid-row: 2; }
				.tf-card-stats { grid-column: 1 / -1; grid-row: 3; }
			}

			/* Wide layout: 2x2 grid - Day/Week top, Month/Stats side by side bottom */
			@container dashboard (min-width: 750px) {
				.tf-card-month { grid-column: 1; grid-row: 2; }
				.tf-card-stats { grid-column: 2; grid-row: 2; }
			}

			/* Default card styling - used for month card */
			.tf-card {
				padding: 20px;
				border-radius: 12px;
				background: var(--background-primary-alt);
				color: var(--text-normal);
				box-shadow: 0 4px 12px rgba(0,0,0,0.15);
				box-sizing: border-box;
				min-width: 0;
				overflow: hidden;
				border: 1px solid var(--background-modifier-border);
			}

			.tf-card-spaced {
				margin-top: 24px;
			}

			.tf-card h3 {
				margin-top: 0;
				margin-bottom: 15px;
				font-size: 18px;
				color: var(--text-normal);
			}

			/* Daily and Weekly cards use dynamic backgrounds set in updateDayCard/updateWeekCard */
			.tf-card-day,
			.tf-card-week {
				/* Background and color set dynamically based on progress */
				position: relative;
			}

			/* Stats and history cards */
			.tf-card-stats,
			.tf-card-history {
				background: var(--background-primary-alt);
				color: var(--text-normal);
			}

			.tf-card-stats h3,
			.tf-card-history h3 {
				color: var(--text-normal);
			}

			.tf-stat-item {
				background: var(--background-secondary);
				color: var(--text-normal);
			}

			.tf-stat-label,
			.tf-stat-value {
				color: var(--text-normal);
			}

			.tf-stat-item div,
			.tf-stat-item .tf-stat-label {
				color: var(--text-normal);
			}

			.tf-card-stats .tf-stat-label {
				color: var(--text-normal);
			}

			/* Colored stat items should always have white text */
			.tf-stat-colored,
			.tf-stat-colored div,
			.tf-stat-colored .tf-stat-label,
			.tf-stat-colored .tf-stat-value {
				color: white !important;
			}

			/* Progress bar */
			.tf-progress-bar {
				width: 100%;
				height: 12px;
				background: var(--background-secondary);
				border-radius: 6px;
				overflow: hidden;
				margin: 10px 0;
			}

			/* Light theme - Progress fill uses green gradient from timeflow.js */
			.tf-progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #4caf50, #2e7d32);
				transition: width 0.3s ease;
			}

			.tf-month-grid {
				display: grid;
				grid-template-columns: repeat(7, minmax(0, 1fr));
				gap: 12px;
				margin-top: 15px;
				width: 100%;
				box-sizing: border-box;
				min-width: 0;
			}

			/* Week number column in calendar */
			.tf-month-grid.with-week-numbers {
				grid-template-columns: clamp(16px, 5cqw, 28px) repeat(7, minmax(0, 1fr));
			}

			.tf-week-number-cell {
				font-size: clamp(9px, 2cqw, 11px);
				color: var(--text-normal);
				display: flex;
				align-items: center;
				justify-content: center;
				min-width: 0;
				border-radius: 4px;
				font-weight: 500;
			}

			/* Week compliance colors */
			.tf-week-number-cell.week-ok {
				background: linear-gradient(135deg, #c8e6c9, #a5d6a7);
				color: #ffffff;
			}
			.tf-week-number-cell.week-over {
				background: linear-gradient(135deg, #ffe0b2, #ffcc80);
				color: #000000;
			}
			.tf-week-number-cell.week-under {
				background: linear-gradient(135deg, #ffcdd2, #ef9a9a);
				color: #ffffff;
			}
			.tf-week-number-cell.week-partial {
				background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
				color: #000000;
			}
			.tf-week-number-cell.week-future {
				background: transparent;
				color: var(--text-muted);
				opacity: 0.5;
			}

			.tf-week-number-header {
				font-size: clamp(8px, 2cqw, 10px);
				color: var(--text-muted);
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: bold;
				min-width: 0;
			}

			/* Week number badge in week card */
			.tf-week-badge {
				position: absolute;
				top: 12px;
				right: 12px;
				font-size: 12px;
				padding: 2px 8px;
				border-radius: 10px;
				background: rgba(255, 255, 255, 0.2);
				color: inherit;
				font-weight: normal;
			}

			/* Reduce gap linearly on narrow containers (below 450px) */
			@container dashboard (max-width: 450px) {
				.tf-month-grid {
					gap: clamp(2px, 2cqw, 8px);
				}
				.tf-week-badge {
					font-size: 10px;
					padding: 2px 8px;
					top: 12px;
					right: 12px;
				}
			}

			/* Day cells - consistent text colors across all themes since backgrounds are always the same */
			.tf-day-cell {
				aspect-ratio: 1;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 6px;
				font-size: clamp(10px, 2.5vw, 16px);
				font-weight: bold;
				cursor: pointer;
				transition: all 0.2s;
				position: relative;
				border: 2px solid transparent;
				text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
				min-width: 0;
				overflow: hidden;
			}

			/* Days with entries - text color set dynamically based on special day */
			.tf-day-cell.has-entry {
				color: var(--text-normal);
			}

			/* Days without entries */
			.tf-day-cell.no-entry {
				color: var(--text-muted);
			}

			.tf-day-cell:hover {
				transform: scale(1.05);
				box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			}

			.tf-day-cell.today {
				border-color: var(--interactive-accent);
				font-weight: bold;
			}

			.tf-stats-grid {
				display: grid;
				grid-template-columns: 1fr;
				gap: 15px;
				margin-top: 15px;
			}

			/* Stats grid 2 columns at same breakpoint as day/week cards */
			@container dashboard (min-width: 400px) {
				.tf-stats-grid {
					grid-template-columns: repeat(2, 1fr);
				}
			}

			/* Future planned days list - only shown in wide layout */
			.tf-future-days-list {
				display: none;
			}

			@container dashboard (min-width: 750px) {
				.tf-future-days-list {
					display: block;
					margin-top: 20px;
					padding-top: 15px;
					border-top: 1px solid var(--background-modifier-border);
				}

				.tf-future-days-list h4 {
					margin: 0 0 10px 0;
					font-size: 14px;
					font-weight: 600;
					opacity: 0.8;
				}

				.tf-future-day-item {
					display: flex;
					justify-content: space-between;
					align-items: center;
					padding: 6px 0;
					font-size: 13px;
					border-bottom: 1px solid var(--background-modifier-border);
				}

				.tf-future-day-item:last-child {
					border-bottom: none;
				}

				.tf-future-day-date {
					font-weight: 500;
				}

				.tf-future-day-type {
					padding: 2px 8px;
					border-radius: 4px;
					font-size: 12px;
					color: white;
				}
			}

			/* Stat items */
			.tf-stat-item {
				padding: 15px;
				background: var(--background-secondary);
				border-radius: 8px;
				color: var(--text-normal);
			}

			.tf-stat-label {
				font-size: 12px;
				margin-bottom: 5px;
				color: var(--text-muted);
			}

			.tf-stat-value {
				font-size: 20px;
				font-weight: bold;
				color: var(--text-normal);
			}

			/* Timeframe label styling */
			.tf-timeframe-label {
				color: var(--text-normal);
			}

			.tf-tabs {
				display: flex;
				gap: 8px;
				margin-bottom: 15px;
				border-bottom: 2px solid var(--background-modifier-border);
			}

			.tf-tab {
				padding: 6px 12px;
				cursor: pointer;
				border: none;
				background: var(--background-secondary);
				color: var(--text-normal);
				font-size: 0.9em;
				border-radius: 6px;
				transition: all 0.2s;
				font-weight: 500;
			}

			.tf-tab.active {
				background: var(--interactive-accent);
				color: var(--text-on-accent);
				font-weight: bold;
			}

			.tf-tab:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal);
			}

			.tf-button {
				padding: clamp(3px, 1.5cqw, 8px) clamp(6px, 3cqw, 16px);
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--interactive-normal);
				color: var(--text-normal);
				cursor: pointer;
				font-size: clamp(10px, 3cqw, 14px);
				transition: all 0.2s;
				white-space: nowrap;
				min-width: 0;
				flex-shrink: 1;
			}

			.tf-button:hover {
				background: var(--interactive-hover);
			}

			/* Make buttons smaller on mobile */
			@media (max-width: 500px) {
				.tf-button {
					padding: 4px 8px;
					font-size: 11px;
					min-width: unset;
				}
			}

			.tf-heatmap {
				display: grid;
				gap: 2px;
				margin-top: 15px;
				padding-right: 1px;
			}

			.tf-heatmap-cell {
				width: 100%;
				aspect-ratio: 1;
				border-radius: 4px;
				cursor: pointer;
				transition: opacity 0.2s, box-shadow 0.2s;
			}

			.tf-heatmap-cell:hover {
				opacity: 0.8;
				box-shadow: inset 0 0 0 2px var(--text-accent);
			}

			/* Make heatmap cells larger on mobile */
			@media (max-width: 600px) {
				.tf-heatmap {
					grid-template-columns: repeat(20, 1fr) !important;
				}
			}

			/* Context menu - uses same styling as submenu for consistency */
			/* Context menu - uses Obsidian native styling for all themes */
			.tf-context-menu {
				position: fixed;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				z-index: 1000;
				min-width: 200px;
				max-width: calc(100vw - 20px);
				display: flex;
				gap: 0;
				box-sizing: border-box;
			}

			.tf-context-menu-main {
				flex: 0 0 auto;
				min-width: 200px;
				box-sizing: border-box;
			}

			.tf-context-menu-info {
				flex: 0 0 auto;
				width: 250px;
				padding: 12px;
				border-left: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				font-size: 0.85em;
				line-height: 1.4;
				box-sizing: border-box;
			}

			/* On mobile, stack menu vertically and make it full width */
			@media (max-width: 500px) {
				.tf-context-menu {
					flex-direction: column;
					width: calc(100vw - 20px);
					max-height: calc(100vh - 40px);
					overflow-y: auto;
				}

				.tf-context-menu-main {
					width: 100%;
				}

				.tf-context-menu-info {
					width: 100%;
					border-left: none;
					border-top: 1px solid var(--background-modifier-border);
				}
			}

			.tf-context-menu-info h4 {
				margin: 0 0 8px 0;
				font-size: 0.95em;
				color: var(--text-normal);
			}

			.tf-context-menu-info p {
				margin: 4px 0;
				color: var(--text-muted);
			}

			.tf-context-menu-info strong {
				color: var(--text-normal);
			}

			/* Compliance info panel */
			.tf-compliance-info-panel {
				position: fixed;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 12px 16px;
				z-index: 1000;
				min-width: 220px;
				max-width: 300px;
			}

			.tf-compliance-info-panel h4 {
				margin: 0 0 10px 0;
				font-size: 0.95em;
				color: var(--text-normal);
			}

			.tf-compliance-info-panel p {
				margin: 6px 0;
				color: var(--text-muted);
				font-size: 0.9em;
			}

			.tf-compliance-info-panel strong {
				color: var(--text-normal);
			}

			.tf-menu-item {
				padding: 8px 16px;
				cursor: pointer;
				transition: background 0.2s;
				display: flex;
				align-items: center;
				gap: 10px;
				color: var(--text-normal);
			}

			.tf-menu-item:hover {
				background: var(--background-modifier-hover);
			}

			.tf-menu-separator {
				height: 1px;
				background: var(--background-modifier-border);
				margin: 4px 0;
			}

			/* Submenu styles */
			.tf-menu-item-with-submenu {
				position: relative;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.tf-submenu {
				display: none;
				position: absolute;
				left: 100%;
				top: 0;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				min-width: 180px;
				z-index: 1001;
			}

			.tf-menu-item-with-submenu:hover .tf-submenu {
				display: block;
			}

			.tf-submenu-arrow {
				font-size: 0.8em;
				opacity: 0.7;
			}

			.tf-status-bar {
				margin-top: 20px;
				padding: 15px;
				background: var(--background-secondary-alt);
				border-radius: 6px;
				border-left: 4px solid var(--interactive-accent);
			}

			.tf-collapsible {
				cursor: pointer;
				user-select: none;
			}

			.tf-collapsible-content {
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.3s ease;
			}

			.tf-collapsible-content.open {
				max-height: none;
				overflow: visible;
			}

			/* Info section two-column grid */
			.tf-info-grid {
				display: grid;
				grid-template-columns: 1fr;
				gap: 20px;
				margin-top: 15px;
			}

			.tf-info-column {
				display: flex;
				flex-direction: column;
				gap: 15px;
			}

			.tf-info-box {
				padding: 12px;
				background: var(--background-primary);
				border-radius: 8px;
			}

			.tf-info-box h4 {
				margin: 0 0 10px 0;
				font-size: 0.95em;
			}

			/* Two columns when dashboard is wide enough */
			@container dashboard (min-width: 500px) {
				.tf-info-grid {
					grid-template-columns: 1fr 1fr;
				}
			}

			/* History header layout */
			.tf-history-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				gap: 10px;
			}

			.tf-history-controls {
				display: flex;
				align-items: center;
				gap: 10px;
				flex: 0 0 auto;
			}

			/* History filter chips */
			.tf-history-filters {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				padding: 10px 0;
				border-bottom: 1px solid var(--background-modifier-border);
				margin-bottom: 10px;
			}

			.tf-filter-chip {
				padding: 4px 12px;
				border-radius: 16px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				cursor: pointer;
				font-size: 0.85em;
				transition: all 0.15s ease;
			}

			.tf-filter-chip:hover {
				background: var(--background-secondary);
			}

			.tf-filter-chip.active {
				background: var(--interactive-accent);
				color: var(--text-on-accent);
				border-color: var(--interactive-accent);
			}

			/* History table - shared styles for consistent column widths */
			.tf-history-table-wide,
			.tf-history-table-narrow {
				width: 100%;
				border-collapse: collapse;
				margin-bottom: 15px;
				table-layout: fixed;
			}

			.tf-history-table-wide th,
			.tf-history-table-wide td,
			.tf-history-table-narrow th,
			.tf-history-table-narrow td {
				padding: 8px;
				color: var(--text-normal);
				border-bottom: 1px solid var(--background-modifier-border);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.tf-history-table-wide thead tr,
			.tf-history-table-narrow thead tr {
				background: var(--background-secondary);
			}

			/* Fixed column widths for wide table */
			.tf-history-table-wide th:nth-child(1),
			.tf-history-table-wide td:nth-child(1) { width: 100px; } /* Dato */
			.tf-history-table-wide th:nth-child(2),
			.tf-history-table-wide td:nth-child(2) { width: 120px; } /* Type */
			.tf-history-table-wide th:nth-child(3),
			.tf-history-table-wide td:nth-child(3) { width: 80px; } /* Start */
			.tf-history-table-wide th:nth-child(4),
			.tf-history-table-wide td:nth-child(4) { width: 80px; } /* Slutt */
			.tf-history-table-wide th:nth-child(5),
			.tf-history-table-wide td:nth-child(5) { width: 70px; } /* Timer */
			.tf-history-table-wide th:nth-child(6),
			.tf-history-table-wide td:nth-child(6) { width: 80px; } /* Fleksitid */
			.tf-history-table-wide th:nth-child(7),
			.tf-history-table-wide td:nth-child(7) { width: 40px; } /* Delete */

			/* Fixed column widths for narrow table */
			.tf-history-table-narrow th:nth-child(1),
			.tf-history-table-narrow td:nth-child(1) { width: 100px; } /* Dato */
			.tf-history-table-narrow th:nth-child(2),
			.tf-history-table-narrow td:nth-child(2) { width: auto; } /* Type */
			.tf-history-table-narrow th:nth-child(3),
			.tf-history-table-narrow td:nth-child(3) { width: 70px; } /* Timer */
			.tf-history-table-narrow th:nth-child(4),
			.tf-history-table-narrow td:nth-child(4) { width: 80px; } /* Fleksitid */
			.tf-history-table-narrow th:nth-child(5),
			.tf-history-table-narrow td:nth-child(5) { width: 50px; } /* Handling */

			.tf-history-table-wide input[type="time"],
			.tf-time-input {
				padding: 4px 6px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
				color: var(--text-normal);
				font-size: 0.9em;
				width: 100%;
				box-sizing: border-box;
			}

			.tf-time-input {
				text-align: center;
				font-family: var(--font-monospace);
			}

			.tf-history-table-wide select {
				padding: 4px 6px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
				color: var(--text-normal);
				font-size: 0.9em;
				width: 100%;
				box-sizing: border-box;
			}

			.tf-history-table-wide input:focus,
			.tf-history-table-wide select:focus {
				outline: none;
				border-color: var(--interactive-accent);
			}

			.tf-history-edit-btn {
				padding: 4px 10px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				cursor: pointer;
				font-size: 0.85em;
				white-space: nowrap;
				min-width: 80px;
			}

			.tf-history-edit-btn:hover {
				background: var(--background-secondary);
			}

			.tf-history-edit-btn.active {
				background: var(--interactive-accent);
				color: var(--text-on-accent);
				border-color: var(--interactive-accent);
			}

			/* Hide edit button in narrow mode */
			.tf-history-edit-btn.tf-hide-narrow {
				display: none;
			}

			.tf-history-delete-btn {
				padding: 4px 8px;
				border: none;
				background: transparent;
				color: var(--text-muted);
				cursor: pointer;
				font-size: 1em;
				opacity: 0.7;
				transition: opacity 0.15s ease;
			}

			.tf-history-delete-btn:hover {
				opacity: 1;
				color: #f44336;
			}

			.tf-history-add-row {
				cursor: pointer;
			}

			.tf-history-add-row td {
				text-align: center;
				color: var(--text-muted);
				padding: 8px;
			}

			.tf-history-add-row:hover td {
				background: var(--background-secondary);
				color: var(--text-normal);
			}

			/* Delete confirmation dialog */
			.tf-confirm-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.5);
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 10000;
			}

			.tf-confirm-dialog {
				background: var(--background-primary);
				border-radius: 8px;
				padding: 20px;
				max-width: 400px;
				width: 90%;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			}

			.tf-confirm-title {
				font-size: 16px;
				font-weight: bold;
				margin-bottom: 12px;
				color: var(--text-normal);
			}

			.tf-confirm-message {
				font-size: 14px;
				color: var(--text-muted);
				margin-bottom: 8px;
			}

			.tf-confirm-details {
				background: var(--background-secondary);
				padding: 10px;
				border-radius: 4px;
				margin-bottom: 16px;
				font-size: 13px;
			}

			.tf-confirm-buttons {
				display: flex;
				gap: 10px;
				justify-content: flex-end;
			}

			.tf-confirm-cancel {
				padding: 8px 16px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				color: var(--text-normal);
				cursor: pointer;
			}

			.tf-confirm-delete {
				padding: 8px 16px;
				border-radius: 4px;
				border: none;
				background: #f44336;
				color: white;
				cursor: pointer;
				font-weight: bold;
			}

			.tf-confirm-delete:hover {
				background: #d32f2f;
			}
		`;
    document.head.appendChild(style);
  }
  buildBadgeSection() {
    const section = document.createElement("div");
    section.className = "tf-badge-section";
    const badge = document.createElement("div");
    badge.className = "tf-badge";
    this.elements.badge = badge;
    const clock = document.createElement("div");
    clock.className = "tf-clock";
    this.elements.clock = clock;
    const complianceBadge = document.createElement("div");
    complianceBadge.className = "tf-compliance-badge";
    this.elements.complianceBadge = complianceBadge;
    const timerBadge = document.createElement("button");
    timerBadge.className = "tf-timer-badge";
    this.elements.timerBadge = timerBadge;
    if (!this.settings.enableGoalTracking) {
      badge.style.display = "none";
      complianceBadge.style.display = "none";
    }
    section.appendChild(badge);
    section.appendChild(clock);
    section.appendChild(complianceBadge);
    section.appendChild(timerBadge);
    this.updateBadge();
    this.updateComplianceBadge();
    this.updateTimerBadge();
    this.updateClock();
    return section;
  }
  updateTimerBadge() {
    if (!this.elements.timerBadge)
      return;
    const activeTimers = this.timerManager.getActiveTimers();
    if (activeTimers.length === 0) {
      this.elements.timerBadge.empty();
      this.elements.timerBadge.style.background = "transparent";
      this.elements.timerBadge.style.display = "inline-flex";
      this.elements.timerBadge.style.alignItems = "stretch";
      this.elements.timerBadge.style.gap = "0";
      this.elements.timerBadge.style.padding = "0";
      this.elements.timerBadge.style.position = "relative";
      this.elements.timerBadge.onclick = null;
      const startBtn = document.createElement("div");
      startBtn.textContent = "Start";
      startBtn.style.background = "#4caf50";
      startBtn.style.color = "white";
      startBtn.style.padding = "8px 12px";
      startBtn.style.cursor = "pointer";
      startBtn.style.borderRadius = "12px 0 0 12px";
      startBtn.style.display = "flex";
      startBtn.style.alignItems = "center";
      startBtn.style.justifyContent = "center";
      startBtn.style.transition = "filter 0.2s";
      startBtn.onmouseover = () => {
        startBtn.style.filter = "brightness(1.1)";
      };
      startBtn.onmouseout = () => {
        startBtn.style.filter = "";
      };
      startBtn.onclick = async (e) => {
        e.stopPropagation();
        const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
        const timerName = (workType == null ? void 0 : workType.id) || "jobb";
        await this.timerManager.startTimer(timerName);
        this.updateTimerBadge();
      };
      const arrowBtn = document.createElement("div");
      arrowBtn.textContent = "\u25BC";
      arrowBtn.style.background = "#388e3c";
      arrowBtn.style.color = "white";
      arrowBtn.style.padding = "8px 8px";
      arrowBtn.style.cursor = "pointer";
      arrowBtn.style.borderRadius = "0 12px 12px 0";
      arrowBtn.style.fontSize = "0.8em";
      arrowBtn.style.display = "flex";
      arrowBtn.style.alignItems = "center";
      arrowBtn.style.borderLeft = "1px solid rgba(255,255,255,0.3)";
      arrowBtn.style.transition = "filter 0.2s";
      arrowBtn.onmouseover = () => {
        arrowBtn.style.filter = "brightness(1.1)";
      };
      arrowBtn.onmouseout = () => {
        arrowBtn.style.filter = "";
      };
      arrowBtn.onclick = (e) => {
        e.stopPropagation();
        this.showTimerTypeMenu(arrowBtn);
      };
      this.elements.timerBadge.appendChild(startBtn);
      this.elements.timerBadge.appendChild(arrowBtn);
    } else {
      this.elements.timerBadge.empty();
      this.elements.timerBadge.textContent = t("buttons.stop");
      this.elements.timerBadge.style.background = "#f44336";
      this.elements.timerBadge.style.color = "white";
      this.elements.timerBadge.style.display = "inline-flex";
      this.elements.timerBadge.style.alignItems = "center";
      this.elements.timerBadge.style.justifyContent = "center";
      this.elements.timerBadge.style.padding = "";
      this.elements.timerBadge.onclick = async () => {
        for (const timer of activeTimers) {
          await this.timerManager.stopTimer(timer);
        }
        this.updateTimerBadge();
      };
    }
  }
  showTimerTypeMenu(button) {
    const existingMenu = document.querySelector(".tf-timer-type-menu");
    if (existingMenu) {
      existingMenu.remove();
      return;
    }
    const menu = document.createElement("div");
    menu.className = "tf-timer-type-menu";
    menu.style.position = "fixed";
    menu.style.background = "var(--background-primary)";
    menu.style.border = "1px solid var(--background-modifier-border)";
    menu.style.borderRadius = "8px";
    menu.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
    menu.style.zIndex = "1000";
    menu.style.minWidth = "150px";
    menu.style.overflow = "hidden";
    const timerTypes = [
      { name: "jobb", icon: "\u{1F4BC}", label: translateSpecialDayName("jobb") },
      { name: "kurs", icon: "\u{1F4DA}", label: translateSpecialDayName("kurs") },
      { name: "studie", icon: "\u{1F393}", label: translateSpecialDayName("studie") }
    ];
    timerTypes.forEach((type) => {
      const item = document.createElement("div");
      item.style.padding = "10px 15px";
      item.style.cursor = "pointer";
      item.style.display = "flex";
      item.style.alignItems = "center";
      item.style.gap = "8px";
      item.style.transition = "background 0.2s";
      item.createSpan({ text: type.icon });
      item.createSpan({ text: type.label });
      item.onmouseover = () => {
        item.style.background = "var(--background-modifier-hover)";
      };
      item.onmouseout = () => {
        item.style.background = "";
      };
      item.onclick = async () => {
        await this.timerManager.startTimer(type.name);
        this.updateTimerBadge();
        menu.remove();
      };
      menu.appendChild(item);
    });
    document.body.appendChild(menu);
    const rect = button.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const margin = 10;
    let top = rect.bottom + 5;
    let left = rect.left;
    if (top + menuRect.height + margin > viewportHeight) {
      top = rect.top - menuRect.height - 5;
    }
    if (left + menuRect.width + margin > viewportWidth) {
      left = viewportWidth - menuRect.width - margin;
    }
    if (left < margin) {
      left = margin;
    }
    if (top < margin) {
      top = margin;
    }
    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 0);
  }
  buildSummaryCards() {
    const container = document.createElement("div");
    container.className = "tf-summary-cards";
    container.appendChild(this.createDayCard());
    container.appendChild(this.createWeekCard());
    container.appendChild(this.createMonthCard());
    return container;
  }
  createDayCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-day";
    this.elements.dayCard = card;
    this.updateDayCard();
    return card;
  }
  createWeekCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-week";
    this.elements.weekCard = card;
    this.updateWeekCard();
    return card;
  }
  createMonthCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-month";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "15px";
    header.style.flexWrap = "wrap";
    header.style.gap = "8px";
    const title = document.createElement("h3");
    title.textContent = t("ui.calendar");
    title.style.margin = "0";
    title.style.flexShrink = "1";
    title.style.minWidth = "0";
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.flexShrink = "0";
    const prevBtn = document.createElement("button");
    prevBtn.textContent = "\u25C4";
    prevBtn.className = "tf-button";
    prevBtn.onclick = () => {
      this.currentMonthOffset--;
      this.updateMonthCard();
    };
    const todayBtn = document.createElement("button");
    todayBtn.textContent = t("ui.today");
    todayBtn.className = "tf-button";
    todayBtn.onclick = () => {
      this.currentMonthOffset = 0;
      this.updateMonthCard();
    };
    const nextBtn = document.createElement("button");
    nextBtn.textContent = "\u25BA";
    nextBtn.className = "tf-button";
    nextBtn.onclick = () => {
      this.currentMonthOffset++;
      this.updateMonthCard();
    };
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const gridContainer = document.createElement("div");
    this.elements.monthCard = gridContainer;
    card.appendChild(gridContainer);
    const futureDaysContainer = document.createElement("div");
    futureDaysContainer.className = "tf-future-days-list";
    card.appendChild(futureDaysContainer);
    this.updateMonthCard();
    return card;
  }
  createStatsCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-stats";
    const contentWrapper = document.createElement("div");
    contentWrapper.className = "tf-collapsible-content open";
    const headerRow = document.createElement("div");
    headerRow.className = "tf-collapsible";
    headerRow.style.display = "flex";
    headerRow.style.justifyContent = "space-between";
    headerRow.style.alignItems = "center";
    headerRow.style.flexWrap = "wrap";
    headerRow.style.gap = "10px";
    const header = document.createElement("h3");
    header.textContent = t("ui.statistics");
    header.style.margin = "0";
    headerRow.appendChild(header);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const timeframes = ["total", "year", "month"];
    const labels = { total: t("timeframes.total"), year: t("timeframes.year"), month: t("timeframes.month") };
    timeframes.forEach((tf) => {
      const tab = document.createElement("button");
      tab.className = `tf-tab ${tf === this.statsTimeframe ? "active" : ""}`;
      tab.textContent = labels[tf];
      tab.onclick = () => {
        this.statsTimeframe = tf;
        tabs.querySelectorAll(".tf-tab").forEach((t2) => t2.classList.remove("active"));
        tab.classList.add("active");
        if (!contentWrapper.classList.contains("open")) {
          contentWrapper.classList.add("open");
        }
        this.updateStatsCard();
      };
      tabs.appendChild(tab);
    });
    headerRow.appendChild(tabs);
    card.appendChild(headerRow);
    const timeframeSelectorContainer = document.createElement("div");
    timeframeSelectorContainer.className = "tf-timeframe-selector";
    timeframeSelectorContainer.style.marginBottom = "15px";
    timeframeSelectorContainer.style.display = "flex";
    timeframeSelectorContainer.style.gap = "10px";
    timeframeSelectorContainer.style.alignItems = "center";
    timeframeSelectorContainer.style.flexWrap = "wrap";
    contentWrapper.appendChild(timeframeSelectorContainer);
    const statsContainer = document.createElement("div");
    statsContainer.className = "tf-stats-grid";
    this.elements.statsCard = statsContainer;
    contentWrapper.appendChild(statsContainer);
    card.appendChild(contentWrapper);
    header.onclick = () => {
      contentWrapper.classList.toggle("open");
    };
    header.style.cursor = "pointer";
    this.updateStatsCard();
    return card;
  }
  buildInfoCard() {
    var _a, _b, _c;
    const card = document.createElement("div");
    card.className = "tf-card tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    const h3 = header.createEl("h3", { text: t("ui.information") });
    h3.style.margin = "0";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const specialDayInfo = this.settings.specialDayBehaviors.filter((b) => !b.isWorkType).map((behavior) => ({
      key: behavior.id,
      emoji: behavior.icon,
      desc: this.getFlextimeEffectDescription(behavior)
    }));
    specialDayInfo.push({ key: t("ui.noRegistration"), emoji: "\u26AA", desc: t("ui.noDataForDay") });
    const infoGrid = content.createDiv({ cls: "tf-info-grid" });
    const leftColumn = infoGrid.createDiv({ cls: "tf-info-column" });
    const specialDaysBox = leftColumn.createDiv({ cls: "tf-info-box" });
    specialDaysBox.createEl("h4", { text: t("info.specialDayTypes") });
    const specialDaysList = specialDaysBox.createEl("ul");
    specialDaysList.style.listStyle = "none";
    specialDaysList.style.paddingLeft = "0";
    specialDaysList.style.margin = "0";
    specialDayInfo.forEach((item) => {
      const color = getSpecialDayColors(this.settings)[item.key] || "transparent";
      const label = translateSpecialDayName(item.key);
      const li = specialDaysList.createEl("li");
      li.style.display = "flex";
      li.style.alignItems = "center";
      li.style.marginBottom = "8px";
      li.style.fontSize = "0.9em";
      const colorBox = li.createDiv();
      colorBox.style.width = "16px";
      colorBox.style.height = "16px";
      colorBox.style.background = color;
      colorBox.style.borderRadius = "3px";
      colorBox.style.border = "1px solid var(--background-modifier-border)";
      colorBox.style.marginRight = "8px";
      colorBox.style.flexShrink = "0";
      const textSpan = li.createSpan({ text: item.emoji + " " });
      textSpan.createEl("strong", { text: label });
      textSpan.appendText(": " + item.desc);
    });
    if (this.settings.enableGoalTracking) {
      const gradientBox = leftColumn.createDiv({ cls: "tf-info-box" });
      gradientBox.createEl("h4", { text: t("info.workDaysGradient") });
      const gradientP = gradientBox.createEl("p", { text: t("info.colorShowsFlextime") + " (" + this.settings.baseWorkday + "h):" });
      gradientP.style.margin = "0 0 10px 0";
      gradientP.style.fontSize = "0.9em";
      const posGradient = gradientBox.createDiv();
      posGradient.style.height = "16px";
      posGradient.style.borderRadius = "8px";
      posGradient.style.background = `linear-gradient(to right, ${this.flextimeColor(0)}, ${this.flextimeColor(1.5)}, ${this.flextimeColor(3)})`;
      posGradient.style.margin = "4px 0";
      posGradient.style.border = "1px solid var(--background-modifier-border)";
      const posLabels = gradientBox.createDiv();
      posLabels.style.display = "flex";
      posLabels.style.justifyContent = "space-between";
      posLabels.style.fontSize = "0.8em";
      posLabels.style.color = "var(--text-muted)";
      posLabels.style.marginBottom = "10px";
      posLabels.createSpan({ text: "0h" });
      posLabels.createSpan({ text: "+1.5h" });
      posLabels.createSpan({ text: "+3h" });
      const negGradient = gradientBox.createDiv();
      negGradient.style.height = "16px";
      negGradient.style.borderRadius = "8px";
      negGradient.style.background = `linear-gradient(to right, ${this.flextimeColor(-3)}, ${this.flextimeColor(-1.5)}, ${this.flextimeColor(0)})`;
      negGradient.style.margin = "4px 0";
      negGradient.style.border = "1px solid var(--background-modifier-border)";
      const negLabels = gradientBox.createDiv();
      negLabels.style.display = "flex";
      negLabels.style.justifyContent = "space-between";
      negLabels.style.fontSize = "0.8em";
      negLabels.style.color = "var(--text-muted)";
      negLabels.createSpan({ text: "-3h" });
      negLabels.createSpan({ text: "-1.5h" });
      negLabels.createSpan({ text: "0h" });
    }
    const rightColumn = infoGrid.createDiv({ cls: "tf-info-column" });
    const calendarBox = rightColumn.createDiv({ cls: "tf-info-box" });
    calendarBox.createEl("h4", { text: t("info.calendarContextMenu") });
    const calendarP = calendarBox.createEl("p", { text: t("info.clickDayFor") });
    calendarP.style.margin = "0 0 8px 0";
    calendarP.style.fontSize = "0.9em";
    const calendarList = calendarBox.createEl("ul");
    calendarList.style.margin = "0 0 0 16px";
    calendarList.style.fontSize = "0.9em";
    calendarList.style.paddingLeft = "0";
    calendarList.style.listStylePosition = "inside";
    calendarList.createEl("li", { text: t("info.createDailyNote") });
    calendarList.createEl("li", { text: t("info.editFlextimeManually") });
    calendarList.createEl("li", { text: t("info.registerSpecialDays") });
    const createColorRow = (container, color, label, desc) => {
      const row = container.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      const colorSpan = row.createSpan();
      colorSpan.style.display = "inline-block";
      colorSpan.style.width = "16px";
      colorSpan.style.height = "16px";
      colorSpan.style.borderRadius = "3px";
      colorSpan.style.background = color;
      colorSpan.style.flexShrink = "0";
      const textSpan = row.createSpan();
      textSpan.createEl("strong", { text: label + ":" });
      textSpan.appendText(" " + desc);
    };
    if (this.settings.enableGoalTracking) {
      const balanceBox = rightColumn.createDiv({ cls: "tf-info-box" });
      balanceBox.createEl("h4", { text: t("info.flextimeBalanceZones") });
      const balanceContainer = balanceBox.createDiv();
      balanceContainer.style.display = "flex";
      balanceContainer.style.flexDirection = "column";
      balanceContainer.style.gap = "6px";
      balanceContainer.style.fontSize = "0.9em";
      createColorRow(balanceContainer, ((_a = this.settings.customColors) == null ? void 0 : _a.balanceOk) || "#4caf50", t("info.green"), this.settings.balanceThresholds.warningLow + "h " + t("info.to") + " +" + this.settings.balanceThresholds.warningHigh + "h");
      createColorRow(balanceContainer, ((_b = this.settings.customColors) == null ? void 0 : _b.balanceWarning) || "#ff9800", t("info.yellow"), this.settings.balanceThresholds.criticalLow + "h " + t("info.to") + " " + (this.settings.balanceThresholds.warningLow - 1) + "h / +" + this.settings.balanceThresholds.warningHigh + "h " + t("info.to") + " +" + this.settings.balanceThresholds.criticalHigh + "h");
      createColorRow(balanceContainer, ((_c = this.settings.customColors) == null ? void 0 : _c.balanceCritical) || "#f44336", t("info.red"), "<" + this.settings.balanceThresholds.criticalLow + "h / >+" + this.settings.balanceThresholds.criticalHigh + "h");
      const weekBox = rightColumn.createDiv({ cls: "tf-info-box" });
      weekBox.createEl("h4", { text: t("info.weekNumberCompliance") });
      const weekContainer = weekBox.createDiv();
      weekContainer.style.display = "flex";
      weekContainer.style.flexDirection = "column";
      weekContainer.style.gap = "6px";
      weekContainer.style.fontSize = "0.9em";
      createColorRow(weekContainer, "linear-gradient(135deg, #c8e6c9, #a5d6a7)", t("info.green"), t("info.reachedGoal") + " (\xB10.5h)");
      createColorRow(weekContainer, "linear-gradient(135deg, #ffe0b2, #ffcc80)", t("info.orange"), t("info.overGoal"));
      createColorRow(weekContainer, "linear-gradient(135deg, #ffcdd2, #ef9a9a)", t("info.red"), t("info.underGoal"));
      createColorRow(weekContainer, "linear-gradient(135deg, #e0e0e0, #bdbdbd)", t("info.gray"), t("info.weekInProgress"));
      const weekTip = weekBox.createEl("p");
      weekTip.style.margin = "8px 0 0 0";
      weekTip.style.fontSize = "0.8em";
      weekTip.style.opacity = "0.8";
      weekTip.createEl("em", { text: t("info.clickWeekForDetails") });
    }
    header.onclick = () => {
      content.classList.toggle("open");
    };
    card.appendChild(header);
    card.appendChild(content);
    return card;
  }
  buildHistoryCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-history tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible tf-history-header";
    const title = document.createElement("h3");
    title.textContent = t("ui.history");
    title.style.margin = "0";
    title.style.flex = "1 1 auto";
    header.appendChild(title);
    const rightControls = document.createElement("div");
    rightControls.className = "tf-history-controls";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const detailsElement = document.createElement("div");
    detailsElement.className = "tf-history-content";
    const editToggle = document.createElement("button");
    editToggle.className = `tf-history-edit-btn ${this.inlineEditMode ? "active" : ""}`;
    editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
    editToggle.onclick = (e) => {
      e.stopPropagation();
      this.inlineEditMode = !this.inlineEditMode;
      editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
      editToggle.classList.toggle("active", this.inlineEditMode);
      this.refreshHistoryView(detailsElement);
    };
    rightControls.appendChild(editToggle);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const views = [
      { id: "list", label: t("buttons.list") },
      { id: "heatmap", label: t("buttons.heatmap") }
    ];
    views.forEach((view) => {
      const tab = document.createElement("button");
      tab.textContent = view.label;
      tab.className = `tf-tab ${this.historyView === view.id ? "active" : ""}`;
      tab.onclick = (e) => {
        e.stopPropagation();
        this.historyView = view.id;
        this.inlineEditMode = false;
        editToggle.textContent = `\u270F\uFE0F ${t("buttons.edit")}`;
        editToggle.classList.remove("active");
        tabs.querySelectorAll(".tf-tab").forEach((t2) => t2.classList.remove("active"));
        tab.classList.add("active");
        if (!content.classList.contains("open")) {
          content.classList.add("open");
        }
        this.refreshHistoryView(detailsElement);
      };
      tabs.appendChild(tab);
    });
    rightControls.appendChild(tabs);
    header.appendChild(rightControls);
    card._editToggle = editToggle;
    card._detailsElement = detailsElement;
    content.appendChild(detailsElement);
    header.onclick = () => {
      content.classList.toggle("open");
    };
    header.style.cursor = "pointer";
    card.appendChild(header);
    card.appendChild(content);
    this.refreshHistoryView(detailsElement);
    requestAnimationFrame(() => {
      this.updateEditToggleVisibility(detailsElement);
    });
    return card;
  }
  buildStatusBar() {
    var _a, _b, _c, _d, _e, _f;
    const bar = document.createElement("div");
    bar.className = "tf-status-bar";
    const status = this.systemStatus;
    const hasErrors = (_a = status.validation) == null ? void 0 : _a.hasErrors;
    const hasWarnings = (_b = status.validation) == null ? void 0 : _b.hasWarnings;
    const statusIcon = hasErrors ? "\u274C" : hasWarnings ? "\u26A0\uFE0F" : "\u2705";
    const hasIssues = hasErrors || hasWarnings;
    const buildIssuesContent = (container) => {
      var _a2;
      if (hasIssues && ((_a2 = status.validation) == null ? void 0 : _a2.issues)) {
        const errors = status.validation.issues.errors || [];
        const warnings = status.validation.issues.warnings || [];
        if (errors.length > 0) {
          const errorHeader = container.createDiv();
          errorHeader.style.marginTop = "8px";
          const errorStrong = errorHeader.createEl("strong");
          errorStrong.style.color = "#f44336";
          errorStrong.textContent = `Feil (${errors.length}):`;
          errors.slice(0, 5).forEach((err) => {
            const errorItem = container.createDiv();
            errorItem.style.cssText = "font-size: 12px; margin-left: 12px; color: #f44336;";
            errorItem.textContent = `\u2022 ${err.type}: ${err.description}${err.date ? ` (${err.date})` : ""}`;
          });
          if (errors.length > 5) {
            const moreErrors = container.createDiv();
            moreErrors.style.cssText = "font-size: 11px; margin-left: 12px; color: var(--text-muted);";
            moreErrors.textContent = `...og ${errors.length - 5} flere feil`;
          }
        }
        if (warnings.length > 0) {
          const warningHeader = container.createDiv();
          warningHeader.style.marginTop = "8px";
          const warningStrong = warningHeader.createEl("strong");
          warningStrong.style.color = "#ff9800";
          warningStrong.textContent = `Advarsler (${warnings.length}):`;
          warnings.slice(0, 5).forEach((warn) => {
            const warningItem = container.createDiv();
            warningItem.style.cssText = "font-size: 12px; margin-left: 12px; color: #ff9800;";
            warningItem.textContent = `\u2022 ${warn.type}: ${warn.description}${warn.date ? ` (${warn.date})` : ""}`;
          });
          if (warnings.length > 5) {
            const moreWarnings = container.createDiv();
            moreWarnings.style.cssText = "font-size: 11px; margin-left: 12px; color: var(--text-muted);";
            moreWarnings.textContent = `...og ${warnings.length - 5} flere advarsler`;
          }
        }
      }
    };
    const header = document.createElement("div");
    header.style.cssText = "display: flex; align-items: center; gap: 10px; cursor: pointer;";
    header.createSpan({ text: statusIcon });
    const headerContent = header.createDiv();
    headerContent.style.flex = "1";
    const titleRow = headerContent.createDiv();
    titleRow.createEl("strong", { text: t("status.systemStatus") });
    if (hasIssues) {
      const clickHint = titleRow.createSpan({ text: ` (${t("status.clickForDetails")})` });
      clickHint.style.cssText = "font-size: 11px; opacity: 0.7;";
    }
    const statusRow = headerContent.createDiv();
    statusRow.style.cssText = "font-size: 12px; color: var(--text-muted); display: flex; justify-content: space-between; align-items: center;";
    const statusText = statusRow.createSpan();
    statusText.textContent = `${((_c = status.holiday) == null ? void 0 : _c.message) || t("status.holidayNotLoaded")} \u2022 ${status.activeTimers || 0} ${t("status.activeTimers")} \u2022 ${((_f = (_e = (_d = status.validation) == null ? void 0 : _d.issues) == null ? void 0 : _e.stats) == null ? void 0 : _f.totalEntries) || 0} ${t("status.entriesChecked")}`;
    const versionText = statusRow.createSpan();
    versionText.style.cssText = "font-size: 11px; opacity: 0.6;";
    versionText.textContent = `v${this.plugin.manifest.version}`;
    if (hasIssues) {
      const toggle = header.createSpan({ cls: "tf-status-toggle", text: "\u25B6" });
      toggle.style.cssText = "font-size: 10px; transition: transform 0.2s;";
    }
    bar.appendChild(header);
    if (hasIssues) {
      const details = document.createElement("div");
      details.className = "tf-status-details";
      details.style.cssText = "max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; opacity: 0;";
      const detailsInner = details.createDiv();
      detailsInner.style.cssText = "padding-top: 10px; border-top: 1px solid var(--background-modifier-border); margin-top: 10px;";
      buildIssuesContent(detailsInner);
      bar.appendChild(details);
      let isOpen = false;
      header.onclick = () => {
        isOpen = !isOpen;
        const toggle = header.querySelector(".tf-status-toggle");
        if (toggle) {
          toggle.style.transform = isOpen ? "rotate(90deg)" : "rotate(0deg)";
        }
        if (isOpen) {
          details.style.maxHeight = details.scrollHeight + "px";
          details.style.opacity = "1";
        } else {
          details.style.maxHeight = "0";
          details.style.opacity = "0";
        }
      };
    }
    return bar;
  }
  buildViewToggle() {
    const container = document.createElement("div");
    container.style.cssText = "display: flex; justify-content: flex-end; margin-top: 8px;";
    const viewToggle = document.createElement("button");
    const isInSidebar = this.isViewInSidebar();
    viewToggle.className = "tf-view-toggle";
    viewToggle.style.cssText = `
			background: var(--background-secondary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			padding: 6px 10px;
			cursor: pointer;
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 6px;
			color: var(--text-normal);
			transition: background 0.2s, border-color 0.2s;
			font-weight: 500;
		`;
    const iconSpan = viewToggle.createSpan();
    iconSpan.style.fontSize = "14px";
    iconSpan.textContent = isInSidebar ? "\u229E" : "\u25E7";
    viewToggle.appendText(" " + (isInSidebar ? t("buttons.moveToMain") : t("buttons.moveToSidebar")));
    viewToggle.title = isInSidebar ? t("buttons.moveToMain") : t("buttons.moveToSidebar");
    viewToggle.onmouseenter = () => {
      viewToggle.style.background = "var(--background-modifier-hover)";
      viewToggle.style.borderColor = "var(--interactive-accent)";
    };
    viewToggle.onmouseleave = () => {
      viewToggle.style.background = "var(--background-secondary)";
      viewToggle.style.borderColor = "var(--background-modifier-border)";
    };
    viewToggle.onclick = (e) => {
      e.stopPropagation();
      const newLocation = isInSidebar ? "main" : "sidebar";
      this.plugin.moveViewToLocation(newLocation);
    };
    container.appendChild(viewToggle);
    return container;
  }
  updateClock() {
    if (!this.elements.clock)
      return;
    const now = /* @__PURE__ */ new Date();
    this.elements.clock.textContent = now.toLocaleTimeString("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  updateBadge() {
    if (!this.elements.badge)
      return;
    const balance = this.data.getCurrentBalance();
    const formatted = Utils.formatHoursToHM(Math.abs(balance), this.settings.hourUnit);
    const sign = balance >= 0 ? "+" : "-";
    const color = this.getBalanceColor(balance);
    this.elements.badge.style.background = color;
    this.elements.badge.style.color = "white";
    this.elements.badge.textContent = `${t("ui.flextimeBalance")}: ${sign}${formatted}`;
  }
  /**
   * Check if the current view is in the sidebar (right or left)
   */
  isViewInSidebar() {
    const leaves = this.app.workspace.getLeavesOfType("timeflow-view");
    if (leaves.length === 0)
      return true;
    const leaf = leaves[0];
    const root = leaf.getRoot();
    return root === this.app.workspace.rightSplit || root === this.app.workspace.leftSplit;
  }
  /**
   * Get compliance status: 'ok' | 'approaching' | 'exceeded'
   * Based on daily and weekly hours compared to limits
   */
  getComplianceStatus() {
    var _a, _b, _c, _d, _e;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      return { status: "ok", dailyStatus: "ok", weeklyStatus: "ok", tooltip: "" };
    }
    const today = /* @__PURE__ */ new Date();
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const weeklyLimit = (_e = (_d = this.settings.complianceSettings) == null ? void 0 : _d.weeklyHoursLimit) != null ? _e : 40;
    const dailyApproaching = this.settings.baseWorkday * this.settings.workPercent;
    const weeklyApproaching = this.settings.baseWorkweek * this.settings.workPercent;
    let dailyStatus = "ok";
    let weeklyStatus = "ok";
    if (todayHours >= dailyLimit) {
      dailyStatus = "exceeded";
    } else if (todayHours >= dailyApproaching) {
      dailyStatus = "approaching";
    }
    if (weekHours >= weeklyLimit) {
      weeklyStatus = "exceeded";
    } else if (weekHours >= weeklyApproaching) {
      weeklyStatus = "approaching";
    }
    let status = "ok";
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded") {
      status = "exceeded";
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      status = "approaching";
    }
    const tooltipParts = [];
    if (dailyStatus === "exceeded") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit} (max ${dailyLimit}${this.settings.hourUnit})`);
    } else if (dailyStatus === "approaching") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit} (${t("status.approachingLimits")} ${dailyLimit}${this.settings.hourUnit})`);
    }
    if (weeklyStatus === "exceeded") {
      tooltipParts.push(`${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} (max ${weeklyLimit}${this.settings.hourUnit})`);
    } else if (weeklyStatus === "approaching") {
      tooltipParts.push(`${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} (${t("status.approachingLimits")} ${weeklyLimit}${this.settings.hourUnit})`);
    }
    if (tooltipParts.length === 0 && status === "ok") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit}, ${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} - ${t("status.withinLimits")}`);
    }
    return { status, dailyStatus, weeklyStatus, tooltip: tooltipParts.join("\n") };
  }
  /**
   * Update compliance status badge
   */
  updateComplianceBadge() {
    var _a;
    if (!this.elements.complianceBadge)
      return;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      this.elements.complianceBadge.style.display = "none";
      return;
    }
    const { status } = this.getComplianceStatus();
    this.elements.complianceBadge.style.display = "";
    this.elements.complianceBadge.style.cursor = "pointer";
    if (status === "ok") {
      this.elements.complianceBadge.style.background = "rgba(76, 175, 80, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(76, 175, 80, 0.4)";
      this.elements.complianceBadge.textContent = `\u{1F7E9} ${t("compliance.ok")}`;
    } else if (status === "approaching") {
      this.elements.complianceBadge.style.background = "rgba(255, 152, 0, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(255, 152, 0, 0.4)";
      this.elements.complianceBadge.textContent = `\u{1F7E8} ${t("compliance.near")}`;
    } else {
      this.elements.complianceBadge.style.background = "rgba(244, 67, 54, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(244, 67, 54, 0.4)";
      this.elements.complianceBadge.textContent = `\u{1F7E5} ${t("compliance.over")}`;
    }
    this.elements.complianceBadge.onclick = (e) => {
      e.stopPropagation();
      this.showComplianceInfoPanel();
    };
  }
  /**
   * Show compliance info panel with detailed information
   */
  showComplianceInfoPanel() {
    var _a, _b, _c, _d, _e, _f;
    const existingPanel = document.querySelector(".tf-compliance-info-panel");
    if (existingPanel) {
      existingPanel.remove();
      return;
    }
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9;
    const weeklyLimit = (_d = (_c = this.settings.complianceSettings) == null ? void 0 : _c.weeklyHoursLimit) != null ? _d : 40;
    const minimumRest = (_f = (_e = this.settings.complianceSettings) == null ? void 0 : _e.minimumRestHours) != null ? _f : 11;
    const { dailyStatus, weeklyStatus } = this.getComplianceStatus();
    const restCheck = this.data.checkRestPeriodViolation(todayStr);
    const panel = document.createElement("div");
    panel.className = "tf-compliance-info-panel";
    panel.createEl("h4", { text: `\u2696\uFE0F ${t("compliance.title")}` });
    const dailyIcon = dailyStatus === "ok" ? "\u{1F7E9}" : dailyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    const dailyP = panel.createEl("p");
    dailyP.createEl("strong", { text: `${t("ui.today")}: ` });
    dailyP.appendText(`${dailyIcon} ${todayHours.toFixed(1)}t / ${dailyLimit}t`);
    const weeklyIcon = weeklyStatus === "ok" ? "\u{1F7E9}" : weeklyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    const weeklyP = panel.createEl("p");
    weeklyP.createEl("strong", { text: `${t("ui.thisWeek")}: ` });
    weeklyP.appendText(`${weeklyIcon} ${weekHours.toFixed(1)}t / ${weeklyLimit}t`);
    if (restCheck.violated && restCheck.restHours !== null) {
      const restP = panel.createEl("p", { cls: "tf-rest-warning" });
      restP.createEl("strong", { text: `${t("ui.restPeriod")}: ` });
      restP.appendText(`\u{1F7E5} ${restCheck.restHours.toFixed(1)}t (${t("ui.minimum")} ${minimumRest}t)`);
    } else if (restCheck.restHours !== null) {
      const restP = panel.createEl("p");
      restP.createEl("strong", { text: `${t("ui.restPeriod")}: ` });
      restP.appendText(`\u{1F7E9} ${restCheck.restHours.toFixed(1)}t (${t("ui.minimum")} ${minimumRest}t)`);
    }
    const hr = panel.createEl("hr");
    hr.style.cssText = "margin: 10px 0; border: none; border-top: 1px solid var(--background-modifier-border);";
    let statusText;
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded" || restCheck.violated) {
      statusText = `${t("compliance.exceeds")} ${t("compliance.limit")}.`;
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      statusText = `${t("status.approachingLimits")} ${t("compliance.limit")}.`;
    } else {
      statusText = t("status.allLimitsOk");
    }
    const statusP = panel.createEl("p", { text: statusText });
    statusP.style.cssText = "font-size: 12px; color: var(--text-muted);";
    const badgeRect = this.elements.complianceBadge.getBoundingClientRect();
    panel.style.position = "fixed";
    document.body.appendChild(panel);
    const panelRect = panel.getBoundingClientRect();
    const padding = 10;
    let top = badgeRect.bottom + 8;
    let right = window.innerWidth - badgeRect.right;
    const leftEdge = window.innerWidth - right - panelRect.width;
    if (leftEdge < padding)
      right = window.innerWidth - panelRect.width - padding;
    if (right < padding)
      right = padding;
    if (top + panelRect.height > window.innerHeight - padding)
      top = badgeRect.top - panelRect.height - 8;
    if (top < padding)
      top = padding;
    panel.style.top = `${top}px`;
    panel.style.right = `${right}px`;
    const closeHandler = (e) => {
      if (!panel.contains(e.target) && e.target !== this.elements.complianceBadge) {
        panel.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  /**
   * Generate compliance warning HTML for daily hours
   */
  getDailyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings))
      return "";
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const approachingThreshold = this.settings.baseWorkday * this.settings.workPercent;
    if (hours >= dailyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger daglig grense p\xE5 ${dailyLimit} timer">\u26A0\uFE0F >${dailyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg daglig grense p\xE5 ${dailyLimit} timer">\u23F0 ${dailyLimit}t grense</span>`;
    }
    return "";
  }
  /**
   * Generate compliance warning HTML for weekly hours
   */
  getWeeklyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings))
      return "";
    const weeklyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.weeklyHoursLimit) != null ? _c : 40;
    const approachingThreshold = this.settings.baseWorkweek * this.settings.workPercent;
    if (hours >= weeklyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger ukentlig grense p\xE5 ${weeklyLimit} timer">\u26A0\uFE0F >${weeklyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg ukentlig grense p\xE5 ${weeklyLimit} timer">\u23F0 ${weeklyLimit}t grense</span>`;
    }
    return "";
  }
  updateDayCard() {
    var _a, _b;
    if (!this.elements.dayCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    this.updateComplianceBadge();
    if (!this.settings.enableGoalTracking) {
      this.elements.dayCard.style.background = "var(--background-secondary)";
      this.elements.dayCard.style.color = "var(--text-normal)";
      this.elements.dayCard.empty();
      const h32 = this.elements.dayCard.createEl("h3", { text: "I dag" });
      h32.style.color = "inherit";
      const hoursDiv2 = this.elements.dayCard.createDiv({ text: Utils.formatHoursToHM(todayHours, this.settings.hourUnit) });
      hoursDiv2.style.cssText = "font-size: 32px; font-weight: bold; margin: 10px 0;";
      const labelDiv = this.elements.dayCard.createDiv({ text: t("ui.hoursWorked") });
      labelDiv.style.cssText = "font-size: 14px; opacity: 0.9; margin-top: 10px;";
      return;
    }
    const goal = this.data.getDailyGoal(todayKey);
    const progress = goal > 0 ? Math.min(todayHours / goal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (todayHours <= goal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (todayHours <= goal + 1.75) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.dayCard.style.background = bgColor;
    this.elements.dayCard.style.color = textColor;
    this.elements.dayCard.empty();
    const h3 = this.elements.dayCard.createEl("h3", { text: t("ui.today") });
    h3.style.color = textColor;
    const hoursDiv = this.elements.dayCard.createDiv({ text: Utils.formatHoursToHM(todayHours, this.settings.hourUnit) });
    hoursDiv.style.cssText = "font-size: 32px; font-weight: bold; margin: 10px 0;";
    const goalDiv = this.elements.dayCard.createDiv({ text: `${t("ui.goal")}: ${Utils.formatHoursToHM(goal, this.settings.hourUnit)}` });
    goalDiv.style.cssText = "font-size: 14px; opacity: 0.9; margin-bottom: 10px;";
    const progressBar = this.elements.dayCard.createDiv({ cls: "tf-progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "tf-progress-fill" });
    progressFill.style.cssText = `width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})`;
  }
  updateWeekCard() {
    var _a, _b;
    if (!this.elements.weekCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const weekHours = this.data.getCurrentWeekHours(today);
    const currentWeekNumber = Utils.getWeekNumber(today);
    const addWeekBadge = (container) => {
      if (this.settings.showWeekNumbers) {
        container.createDiv({ cls: "tf-week-badge", text: `${t("ui.week")} ${currentWeekNumber}` });
      }
    };
    if (!this.settings.enableGoalTracking) {
      this.elements.weekCard.style.background = "var(--background-secondary)";
      this.elements.weekCard.style.color = "var(--text-normal)";
      this.elements.weekCard.empty();
      addWeekBadge(this.elements.weekCard);
      const h32 = this.elements.weekCard.createEl("h3", { text: t("ui.thisWeek") });
      h32.style.color = "inherit";
      const hoursDiv2 = this.elements.weekCard.createDiv({ text: Utils.formatHoursToHM(weekHours, this.settings.hourUnit) });
      hoursDiv2.style.cssText = "font-size: 32px; font-weight: bold; margin: 10px 0;";
      const labelDiv = this.elements.weekCard.createDiv({ text: t("ui.hoursWorked") });
      labelDiv.style.cssText = "font-size: 14px; opacity: 0.9; margin-top: 10px;";
      return;
    }
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    let adjustedGoal = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(firstDayOfWeek);
      d.setDate(firstDayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayGoal = this.data.getDailyGoal(dayKey);
      adjustedGoal += dayGoal;
    }
    const progress = adjustedGoal > 0 ? Math.min(weekHours / adjustedGoal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (!this.settings.enableWeeklyGoals) {
      bgColor = "var(--background-secondary)";
      textColor = "var(--text-normal)";
    } else if (weekHours <= adjustedGoal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (weekHours <= adjustedGoal + 3.5) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.weekCard.style.background = bgColor;
    this.elements.weekCard.style.color = textColor;
    this.elements.weekCard.empty();
    addWeekBadge(this.elements.weekCard);
    const h3 = this.elements.weekCard.createEl("h3", { text: t("ui.thisWeek") });
    h3.style.color = textColor;
    const hoursDiv = this.elements.weekCard.createDiv({ text: Utils.formatHoursToHM(weekHours, this.settings.hourUnit) });
    hoursDiv.style.cssText = "font-size: 32px; font-weight: bold; margin: 10px 0;";
    if (this.settings.enableWeeklyGoals) {
      const goalDiv = this.elements.weekCard.createDiv({ text: `${t("ui.goal")}: ${Utils.formatHoursToHM(adjustedGoal, this.settings.hourUnit)}` });
      goalDiv.style.cssText = "font-size: 14px; opacity: 0.9; margin-bottom: 10px;";
      const progressBar = this.elements.weekCard.createDiv({ cls: "tf-progress-bar" });
      const progressFill = progressBar.createDiv({ cls: "tf-progress-fill" });
      progressFill.style.cssText = `width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})`;
    }
  }
  updateStatsCard() {
    var _a, _b;
    if (!this.elements.statsCard)
      return;
    const stats = this.data.getStatistics(this.statsTimeframe, this.selectedYear, this.selectedMonth);
    const balance = this.data.getCurrentBalance();
    const { avgDaily, avgWeekly } = this.data.getAverages();
    const workloadPct = this.settings.baseWorkweek > 0 ? (avgWeekly / this.settings.baseWorkweek * 100).toFixed(0) : "0";
    const selectorContainer = (_a = this.elements.statsCard.parentElement) == null ? void 0 : _a.querySelector(".tf-timeframe-selector");
    if (selectorContainer) {
      selectorContainer.empty();
      if (this.statsTimeframe === "year") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.style.padding = "4px 8px";
          yearSelect.style.fontSize = "1em";
          yearSelect.style.fontWeight = "bold";
          yearSelect.style.border = "1px solid var(--background-modifier-border)";
          yearSelect.style.borderRadius = "4px";
          yearSelect.style.background = "var(--background-primary)";
          yearSelect.style.color = "var(--text-normal)";
          yearSelect.style.cursor = "pointer";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
        }
      } else if (this.statsTimeframe === "month") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.style.padding = "4px 8px";
          yearSelect.style.fontSize = "1em";
          yearSelect.style.fontWeight = "bold";
          yearSelect.style.border = "1px solid var(--background-modifier-border)";
          yearSelect.style.borderRadius = "4px";
          yearSelect.style.background = "var(--background-primary)";
          yearSelect.style.color = "var(--text-normal)";
          yearSelect.style.cursor = "pointer";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            const months = this.data.getAvailableMonthsForYear(this.selectedYear);
            if (months.length > 0) {
              this.selectedMonth = months[months.length - 1];
            }
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
          const availableMonths = this.data.getAvailableMonthsForYear(this.selectedYear);
          if (availableMonths.length > 0) {
            const monthSelect = document.createElement("select");
            monthSelect.style.padding = "4px 8px";
            monthSelect.style.fontSize = "1em";
            monthSelect.style.fontWeight = "bold";
            monthSelect.style.border = "1px solid var(--background-modifier-border)";
            monthSelect.style.borderRadius = "4px";
            monthSelect.style.background = "var(--background-primary)";
            monthSelect.style.color = "var(--text-normal)";
            monthSelect.style.cursor = "pointer";
            const monthNames = [
              "Januar",
              "Februar",
              "Mars",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Desember"
            ];
            availableMonths.forEach((month) => {
              const option = document.createElement("option");
              option.value = month.toString();
              option.textContent = monthNames[month];
              option.selected = month === this.selectedMonth;
              monthSelect.appendChild(option);
            });
            monthSelect.onchange = () => {
              this.selectedMonth = parseInt(monthSelect.value);
              this.updateStatsCard();
            };
            selectorContainer.appendChild(monthSelect);
          }
        }
      } else {
        const label = document.createElement("div");
        label.style.fontSize = "1.1em";
        label.style.fontWeight = "bold";
        label.textContent = t("ui.total");
        selectorContainer.appendChild(label);
      }
    }
    const context = this.data.getContextualData(this.today);
    const sign = balance >= 0 ? "+" : "";
    const timesaldoColor = this.getBalanceColor(balance);
    let ferieDisplay = `${stats.ferie.count} ${t("ui.days")}`;
    if (this.statsTimeframe === "year" && stats.ferie.max > 0) {
      const feriePercent = (stats.ferie.count / stats.ferie.max * 100).toFixed(0);
      ferieDisplay = `${stats.ferie.count}/${stats.ferie.max} ${t("ui.days")} (${feriePercent}%)`;
    }
    const egenmeldingStats = this.data.getSpecialDayStats("egenmelding", this.selectedYear);
    let egenmeldingDisplay = `${egenmeldingStats.count} ${t("ui.days")}`;
    let egenmeldingPeriodLabel = "";
    if (this.statsTimeframe === "year") {
      if (egenmeldingStats.max && egenmeldingStats.max > 0) {
        const egenmeldingPercent = (egenmeldingStats.count / egenmeldingStats.max * 100).toFixed(0);
        egenmeldingDisplay = `${egenmeldingStats.count}/${egenmeldingStats.max} ${t("ui.days")} (${egenmeldingPercent}%)`;
      }
      egenmeldingPeriodLabel = `(${egenmeldingStats.periodLabel})`;
    }
    this.elements.statsCard.empty();
    const createStatItem = (label, value, subtitle, extraCls, extraStyle) => {
      const item = this.elements.statsCard.createDiv({ cls: `tf-stat-item${extraCls ? " " + extraCls : ""}` });
      if (extraStyle)
        item.style.cssText = extraStyle;
      item.createDiv({ cls: "tf-stat-label", text: label });
      const valueDiv = item.createDiv({ cls: "tf-stat-value", text: value });
      if (subtitle !== void 0) {
        const subDiv = item.createDiv({ text: subtitle });
        subDiv.style.cssText = "font-size: 0.75em; margin-top: 4px;";
      }
      return { item, valueDiv };
    };
    if (this.settings.enableGoalTracking) {
      createStatItem(t("stats.flextimeBalance"), `${sign}${balance.toFixed(1)}t`, t("stats.totalBalance"), "tf-stat-colored", `background: ${timesaldoColor};`);
    }
    createStatItem(`\u23F1\uFE0F ${t("stats.hours")}`, `${stats.totalHours.toFixed(1)}t`);
    createStatItem(`\u{1F4CA} ${t("stats.avgPerDay")}`, `${avgDaily.toFixed(1)}t`);
    const weekItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
    weekItem.createDiv({ cls: "tf-stat-label", text: `\u{1F4C5} ${t("stats.avgPerWeek")}` });
    weekItem.createDiv({ cls: "tf-stat-value", text: `${avgWeekly.toFixed(1)}t` });
    if (context.lastWeekHours > 0) {
      const currWeekHours = this.data.getCurrentWeekHours(this.today);
      const diff = currWeekHours - context.lastWeekHours;
      if (Math.abs(diff) > 2) {
        const arrow = diff > 0 ? "\u{1F4C8}" : "\u{1F4C9}";
        const signDiff = diff > 0 ? "+" : "";
        const compDiv = weekItem.createDiv({ text: `${t("ui.vsLastWeek")}: ${signDiff}${diff.toFixed(1)}t ${arrow}` });
        compDiv.style.cssText = "font-size: 0.75em; margin-top: 4px;";
      }
    }
    if (this.settings.enableGoalTracking && this.settings.enableWeeklyGoals) {
      createStatItem(`\u{1F4AA} ${t("stats.workIntensity")}`, `${workloadPct}%`, t("stats.ofNormalWeek"));
    }
    createStatItem(`\u{1F4BC} ${t("stats.work")}`, `${stats.jobb.count} ${t("ui.days")}`, `${stats.jobb.hours.toFixed(1)}t`);
    if (stats.weekendDays > 0) {
      createStatItem(`\u{1F319} ${t("stats.weekendDaysWorked")}`, `${stats.weekendDays} ${t("ui.days")}`, `${stats.weekendHours.toFixed(1)}${this.settings.hourUnit}`);
    }
    createStatItem(`\u{1F6CC} ${t("stats.flexTimeOff")}`, `${stats.avspasering.count} ${t("ui.days")}`, `${stats.avspasering.hours.toFixed(1)}${this.settings.hourUnit}`);
    const vacationItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
    vacationItem.createDiv({ cls: "tf-stat-label", text: `\u{1F3D6}\uFE0F ${t("stats.vacation")}` });
    const vacationValue = vacationItem.createDiv({ cls: "tf-stat-value", text: ferieDisplay });
    vacationValue.style.fontSize = this.statsTimeframe === "year" ? "0.9em" : "1.3em";
    const vacationSub = vacationItem.createDiv();
    vacationSub.style.cssText = "font-size: 0.75em; margin-top: 4px;";
    createStatItem(`\u{1F3E5} ${t("stats.welfareLeave")}`, `${stats.velferdspermisjon.count} ${t("ui.days")}`);
    const sickItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
    sickItem.createDiv({ cls: "tf-stat-label", text: `\u{1F912} ${t("stats.selfReportedSick")}` });
    const sickValue = sickItem.createDiv({ cls: "tf-stat-value", text: egenmeldingDisplay });
    sickValue.style.fontSize = this.statsTimeframe === "year" ? "0.9em" : "1.3em";
    const sickSub = sickItem.createDiv({ text: egenmeldingPeriodLabel });
    sickSub.style.cssText = "font-size: 0.75em; margin-top: 4px;";
    createStatItem(`\u{1F3E5} ${t("stats.doctorSick")}`, `${stats.sykemelding.count} ${t("ui.days")}`);
    createStatItem(`\u{1F4DA} ${t("stats.study")}`, `${stats.studie.count} ${t("ui.days")}`, `${stats.studie.hours.toFixed(1)}${this.settings.hourUnit}`);
    createStatItem(`\u{1F4DA} ${t("stats.course")}`, `${stats.kurs.count} ${t("ui.days")}`, `${stats.kurs.hours.toFixed(1)}${this.settings.hourUnit}`);
    const tabs = (_b = this.elements.statsCard.parentElement) == null ? void 0 : _b.querySelectorAll(".tf-tab");
    tabs == null ? void 0 : tabs.forEach((tab) => {
      var _a2;
      const timeframe = (_a2 = tab.textContent) == null ? void 0 : _a2.toLowerCase();
      if (timeframe === "totalt" && this.statsTimeframe === "total" || timeframe === "\xE5r" && this.statsTimeframe === "year" || timeframe === "m\xE5ned" && this.statsTimeframe === "month") {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
  }
  updateMonthCard() {
    if (!this.elements.monthCard)
      return;
    const displayDate = new Date(this.today);
    displayDate.setMonth(this.today.getMonth() + this.currentMonthOffset);
    const grid = this.createMonthGrid(displayDate);
    this.elements.monthCard.empty();
    this.elements.monthCard.appendChild(grid);
    const card = this.elements.monthCard.parentElement;
    if (card) {
      const futureList = card.querySelector(".tf-future-days-list");
      if (futureList) {
        this.updateFutureDaysList(futureList);
      }
    }
  }
  updateFutureDaysList(container) {
    const today = /* @__PURE__ */ new Date();
    const futureDays = [];
    Object.keys(this.data.holidays).forEach((dateStr) => {
      const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
      if (date >= today) {
        const holiday = this.data.holidays[dateStr];
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === holiday.type);
        if (behavior) {
          const translatedLabel = translateSpecialDayName(behavior.id, behavior.label);
          futureDays.push({
            date: dateStr,
            type: translatedLabel,
            label: holiday.description || translatedLabel,
            color: behavior.color,
            textColor: behavior.textColor || "#000000"
          });
        }
      }
    });
    futureDays.sort((a, b) => a.date.localeCompare(b.date));
    const limit = this.settings.enableGoalTracking ? 10 : 7;
    const limitedDays = futureDays.slice(0, limit);
    if (limitedDays.length === 0) {
      container.empty();
      return;
    }
    container.empty();
    container.createEl("h4", { text: t("ui.upcomingPlannedDays") });
    limitedDays.forEach((day) => {
      const date = /* @__PURE__ */ new Date(day.date + "T00:00:00");
      const dateStr = formatDate(date, "long");
      const itemDiv = container.createDiv({ cls: "tf-future-day-item" });
      itemDiv.createSpan({ cls: "tf-future-day-date", text: dateStr });
      const typeSpan = itemDiv.createSpan({ cls: "tf-future-day-type", text: day.label });
      typeSpan.style.backgroundColor = day.color;
      typeSpan.style.color = day.textColor;
    });
  }
  createMonthGrid(displayDate) {
    var _a;
    const year = displayDate.getFullYear();
    const month = displayDate.getMonth();
    const monthName = getMonthName(displayDate);
    const showWeekNumbers = (_a = this.settings.showWeekNumbers) != null ? _a : true;
    const container = document.createElement("div");
    const monthTitle = document.createElement("div");
    monthTitle.textContent = monthName;
    monthTitle.style.textAlign = "left";
    monthTitle.style.fontWeight = "bold";
    monthTitle.style.marginBottom = "10px";
    container.appendChild(monthTitle);
    const grid = document.createElement("div");
    grid.className = showWeekNumbers ? "tf-month-grid with-week-numbers" : "tf-month-grid";
    if (showWeekNumbers) {
      const weekHeader = document.createElement("div");
      weekHeader.className = "tf-week-number-header";
      weekHeader.textContent = t("ui.week");
      grid.appendChild(weekHeader);
    }
    const dayNames = getDayNamesShort();
    dayNames.forEach((name) => {
      const header = document.createElement("div");
      header.textContent = name;
      header.style.textAlign = "center";
      header.style.fontWeight = "bold";
      header.style.fontSize = "12px";
      header.style.color = "var(--text-muted)";
      grid.appendChild(header);
    });
    const firstDay = new Date(year, month, 1);
    let firstDayOfWeek = firstDay.getDay() - 1;
    if (firstDayOfWeek === -1)
      firstDayOfWeek = 6;
    if (showWeekNumbers) {
      const weekNumCell = document.createElement("div");
      const dayOfWeek = firstDay.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const mondayOfWeek = new Date(firstDay);
      mondayOfWeek.setDate(firstDay.getDate() - daysFromMonday);
      const complianceClass = this.getWeekComplianceClass(mondayOfWeek);
      weekNumCell.className = `tf-week-number-cell ${complianceClass}`;
      weekNumCell.textContent = Utils.getWeekNumber(firstDay).toString();
      if (complianceClass && complianceClass !== "week-future") {
        weekNumCell.style.cursor = "pointer";
        const monday = new Date(mondayOfWeek);
        weekNumCell.onclick = (e) => {
          e.stopPropagation();
          this.showWeekCompliancePanel(weekNumCell.getBoundingClientRect(), monday);
        };
      }
      grid.appendChild(weekNumCell);
    }
    for (let i = 0; i < firstDayOfWeek; i++) {
      const emptyCell = document.createElement("div");
      grid.appendChild(emptyCell);
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const todayKey = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    let gridPosition = firstDayOfWeek;
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = Utils.toLocalDateStr(date);
      if (showWeekNumbers && day > 1 && date.getDay() === 1) {
        const weekNumCell = document.createElement("div");
        const complianceClass = this.getWeekComplianceClass(date);
        weekNumCell.className = `tf-week-number-cell ${complianceClass}`;
        weekNumCell.textContent = Utils.getWeekNumber(date).toString();
        if (complianceClass && complianceClass !== "week-future") {
          weekNumCell.style.cursor = "pointer";
          const monday = new Date(date);
          weekNumCell.onclick = (e) => {
            e.stopPropagation();
            this.showWeekCompliancePanel(weekNumCell.getBoundingClientRect(), monday);
          };
        }
        grid.appendChild(weekNumCell);
      }
      const cell = document.createElement("div");
      cell.className = "tf-day-cell";
      cell.textContent = day.toString();
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      const dayEntries = this.data.daily[dateKey];
      const specialDayColors = getSpecialDayColors(this.settings);
      const specialDayTextColors = getSpecialDayTextColors(this.settings);
      const specialEntry = dayEntries == null ? void 0 : dayEntries.find((e) => {
        const entryName = e.name.toLowerCase();
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === entryName);
        return specialDayColors[entryName] && (!behavior || !behavior.isWorkType);
      });
      const hasEntry = !!(holidayInfo || specialEntry || dayEntries);
      if (holidayInfo) {
        const colorKey = holidayInfo.halfDay ? "halfday" : holidayInfo.type;
        cell.style.background = specialDayColors[colorKey] || specialDayColors[holidayInfo.type] || "var(--background-secondary)";
        cell.style.color = specialDayTextColors[colorKey] || specialDayTextColors[holidayInfo.type] || "var(--text-normal)";
      } else if (specialEntry) {
        const entryKey = specialEntry.name.toLowerCase();
        cell.style.background = specialDayColors[entryKey];
        cell.style.color = specialDayTextColors[entryKey] || "var(--text-normal)";
      } else if (dayEntries) {
        if (!this.settings.enableGoalTracking) {
          const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
          cell.style.background = (workType == null ? void 0 : workType.simpleColor) || "#90caf9";
          cell.style.color = (workType == null ? void 0 : workType.simpleTextColor) || "#000000";
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.style.background = this.flextimeColor(dayFlextime);
          cell.style.color = this.flextimeTextColor(dayFlextime);
        }
      } else if (Utils.isWeekend(date, this.settings)) {
        cell.style.background = "var(--background-modifier-border)";
      } else {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (cellDate < today) {
          cell.style.background = "var(--background-secondary)";
        } else {
          cell.style.background = "transparent";
        }
      }
      if (hasEntry) {
        cell.classList.add("has-entry");
      } else {
        cell.classList.add("no-entry");
        cell.style.color = "var(--text-muted)";
      }
      if (dateKey === todayKey) {
        cell.classList.add("today");
      }
      const hasActiveEntry = dayEntries == null ? void 0 : dayEntries.some((e) => !e.endTime);
      if (hasActiveEntry) {
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.top = "4px";
        indicator.style.right = "4px";
        indicator.style.width = "8px";
        indicator.style.height = "8px";
        indicator.style.borderRadius = "50%";
        indicator.style.background = "#ffffff";
        indicator.style.border = "2px solid #333333";
        indicator.style.animation = "pulse 2s infinite";
        indicator.style.boxShadow = "0 0 4px rgba(0, 0, 0, 0.4)";
        cell.appendChild(indicator);
      }
      cell.onclick = (e) => {
        e.stopPropagation();
        const cellRect = cell.getBoundingClientRect();
        this.showNoteTypeMenu(cellRect, date);
      };
      grid.appendChild(cell);
    }
    container.appendChild(grid);
    return container;
  }
  flextimeColor(val) {
    var _a, _b, _c;
    const jobbBehavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.id === "jobb");
    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 128, g: 128, b: 128 };
    };
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const baseWorkday = this.settings.baseWorkday * this.settings.workPercent;
    const scale = Math.max(dailyLimit - baseWorkday, 0.5);
    if (val < 0) {
      const baseColor = (jobbBehavior == null ? void 0 : jobbBehavior.negativeColor) || "#64b5f6";
      const rgb = hexToRgb(baseColor);
      const t2 = Math.min(Math.abs(val) / scale, 1);
      const lightFactor = (1 - t2) * 0.4;
      const r = Math.floor(rgb.r + (255 - rgb.r) * lightFactor);
      const g = Math.floor(rgb.g + (255 - rgb.g) * lightFactor);
      const b = Math.floor(rgb.b + (255 - rgb.b) * lightFactor);
      return `rgb(${r},${g},${b})`;
    } else {
      const baseColor = (jobbBehavior == null ? void 0 : jobbBehavior.color) || "#4caf50";
      const rgb = hexToRgb(baseColor);
      const t2 = Math.min(val / scale, 1);
      const lightFactor = (1 - t2) * 0.4;
      const r = Math.floor(rgb.r + (255 - rgb.r) * lightFactor);
      const g = Math.floor(rgb.g + (255 - rgb.g) * lightFactor);
      const b = Math.floor(rgb.b + (255 - rgb.b) * lightFactor);
      return `rgb(${r},${g},${b})`;
    }
  }
  flextimeTextColor(val) {
    var _a;
    const jobbBehavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.id === "jobb");
    if (val < 0) {
      return (jobbBehavior == null ? void 0 : jobbBehavior.negativeTextColor) || "#000000";
    } else {
      return (jobbBehavior == null ? void 0 : jobbBehavior.textColor) || "#ffffff";
    }
  }
  /**
   * Generate description for a special day behavior based on its flextimeEffect setting
   */
  getFlextimeEffectDescription(behavior) {
    if (behavior.id === "helligdag") {
      return t("info.publicHolidayDesc");
    }
    if (behavior.id === "halfday") {
      const halfDayHours = this.settings.halfDayMode === "percentage" ? this.settings.baseWorkday / 2 : this.settings.halfDayHours;
      const halfDayReduction = this.settings.baseWorkday - halfDayHours;
      return t("info.halfDayDesc").replace("{hours}", halfDayHours.toString()).replace("{reduction}", halfDayReduction.toString());
    }
    switch (behavior.flextimeEffect) {
      case "withdraw":
        return t("info.withdrawFromFlextime");
      case "accumulate":
        return t("info.countsAsFlextime").replace("{hours}", this.settings.baseWorkday.toString());
      case "none":
      default:
        return t("info.noFlextimeEffect");
    }
  }
  /**
   * Check if week compliance indicators should be shown
   */
  shouldShowWeekCompliance() {
    var _a, _b;
    return this.settings.enableGoalTracking && ((_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) != null ? _b : true);
  }
  /**
   * Get the compliance status for a given week
   * Returns: 'ok' (met goal), 'over' (exceeded), 'under' (below goal), 'partial' (incomplete week), 'future', or '' if disabled
   */
  getWeekComplianceClass(mondayOfWeek) {
    if (!this.shouldShowWeekCompliance()) {
      return "";
    }
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const balanceStartDate = /* @__PURE__ */ new Date(this.settings.balanceStartDate + "T00:00:00");
    const sundayOfWeek = new Date(mondayOfWeek);
    sundayOfWeek.setDate(mondayOfWeek.getDate() + 6);
    if (sundayOfWeek < balanceStartDate) {
      return "";
    }
    if (mondayOfWeek > today) {
      return "week-future";
    }
    let totalHours = 0;
    let workDaysInWeek = 0;
    let workDaysPassed = 0;
    for (let i = 0; i < 7; i++) {
      const day = new Date(mondayOfWeek);
      day.setDate(mondayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(day);
      if (day < balanceStartDate) {
        continue;
      }
      const isWorkDay = this.settings.workDays.includes(day.getDay());
      if (isWorkDay) {
        const holidayInfo = this.data.getHolidayInfo(dayKey);
        const behavior = holidayInfo ? this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type) : null;
        const isNoHoursDay = (behavior == null ? void 0 : behavior.noHoursRequired) === true;
        if (!isNoHoursDay) {
          workDaysInWeek++;
          if (day <= today) {
            workDaysPassed++;
          }
        }
      }
      const dayEntries = this.data.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "ferie" && name !== "egenmelding" && name !== "sykemelding" && name !== "velferdspermisjon") {
          totalHours += entry.duration || 0;
        }
      });
    }
    if (workDaysPassed === 0) {
      return "week-future";
    }
    const expectedHoursPerDay = this.settings.baseWorkday;
    const expectedHours = workDaysPassed * expectedHoursPerDay * this.settings.workPercent;
    const tolerance = 0.5;
    if (totalHours >= expectedHours - tolerance && totalHours <= expectedHours + tolerance) {
      return "week-ok";
    } else if (totalHours > expectedHours + tolerance) {
      return "week-over";
    } else if (workDaysPassed < workDaysInWeek && sundayOfWeek >= today) {
      return "week-partial";
    } else {
      return "week-under";
    }
  }
  /**
   * Get detailed week compliance data for popup
   */
  getWeekComplianceData(mondayOfWeek) {
    var _a, _b, _c, _d;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const balanceStartDate = /* @__PURE__ */ new Date(this.settings.balanceStartDate + "T00:00:00");
    const sundayOfWeek = new Date(mondayOfWeek);
    sundayOfWeek.setDate(mondayOfWeek.getDate() + 6);
    let totalHours = 0;
    let workDaysInWeek = 0;
    let workDaysPassed = 0;
    for (let i = 0; i < 7; i++) {
      const day = new Date(mondayOfWeek);
      day.setDate(mondayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(day);
      if (day < balanceStartDate)
        continue;
      const isWorkDay = this.settings.workDays.includes(day.getDay());
      if (isWorkDay) {
        const holidayInfo = this.data.getHolidayInfo(dayKey);
        const behavior = holidayInfo ? this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type) : null;
        const isNoHoursDay = (behavior == null ? void 0 : behavior.noHoursRequired) === true;
        if (!isNoHoursDay) {
          workDaysInWeek++;
          if (day <= today) {
            workDaysPassed++;
          }
        }
      }
      const dayEntries = this.data.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "ferie" && name !== "egenmelding" && name !== "sykemelding" && name !== "velferdspermisjon") {
          totalHours += entry.duration || 0;
        }
      });
    }
    const expectedHoursPerDay = this.settings.baseWorkday;
    const expectedHours = workDaysPassed * expectedHoursPerDay * this.settings.workPercent;
    const isComplete = workDaysPassed >= workDaysInWeek || sundayOfWeek < today;
    let status = "ok";
    const tolerance = 0.5;
    if (totalHours < expectedHours - tolerance) {
      status = isComplete ? "under" : "partial";
    } else if (totalHours > expectedHours + tolerance) {
      status = "over";
    }
    return {
      weekNumber: Utils.getWeekNumber(mondayOfWeek),
      totalHours,
      expectedHours,
      workDaysPassed,
      workDaysInWeek,
      dailyLimit: (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9,
      weeklyLimit: (_d = (_c = this.settings.complianceSettings) == null ? void 0 : _c.weeklyHoursLimit) != null ? _d : 40,
      status,
      isComplete
    };
  }
  /**
   * Show week compliance info panel when clicking on a week number
   */
  showWeekCompliancePanel(cellRect, mondayOfWeek) {
    const existingPanel = document.querySelector(".tf-week-compliance-panel");
    if (existingPanel)
      existingPanel.remove();
    const data = this.getWeekComplianceData(mondayOfWeek);
    const panel = document.createElement("div");
    panel.className = "tf-week-compliance-panel";
    panel.style.cssText = `
			position: fixed;
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 16px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			z-index: 1000;
			min-width: 220px;
			max-width: 300px;
		`;
    let statusIcon = "\u{1F7E9}";
    let statusText = t("status.onTarget");
    let statusColor = "#4caf50";
    if (data.status === "over") {
      statusIcon = "\u{1F7E8}";
      statusText = t("status.overTarget");
      statusColor = "#ff9800";
    } else if (data.status === "under") {
      statusIcon = "\u{1F7E5}";
      statusText = t("status.underTarget");
      statusColor = "#f44336";
    } else if (data.status === "partial") {
      statusIcon = "\u23F3";
      statusText = t("status.inProgress");
      statusColor = "#9e9e9e";
    }
    const diff = data.totalHours - data.expectedHours;
    const diffText = diff >= 0 ? `+${diff.toFixed(1)}` : diff.toFixed(1);
    const headerRow = panel.createDiv();
    headerRow.style.cssText = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;";
    const weekTitle = headerRow.createEl("strong", { text: `${t("ui.week")} ${data.weekNumber}` });
    weekTitle.style.fontSize = "1.1em";
    const statusSpan = headerRow.createSpan({ text: `${statusIcon} ${statusText}` });
    statusSpan.style.cssText = `color: ${statusColor}; font-weight: bold;`;
    const contentDiv = panel.createDiv();
    contentDiv.style.cssText = "display: flex; flex-direction: column; gap: 8px; font-size: 0.9em;";
    const hoursRow = contentDiv.createDiv();
    hoursRow.style.cssText = "display: flex; justify-content: space-between;";
    hoursRow.createSpan({ text: `${t("ui.hoursLogged")}:` });
    hoursRow.createEl("strong", { text: `${data.totalHours.toFixed(1)}t` });
    const expectedRow = contentDiv.createDiv();
    expectedRow.style.cssText = "display: flex; justify-content: space-between;";
    expectedRow.createSpan({ text: `${t("ui.expected")}:` });
    expectedRow.createSpan({ text: `${data.expectedHours.toFixed(1)}t (${data.workDaysPassed}/${data.workDaysInWeek} ${t("ui.days")})` });
    const diffRow = contentDiv.createDiv();
    diffRow.style.cssText = "display: flex; justify-content: space-between; border-top: 1px solid var(--background-modifier-border); padding-top: 8px;";
    diffRow.createSpan({ text: `${t("ui.difference")}:` });
    const diffValue = diffRow.createEl("strong", { text: `${diffText}t` });
    diffValue.style.color = statusColor;
    if (data.totalHours > data.weeklyLimit) {
      const warningDiv = contentDiv.createDiv({ text: `\u26A0\uFE0F ${t("ui.overWeekLimit")} (${data.weeklyLimit}t)` });
      warningDiv.style.cssText = "color: #f44336; margin-top: 4px;";
    }
    panel.style.left = `${cellRect.right + 8}px`;
    panel.style.top = `${cellRect.top}px`;
    document.body.appendChild(panel);
    const panelRect = panel.getBoundingClientRect();
    if (panelRect.right > window.innerWidth - 10) {
      panel.style.left = `${cellRect.left - panelRect.width - 8}px`;
    }
    if (panelRect.bottom > window.innerHeight - 10) {
      panel.style.top = `${window.innerHeight - panelRect.height - 10}px`;
    }
    const closeHandler = (e) => {
      if (!panel.contains(e.target)) {
        panel.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  showNoteTypeMenu(cellRect, dateObj) {
    var _a, _b, _c;
    const existingMenu = document.querySelector(".tf-context-menu");
    if (existingMenu)
      existingMenu.remove();
    const menu = document.createElement("div");
    menu.className = "tf-context-menu";
    const menuMain = document.createElement("div");
    menuMain.className = "tf-context-menu-main";
    let menuLeft = cellRect.right;
    let menuTop = cellRect.top;
    document.body.appendChild(menu);
    const isMobile = window.innerWidth <= 500;
    if (isMobile) {
      menuLeft = 10;
      menu.style.left = `${menuLeft}px`;
      menu.style.right = "10px";
      menu.style.width = "calc(100vw - 20px)";
    } else {
      const menuWidth = 450;
      if (menuLeft + menuWidth > window.innerWidth) {
        menuLeft = cellRect.left - menuWidth;
        if (menuLeft < 10) {
          menuLeft = 10;
        }
      }
      menu.style.left = `${menuLeft}px`;
    }
    setTimeout(() => {
      const menuHeight = menu.offsetHeight;
      if (menuTop + menuHeight > window.innerHeight) {
        menuTop = Math.max(10, window.innerHeight - menuHeight - 10);
      }
      if (menuTop < 10) {
        menuTop = 10;
      }
      menu.style.top = `${menuTop}px`;
    }, 0);
    menu.style.top = `${menuTop}px`;
    const dateStr = Utils.toLocalDateStr(dateObj);
    const dateEntries = this.data.daily[dateStr];
    const hasWorkEntriesInDaily = dateEntries && dateEntries.some((e) => e.name.toLowerCase() === "jobb");
    const hasRunningTimerForDate = this.timerManager.data.entries.some((entry) => {
      if (!entry.startTime || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    const hasWorkEntries = hasWorkEntriesInDaily || hasRunningTimerForDate;
    const workTimeItem = document.createElement("div");
    workTimeItem.className = "tf-menu-item";
    workTimeItem.createSpan({ text: "\u23F1\uFE0F" });
    workTimeItem.createSpan({ text: t("menu.logWork") });
    workTimeItem.onclick = () => {
      menu.remove();
      this.showWorkTimeModal(dateObj);
    };
    menuMain.appendChild(workTimeItem);
    if (hasWorkEntries) {
      const editItem = document.createElement("div");
      editItem.className = "tf-menu-item";
      editItem.createSpan({ text: "\u270F\uFE0F" });
      editItem.createSpan({ text: t("menu.editWork") });
      editItem.onclick = () => {
        menu.remove();
        this.showEditEntriesModal(dateObj);
      };
      menuMain.appendChild(editItem);
    }
    const specialDayItem = document.createElement("div");
    specialDayItem.className = "tf-menu-item";
    specialDayItem.createSpan({ text: "\u{1F4C5}" });
    specialDayItem.createSpan({ text: t("menu.registerSpecialDay") });
    specialDayItem.onclick = () => {
      menu.remove();
      this.showSpecialDayModal(dateObj);
    };
    menuMain.appendChild(specialDayItem);
    const separator1 = document.createElement("div");
    separator1.className = "tf-menu-separator";
    menuMain.appendChild(separator1);
    this.settings.noteTypes.forEach((noteType) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.createSpan({ text: noteType.icon });
      item.createSpan({ text: translateNoteTypeName(noteType.id, noteType.label) });
      item.onclick = async () => {
        await this.createNoteFromType(dateObj, noteType);
        menu.remove();
      };
      menuMain.appendChild(item);
    });
    menu.appendChild(menuMain);
    const menuInfo = document.createElement("div");
    menuInfo.className = "tf-context-menu-info";
    const allEntries = dateEntries || [];
    const plannedInfo = this.data.getHolidayInfo(dateStr);
    const isPlannedDay = plannedInfo !== null;
    const isPastDay = dateObj < /* @__PURE__ */ new Date();
    const isFutureDay = dateObj > /* @__PURE__ */ new Date();
    const runningTimersForDate = this.timerManager.data.entries.filter((entry) => {
      if (!entry.startTime || !entry.endTime === false || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr && !entry.endTime;
    });
    menuInfo.createEl("h4", { text: "\u{1F4C5} " + dateStr });
    if (isPlannedDay && plannedInfo) {
      const emoji = Utils.getEmoji({ name: plannedInfo.type, date: dateObj });
      const halfDayText = plannedInfo.halfDay ? " (halv dag)" : "";
      const plannedP = menuInfo.createEl("p");
      plannedP.createEl("strong", { text: emoji + " " + plannedInfo.description + halfDayText });
    }
    if (runningTimersForDate.length > 0) {
      const timersP = menuInfo.createEl("p");
      timersP.createEl("strong", { text: t("timer.runningTimers") + ":" });
      runningTimersForDate.forEach((timer) => {
        const startTime = new Date(timer.startTime);
        const startTimeStr = `${startTime.getHours().toString().padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;
        const now = /* @__PURE__ */ new Date();
        const elapsed = ((now.getTime() - startTime.getTime()) / (1e3 * 60 * 60)).toFixed(1);
        const timerP = menuInfo.createEl("p", { text: "\u23F1\uFE0F " + timer.name + ": " + startTimeStr + " - P\xE5g\xE5r (" + elapsed + "t)" });
        timerP.style.marginLeft = "8px";
      });
    }
    const completedEntries = allEntries.filter((e) => {
      if (e.duration && e.duration > 0)
        return true;
      const behavior = this.data.getSpecialDayBehavior(e.name);
      return behavior && (behavior.noHoursRequired || behavior.countsAsWorkday);
    });
    if (completedEntries.length > 0) {
      const historyP = menuInfo.createEl("p");
      historyP.createEl("strong", { text: t("ui.history") + ":" });
      completedEntries.forEach((e) => {
        const emoji = Utils.getEmoji(e);
        const behavior = this.data.getSpecialDayBehavior(e.name);
        const isSpecialDay = behavior && (behavior.noHoursRequired || behavior.countsAsWorkday);
        const durationText = e.duration && e.duration > 0 ? `: ${e.duration.toFixed(1)}${this.settings.hourUnit}` : "";
        const entryP = menuInfo.createEl("p", { text: emoji + " " + translateSpecialDayName(e.name.toLowerCase(), e.name) + durationText });
        entryP.style.marginLeft = "8px";
      });
      if (!isFutureDay) {
        const totalHours = allEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
        const dayGoal = this.data.getDailyGoal(dateStr);
        const dailyDelta = dayGoal === 0 ? totalHours : totalHours - dayGoal;
        const runningBalance = this.data.getBalanceUpToDate(dateStr);
        const goalP = menuInfo.createEl("p");
        goalP.style.marginTop = "8px";
        goalP.createEl("strong", { text: t("ui.goal") + ":" });
        goalP.appendText(" " + dayGoal.toFixed(1) + "t");
        const dailyP = menuInfo.createEl("p");
        dailyP.createEl("strong", { text: t("ui.dailyBalance") + ":" });
        dailyP.appendText(" " + (dailyDelta >= 0 ? "+" : "") + dailyDelta.toFixed(1) + "t");
        const balanceP = menuInfo.createEl("p");
        balanceP.createEl("strong", { text: t("ui.runningBalance") + ":" });
        balanceP.appendText(" " + (runningBalance >= 0 ? "+" : "") + Utils.formatHoursToHM(runningBalance, this.settings.hourUnit));
      }
    } else if (isPastDay && !isPlannedDay && runningTimersForDate.length === 0) {
      const noRegP = menuInfo.createEl("p", { text: t("ui.noRegistration") });
      noRegP.style.color = "var(--text-muted)";
    }
    if (((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) && !isFutureDay && completedEntries.length > 0) {
      const restCheck = this.data.checkRestPeriodViolation(dateStr);
      if (restCheck.violated && restCheck.restHours !== null) {
        const minimumRest = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.minimumRestHours) != null ? _c : 11;
        const warningDiv = menuInfo.createDiv({ cls: "tf-rest-period-warning" });
        warningDiv.createSpan({ cls: "warning-icon", text: "\u26A0\uFE0F" });
        warningDiv.createSpan({ text: t("ui.restPeriod") + ": " + restCheck.restHours.toFixed(1) + "h (" + t("ui.minimum") + " " + minimumRest + "h)" });
      }
    }
    const tipP = menuInfo.createEl("p", { text: `\u{1F4A1} ${t("menu.selectOption")}` });
    tipP.style.marginTop = "12px";
    tipP.style.fontSize = "0.8em";
    tipP.style.color = "var(--text-muted)";
    tipP.style.borderTop = "1px solid var(--background-modifier-border)";
    tipP.style.paddingTop = "8px";
    menu.appendChild(menuInfo);
    setTimeout(() => {
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  /**
   * Show confirmation dialog for overnight shift detection.
   */
  showOvernightShiftConfirmation(onConfirm) {
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1001";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "350px";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = t("confirm.overnightShiftTitle");
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const message = document.createElement("p");
    message.textContent = t("confirm.overnightShift");
    content.appendChild(message);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "15px";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const confirmBtn = document.createElement("button");
    confirmBtn.textContent = t("buttons.confirm");
    confirmBtn.className = "mod-cta";
    confirmBtn.onclick = () => {
      modal.remove();
      onConfirm();
    };
    buttonDiv.appendChild(confirmBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  /**
   * Check if a new/edited entry would create a prohibited overlap.
   * Blocks: same-type overlaps AND overlaps between accumulate-type entries.
   */
  checkProhibitedOverlap(dateStr, entryType, startTime, endTime, excludeEntry) {
    const newBehavior = this.settings.specialDayBehaviors.find((b) => b.id === entryType.toLowerCase());
    const newIsAccumulate = (newBehavior == null ? void 0 : newBehavior.flextimeEffect) === "accumulate";
    const dayEntries = this.timerManager.data.entries.filter((e) => {
      if (e === excludeEntry)
        return false;
      if (!e.startTime || !e.endTime)
        return false;
      return Utils.toLocalDateStr(new Date(e.startTime)) === dateStr;
    });
    for (const entry of dayEntries) {
      const existingStart = new Date(entry.startTime);
      const existingEnd = new Date(entry.endTime);
      if (startTime < existingEnd && endTime > existingStart) {
        const existingType = entry.name.toLowerCase();
        const existingBehavior = this.settings.specialDayBehaviors.find((b) => b.id === existingType);
        const existingIsAccumulate = (existingBehavior == null ? void 0 : existingBehavior.flextimeEffect) === "accumulate";
        if (entryType.toLowerCase() === existingType)
          return true;
        if (newIsAccumulate && existingIsAccumulate)
          return true;
      }
    }
    return false;
  }
  showWorkTimeModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.logWorkTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const startLabel = document.createElement("div");
    startLabel.textContent = t("modals.startTimeFormat");
    startLabel.style.marginBottom = "5px";
    startLabel.style.fontWeight = "bold";
    content.appendChild(startLabel);
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.value = "08:00";
    startInput.placeholder = "HH:MM";
    startInput.style.width = "100%";
    startInput.style.marginBottom = "15px";
    startInput.style.padding = "8px";
    startInput.style.fontSize = "14px";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = t("modals.endTimeFormat");
    endLabel.style.marginBottom = "5px";
    endLabel.style.fontWeight = "bold";
    content.appendChild(endLabel);
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.value = "15:30";
    endInput.placeholder = "HH:MM";
    endInput.style.width = "100%";
    endInput.style.marginBottom = "20px";
    endInput.style.padding = "8px";
    endInput.style.fontSize = "14px";
    content.appendChild(endInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = t("buttons.add");
    addBtn.className = "mod-cta";
    addBtn.onclick = () => {
      const startTime = startInput.value.trim();
      const endTime = endInput.value.trim();
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
        new import_obsidian4.Notice("\u274C Ugyldig tidsformat. Bruk HH:MM format.");
        return;
      }
      const [startHour, startMin] = startTime.split(":").map(Number);
      const [endHour, endMin] = endTime.split(":").map(Number);
      const startDate = new Date(dateObj);
      startDate.setHours(startHour, startMin, 0, 0);
      const endDate = new Date(dateObj);
      endDate.setHours(endHour, endMin, 0, 0);
      const addEntry = async (finalEndDate) => {
        if (this.checkProhibitedOverlap(dateStr, "jobb", startDate, finalEndDate)) {
          new import_obsidian4.Notice(`\u274C ${t("validation.overlappingEntry")}`);
          return;
        }
        try {
          this.timerManager.data.entries.push({
            name: "jobb",
            startTime: startDate.toISOString(),
            endTime: finalEndDate.toISOString(),
            subEntries: null,
            collapsed: false
          });
          await this.saveWithErrorHandling();
          const duration = (finalEndDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
          new import_obsidian4.Notice(`\u2705 Lagt til ${duration.toFixed(1)} timer arbeidstid for ${dateStr}`);
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          this.isModalOpen = false;
          modal.remove();
        } catch (error) {
          console.error("Failed to add work time:", error);
          new import_obsidian4.Notice("\u274C Kunne ikke legge til arbeidstid");
        }
      };
      if (endDate <= startDate) {
        this.showOvernightShiftConfirmation(() => {
          const nextDayEndDate = new Date(endDate);
          nextDayEndDate.setDate(nextDayEndDate.getDate() + 1);
          addEntry(nextDayEndDate);
        });
      } else {
        addEntry(endDate);
      }
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    startInput.focus();
    startInput.select();
  }
  showEditEntriesModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const allEntries = this.timerManager.data.entries;
    const workEntries = [];
    allEntries.forEach((entry) => {
      if (entry.collapsed && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub, idx) => {
          if (sub.startTime) {
            const entryDate = new Date(sub.startTime);
            if (Utils.toLocalDateStr(entryDate) === dateStr) {
              workEntries.push({ entry: sub, parent: entry, subIndex: idx });
            }
          }
        });
      } else if (entry.startTime) {
        const entryDate = new Date(entry.startTime);
        if (Utils.toLocalDateStr(entryDate) === dateStr) {
          workEntries.push({ entry });
        }
      }
    });
    if (workEntries.length === 0) {
      new import_obsidian4.Notice("Ingen arbeidstidsoppf\xF8ringer funnet for denne datoen");
      return;
    }
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "500px";
    modalContent.style.maxHeight = "80vh";
    modalContent.style.overflow = "auto";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.editWorkTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    workEntries.forEach((item, index) => {
      const entry = item.entry;
      const entryDiv = document.createElement("div");
      entryDiv.style.padding = "15px";
      entryDiv.style.marginBottom = "10px";
      entryDiv.style.background = "var(--background-secondary)";
      entryDiv.style.borderRadius = "8px";
      entryDiv.style.border = "1px solid var(--background-modifier-border)";
      const startDate = new Date(entry.startTime);
      const endDate = entry.endTime ? new Date(entry.endTime) : null;
      const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
      const endTimeStr = endDate ? `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}` : t("ui.ongoing");
      const startDateStr = Utils.toLocalDateStr(startDate);
      const endDateStr = endDate ? Utils.toLocalDateStr(endDate) : null;
      const isMultiDay = endDate && startDateStr !== endDateStr;
      const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(1) : "N/A";
      const infoDiv = document.createElement("div");
      infoDiv.style.marginBottom = "10px";
      const entryLabel = item.parent ? `${item.parent.name} - ${entry.name}` : `Oppf\xF8ring ${index + 1}`;
      const titleDiv = infoDiv.createDiv({ text: entryLabel });
      titleDiv.style.cssText = "font-weight: bold; margin-bottom: 5px;";
      const timeDisplay = isMultiDay ? `\u23F0 ${startDateStr} ${startTimeStr} \u2192 ${endDateStr} ${endTimeStr}` : `\u23F0 ${startTimeStr} - ${endTimeStr}`;
      infoDiv.createDiv({ text: timeDisplay });
      infoDiv.createDiv({ text: `\u23F1\uFE0F ${duration} timer` });
      entryDiv.appendChild(infoDiv);
      const editDiv = document.createElement("div");
      editDiv.style.display = "none";
      editDiv.style.marginTop = "10px";
      const startLabel = document.createElement("div");
      startLabel.textContent = `${t("modals.startTime")}:`;
      startLabel.style.marginBottom = "5px";
      startLabel.style.fontWeight = "bold";
      editDiv.appendChild(startLabel);
      const startRow = document.createElement("div");
      startRow.style.display = "flex";
      startRow.style.gap = "8px";
      startRow.style.marginBottom = "10px";
      const startDateInput = document.createElement("input");
      startDateInput.type = "date";
      startDateInput.value = startDateStr;
      startDateInput.style.flex = "1";
      startDateInput.style.padding = "6px";
      startRow.appendChild(startDateInput);
      const startTimeInput = this.createTimeInput(startTimeStr, () => {
      });
      startTimeInput.style.flex = "1";
      startTimeInput.style.padding = "6px";
      startRow.appendChild(startTimeInput);
      editDiv.appendChild(startRow);
      const endLabel = document.createElement("div");
      endLabel.textContent = `${t("modals.endTime")}:`;
      endLabel.style.marginBottom = "5px";
      endLabel.style.fontWeight = "bold";
      editDiv.appendChild(endLabel);
      const endRow = document.createElement("div");
      endRow.style.display = "flex";
      endRow.style.gap = "8px";
      endRow.style.marginBottom = "10px";
      const endDateInput = document.createElement("input");
      endDateInput.type = "date";
      endDateInput.value = endDateStr || startDateStr;
      endDateInput.style.flex = "1";
      endDateInput.style.padding = "6px";
      endRow.appendChild(endDateInput);
      const endTimeInput = this.createTimeInput(endTimeStr !== t("ui.ongoing") ? endTimeStr : "", () => {
      });
      endTimeInput.style.flex = "1";
      endTimeInput.style.padding = "6px";
      endRow.appendChild(endTimeInput);
      editDiv.appendChild(endRow);
      entryDiv.appendChild(editDiv);
      const buttonDiv = document.createElement("div");
      buttonDiv.style.display = "flex";
      buttonDiv.style.gap = "8px";
      buttonDiv.style.marginTop = "10px";
      const editBtn = document.createElement("button");
      editBtn.textContent = `\u270F\uFE0F ${t("buttons.edit")}`;
      editBtn.style.flex = "1";
      editBtn.onclick = () => {
        if (editDiv.style.display === "none") {
          editDiv.style.display = "block";
          editBtn.textContent = `\u{1F4BE} ${t("buttons.save")}`;
        } else {
          const newStartDateValue = startDateInput.value;
          const newStartTimeValue = startTimeInput.value;
          const newEndDateValue = endDateInput.value;
          const newEndTimeValue = endTimeInput.value;
          if (!newStartDateValue || !newStartTimeValue) {
            new import_obsidian4.Notice("\u274C Starttid m\xE5 fylles ut");
            return;
          }
          const newStartDate = /* @__PURE__ */ new Date(`${newStartDateValue}T${newStartTimeValue}:00`);
          if (isNaN(newStartDate.getTime())) {
            new import_obsidian4.Notice("\u274C Ugyldig startdato/tid");
            return;
          }
          const saveUpdate = async (finalEndDate) => {
            if (finalEndDate) {
              const checkDateStr = Utils.toLocalDateStr(newStartDate);
              if (this.checkProhibitedOverlap(checkDateStr, entry.name, newStartDate, finalEndDate, entry)) {
                new import_obsidian4.Notice(`\u274C ${t("validation.overlappingEntry")}`);
                return;
              }
            }
            entry.startTime = Utils.toLocalISOString(newStartDate);
            entry.endTime = finalEndDate ? Utils.toLocalISOString(finalEndDate) : null;
            await this.saveWithErrorHandling();
            new import_obsidian4.Notice("\u2705 Oppf\xF8ring oppdatert");
            this.data.rawEntries = this.timerManager.convertToTimeEntries();
            this.data.processEntries();
            this.updateDayCard();
            this.updateWeekCard();
            this.updateStatsCard();
            this.updateMonthCard();
            this.isModalOpen = false;
            modal.remove();
          };
          if (newEndTimeValue) {
            const newEndDate = /* @__PURE__ */ new Date(`${newEndDateValue}T${newEndTimeValue}:00`);
            if (isNaN(newEndDate.getTime())) {
              new import_obsidian4.Notice("\u274C Ugyldig sluttdato/tid");
              return;
            }
            if (newEndDate <= newStartDate) {
              new import_obsidian4.Notice("\u274C Sluttid m\xE5 v\xE6re etter starttid");
              return;
            }
            saveUpdate(newEndDate);
          } else {
            saveUpdate(null);
          }
        }
      };
      buttonDiv.appendChild(editBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = `\u{1F5D1}\uFE0F ${t("buttons.delete")}`;
      deleteBtn.style.flex = "1";
      deleteBtn.onclick = () => {
        this.showDeleteConfirmation(entry, dateObj, async () => {
          let deleted = false;
          if (item.parent && item.subIndex !== void 0) {
            if (item.parent.subEntries) {
              item.parent.subEntries.splice(item.subIndex, 1);
              if (item.parent.subEntries.length === 0) {
                const parentIndex = this.timerManager.data.entries.indexOf(item.parent);
                if (parentIndex > -1) {
                  this.timerManager.data.entries.splice(parentIndex, 1);
                }
              }
              deleted = true;
            }
          } else {
            const entryIndex = this.timerManager.data.entries.indexOf(entry);
            if (entryIndex > -1) {
              this.timerManager.data.entries.splice(entryIndex, 1);
              deleted = true;
            }
          }
          if (deleted) {
            await this.saveWithErrorHandling();
            new import_obsidian4.Notice("\u2705 Oppf\xF8ring slettet");
            this.data.rawEntries = this.timerManager.convertToTimeEntries();
            this.data.processEntries();
            this.updateDayCard();
            this.updateWeekCard();
            this.updateStatsCard();
            this.updateMonthCard();
            this.isModalOpen = false;
            modal.remove();
          }
        });
      };
      buttonDiv.appendChild(deleteBtn);
      entryDiv.appendChild(buttonDiv);
      content.appendChild(entryDiv);
    });
    const closeDiv = document.createElement("div");
    closeDiv.style.marginTop = "20px";
    closeDiv.style.display = "flex";
    closeDiv.style.justifyContent = "flex-end";
    const closeBtn = document.createElement("button");
    closeBtn.textContent = t("buttons.close");
    closeBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    closeDiv.appendChild(closeBtn);
    content.appendChild(closeDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  showSpecialDayModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = t("modals.registerSpecialDayTitle");
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const dateDisplay = document.createElement("div");
    dateDisplay.textContent = `${t("ui.date")}: ${dateStr}`;
    dateDisplay.style.marginBottom = "15px";
    dateDisplay.style.fontSize = "16px";
    dateDisplay.style.fontWeight = "bold";
    content.appendChild(dateDisplay);
    const typeLabel = document.createElement("div");
    typeLabel.textContent = t("modals.dayType");
    typeLabel.style.marginBottom = "5px";
    typeLabel.style.fontWeight = "bold";
    content.appendChild(typeLabel);
    const dayTypes = this.settings.specialDayBehaviors.filter((behavior) => !behavior.isWorkType).map((behavior) => ({
      type: behavior.id,
      label: `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`
    }));
    const typeSelect = document.createElement("select");
    typeSelect.style.width = "100%";
    typeSelect.style.marginBottom = "15px";
    typeSelect.style.padding = "8px";
    typeSelect.style.fontSize = "14px";
    dayTypes.forEach(({ type, label }) => {
      const option = document.createElement("option");
      option.value = type;
      option.textContent = label;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const timeContainer = document.createElement("div");
    timeContainer.style.marginBottom = "15px";
    timeContainer.style.display = "none";
    const timeLabel = document.createElement("div");
    timeLabel.textContent = "Tidsperiode:";
    timeLabel.style.marginBottom = "5px";
    timeLabel.style.fontWeight = "bold";
    timeContainer.appendChild(timeLabel);
    const timeInputRow = document.createElement("div");
    timeInputRow.style.display = "flex";
    timeInputRow.style.gap = "10px";
    timeInputRow.style.alignItems = "center";
    const fromLabel = document.createElement("span");
    fromLabel.textContent = "Fra:";
    timeInputRow.appendChild(fromLabel);
    const workdayHours = this.settings.baseWorkday * this.settings.workPercent;
    const defaultEndHour = 8 + workdayHours;
    const endH = Math.floor(defaultEndHour);
    const endM = Math.round((defaultEndHour - endH) * 60);
    const defaultEndTime = `${endH.toString().padStart(2, "0")}:${endM.toString().padStart(2, "0")}`;
    const fromTimeInput = this.createTimeInput("08:00", () => {
    });
    fromTimeInput.style.padding = "8px";
    fromTimeInput.style.fontSize = "14px";
    timeInputRow.appendChild(fromTimeInput);
    const toLabel = document.createElement("span");
    toLabel.textContent = "Til:";
    timeInputRow.appendChild(toLabel);
    const toTimeInput = this.createTimeInput(defaultEndTime, () => {
    });
    toTimeInput.style.padding = "8px";
    toTimeInput.style.fontSize = "14px";
    timeInputRow.appendChild(toTimeInput);
    timeContainer.appendChild(timeInputRow);
    const durationDisplay = document.createElement("div");
    durationDisplay.style.fontSize = "12px";
    durationDisplay.style.color = "var(--text-muted)";
    durationDisplay.style.marginTop = "8px";
    const updateDuration = () => {
      const from = fromTimeInput.value;
      const to = toTimeInput.value;
      if (from && to) {
        const [fH, fM] = from.split(":").map(Number);
        const [tH, tM] = to.split(":").map(Number);
        const hours = tH + tM / 60 - (fH + fM / 60);
        if (hours > 0) {
          durationDisplay.textContent = `Varighet: ${hours.toFixed(1)} timer`;
        } else {
          durationDisplay.textContent = "Ugyldig tidsperiode";
        }
      }
    };
    updateDuration();
    fromTimeInput.addEventListener("change", updateDuration);
    toTimeInput.addEventListener("change", updateDuration);
    timeContainer.appendChild(durationDisplay);
    content.appendChild(timeContainer);
    typeSelect.addEventListener("change", () => {
      timeContainer.style.display = typeSelect.value === "avspasering" ? "block" : "none";
    });
    const noteLabel = document.createElement("div");
    noteLabel.textContent = t("modals.commentOptional");
    noteLabel.style.marginBottom = "5px";
    noteLabel.style.fontWeight = "bold";
    content.appendChild(noteLabel);
    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.placeholder = t("modals.commentPlaceholder");
    noteInput.style.width = "100%";
    noteInput.style.marginBottom = "20px";
    noteInput.style.padding = "8px";
    noteInput.style.fontSize = "14px";
    content.appendChild(noteInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = t("buttons.add");
    addBtn.className = "mod-cta";
    addBtn.onclick = async () => {
      const dayType = typeSelect.value;
      const note = noteInput.value.trim();
      const startTime = dayType === "avspasering" ? fromTimeInput.value : void 0;
      const endTime = dayType === "avspasering" ? toTimeInput.value : void 0;
      await this.addSpecialDay(dateObj, dayType, note, startTime, endTime);
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    typeSelect.focus();
  }
  async addSpecialDay(dateObj, dayType, note = "", startTime, endTime) {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        new import_obsidian4.Notice(`\u274C Fant ikke filen: ${filePath}`);
        return;
      }
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      const dateStr = `${year}-${month}-${day}`;
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian4.Notice('\u274C Fant ikke seksjonen "Planlagte egne fridager"');
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian4.Notice("\u274C Fant ikke kodeblokk i seksjonen");
        return;
      }
      let typeWithModifier = dayType;
      if (dayType === "avspasering" && startTime && endTime) {
        typeWithModifier = `${dayType}:${startTime}-${endTime}`;
      }
      const newEntry = `- ${dateStr}: ${typeWithModifier}: ${note}`;
      const beforeClosing = content.substring(0, codeBlockEnd);
      const afterClosing = content.substring(codeBlockEnd);
      const needsNewline = !beforeClosing.endsWith("\n");
      content = beforeClosing + (needsNewline ? "\n" : "") + newEntry + "\n" + afterClosing;
      await this.app.vault.modify(file, content);
      const label = translateSpecialDayName(dayType);
      new import_obsidian4.Notice(`\u2705 ${t("notifications.added")} ${dateStr} (${label})`);
      await this.data.loadHolidays();
      this.updateMonthCard();
    } catch (error) {
      console.error("Failed to add special day:", error);
      new import_obsidian4.Notice("\u274C Kunne ikke legge til spesialdag");
    }
  }
  async createNoteFromType(dateObj, noteType) {
    try {
      const dateStr = Utils.toLocalDateStr(dateObj);
      const weekNum = Utils.getWeekNumber(dateObj);
      let filename = noteType.filenamePattern.replace("{YYYY}", dateObj.getFullYear().toString()).replace("{MM}", (dateObj.getMonth() + 1).toString().padStart(2, "0")).replace("{DD}", dateObj.getDate().toString().padStart(2, "0")).replace("{WEEK}", weekNum.toString());
      const filePath = `${noteType.folder}/${filename}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        await this.app.workspace.getLeaf(false).openFile(existingFile);
        new import_obsidian4.Notice(`Opened existing note: ${filename}`);
        return;
      }
      const folderPath = noteType.folder;
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      let content = "";
      const templateFile = this.app.vault.getAbstractFileByPath(noteType.template);
      if (templateFile && templateFile instanceof import_obsidian4.TFile) {
        content = await this.app.vault.read(templateFile);
      }
      content = content.replace(/{date}/g, dateStr).replace(/{time}/g, (/* @__PURE__ */ new Date()).toLocaleTimeString("nb-NO")).replace(/{week}/g, weekNum.toString());
      if (noteType.tags && noteType.tags.length > 0) {
        content += `

${noteType.tags.join(" ")}`;
      }
      const file = await this.app.vault.create(filePath, content);
      await this.app.workspace.getLeaf(false).openFile(file);
      new import_obsidian4.Notice(`Created note: ${filename}`);
    } catch (error) {
      new import_obsidian4.Notice(`Error creating note: ${error.message}`);
      console.error("Error creating note:", error);
    }
  }
  refreshHistoryView(container) {
    container.empty();
    const activeEntries = [];
    const years = {};
    Object.keys(this.data.daily).sort().reverse().forEach((dateKey) => {
      const year = dateKey.split("-")[0];
      if (!years[year])
        years[year] = {};
      const month = dateKey.split("-")[1];
      if (!years[year][month])
        years[year][month] = [];
      const dayEntries = this.data.daily[dateKey];
      dayEntries.forEach((entry) => {
        if (this.historyView === "list" && this.historyFilter.length > 0) {
          const entryType = entry.name.toLowerCase();
          if (!this.historyFilter.includes(entryType)) {
            return;
          }
        }
        if (entry.isActive && this.historyView === "list") {
          activeEntries.push(entry);
        } else {
          years[year][month].push(entry);
        }
      });
    });
    Object.keys(years).forEach((year) => {
      Object.keys(years[year]).forEach((month) => {
        if (years[year][month].length === 0) {
          delete years[year][month];
        }
      });
      if (Object.keys(years[year]).length === 0) {
        delete years[year];
      }
    });
    if (this.historyView === "list") {
      this.renderListView(container, years, activeEntries);
    } else if (this.historyView === "weekly") {
      this.renderWeeklyView(container, years);
    } else if (this.historyView === "heatmap") {
      this.renderHeatmapView(container, years);
    }
    this.updateEditToggleVisibility(container);
  }
  updateEditToggleVisibility(container) {
    const historyCard = container.closest(".tf-card-history");
    if (!historyCard)
      return;
    const editToggle = historyCard._editToggle;
    if (!editToggle)
      return;
    const isWide = container.offsetWidth >= 450;
    const isListView = this.historyView === "list";
    editToggle.style.display = isWide && isListView ? "block" : "none";
    editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
    editToggle.classList.toggle("active", this.inlineEditMode);
  }
  renderListView(container, years, activeEntries = []) {
    this.renderFilterBar(container);
    if (activeEntries.length > 0) {
      this.renderActiveEntriesSection(container, activeEntries);
    }
    const isWide = container.offsetWidth >= 450;
    if (isWide) {
      this.renderWideListView(container, years);
    } else {
      this.renderNarrowListView(container, years);
    }
    requestAnimationFrame(() => {
      const actualWidth = container.offsetWidth;
      const shouldBeWide = actualWidth >= 450;
      if (shouldBeWide !== isWide) {
        container.empty();
        this.renderFilterBar(container);
        if (activeEntries.length > 0) {
          this.renderActiveEntriesSection(container, activeEntries);
        }
        if (shouldBeWide) {
          this.renderWideListView(container, years);
        } else {
          this.renderNarrowListView(container, years);
        }
      }
    });
  }
  renderFilterBar(container) {
    const filterBar = document.createElement("div");
    filterBar.className = "tf-history-filters";
    const alleChip = document.createElement("button");
    alleChip.className = `tf-filter-chip ${this.historyFilter.length === 0 ? "active" : ""}`;
    alleChip.textContent = t("ui.all");
    alleChip.onclick = () => {
      this.historyFilter = [];
      this.refreshHistoryView(container);
    };
    filterBar.appendChild(alleChip);
    this.settings.specialDayBehaviors.forEach((behavior) => {
      const chip = document.createElement("button");
      const isActive = this.historyFilter.includes(behavior.id);
      chip.className = `tf-filter-chip ${isActive ? "active" : ""}`;
      chip.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
      chip.onclick = () => {
        if (isActive) {
          this.historyFilter = this.historyFilter.filter((f) => f !== behavior.id);
        } else {
          this.historyFilter = [...this.historyFilter, behavior.id];
        }
        this.refreshHistoryView(container);
      };
      filterBar.appendChild(chip);
    });
    container.appendChild(filterBar);
  }
  renderActiveEntriesSection(container, activeEntries) {
    const section = document.createElement("div");
    section.className = "tf-active-entries-section";
    section.style.marginBottom = "16px";
    section.style.padding = "12px";
    section.style.backgroundColor = "var(--background-secondary)";
    section.style.borderRadius = "8px";
    section.style.border = "2px solid var(--interactive-accent)";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    header.style.marginBottom = "10px";
    header.style.fontWeight = "bold";
    header.style.color = "var(--text-normal)";
    header.innerHTML = `\u23F1\uFE0F ${t("ui.activeTimers")} (${activeEntries.length})`;
    section.appendChild(header);
    const isWide = container.offsetWidth >= 450;
    const table = document.createElement("table");
    table.className = isWide ? "tf-history-table-wide" : "tf-history-table-narrow";
    table.style.width = "100%";
    const rawEntries = this.timerManager.data.entries;
    const flatRawEntries = [];
    rawEntries.forEach((entry) => {
      if (entry.collapsed && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub, idx) => {
          if (sub.startTime) {
            flatRawEntries.push({ entry: sub, parent: entry, subIndex: idx });
          }
        });
      } else if (entry.startTime) {
        flatRawEntries.push({ entry });
      }
    });
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    const headers = isWide ? this.inlineEditMode ? [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.hours"), t("ui.flextime"), ""] : [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.hours"), t("ui.flextime")] : [t("ui.date"), t("ui.type"), t("ui.hours"), ""];
    headers.forEach((h) => {
      const th = document.createElement("th");
      th.textContent = h;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    activeEntries.forEach((e) => {
      const row = document.createElement("tr");
      row.style.fontStyle = "italic";
      row.style.opacity = "0.8";
      const dateStr = Utils.toLocalDateStr(e.date);
      const matchingItem = flatRawEntries.find(
        (item) => item.entry.name.toLowerCase() === e.name.toLowerCase() && !item.entry.endTime && Utils.toLocalDateStr(new Date(item.entry.startTime)) === dateStr
      );
      const matchingRaw = matchingItem == null ? void 0 : matchingItem.entry;
      const dateCell = document.createElement("td");
      const activeIcon = document.createElement("span");
      activeIcon.textContent = "\u23F1\uFE0F ";
      activeIcon.title = t("ui.activeTimer");
      activeIcon.style.cursor = "help";
      dateCell.appendChild(activeIcon);
      dateCell.appendChild(document.createTextNode(dateStr));
      row.appendChild(dateCell);
      const typeCell = document.createElement("td");
      if (isWide && this.inlineEditMode && matchingRaw) {
        const select = document.createElement("select");
        this.settings.specialDayBehaviors.forEach((behavior) => {
          const option = document.createElement("option");
          option.value = behavior.id;
          option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
          if (behavior.id === e.name.toLowerCase()) {
            option.selected = true;
          }
          select.appendChild(option);
        });
        select.onchange = async () => {
          var _a, _b;
          matchingRaw.name = select.value;
          await this.saveWithErrorHandling();
          await ((_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a));
        };
        typeCell.appendChild(select);
      } else {
        typeCell.textContent = translateSpecialDayName(e.name.toLowerCase(), e.name);
      }
      row.appendChild(typeCell);
      if (isWide) {
        const startCell = document.createElement("td");
        if (matchingRaw == null ? void 0 : matchingRaw.startTime) {
          const startDate = new Date(matchingRaw.startTime);
          const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
          if (this.inlineEditMode) {
            const input = this.createTimeInput(startTimeStr, async (newValue) => {
              var _a, _b;
              const parsed = this.parseTimeInput(newValue);
              if (!parsed)
                return;
              const newStart = new Date(matchingRaw.startTime);
              newStart.setHours(parsed.hours, parsed.minutes, 0, 0);
              matchingRaw.startTime = Utils.toLocalISOString(newStart);
              await this.saveWithErrorHandling();
              await ((_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a));
            });
            startCell.appendChild(input);
          } else {
            startCell.textContent = startTimeStr;
          }
        } else {
          startCell.textContent = "-";
        }
        row.appendChild(startCell);
      }
      const hoursCell = document.createElement("td");
      const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
      hoursCell.textContent = `${hoursText}...`;
      row.appendChild(hoursCell);
      if (isWide) {
        const flextimeCell = document.createElement("td");
        flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
        row.appendChild(flextimeCell);
      }
      if (isWide && this.inlineEditMode) {
        const actionCell = document.createElement("td");
        if (matchingItem) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "tf-history-delete-btn";
          deleteBtn.textContent = "\u{1F5D1}\uFE0F";
          deleteBtn.title = t("menu.deleteEntry");
          deleteBtn.onclick = async () => {
            if (confirm(`${t("confirm.deleteEntryFor")} ${dateStr}?`)) {
              if (matchingItem.parent && matchingItem.subIndex !== void 0) {
                if (matchingItem.parent.subEntries) {
                  matchingItem.parent.subEntries.splice(matchingItem.subIndex, 1);
                  if (matchingItem.parent.subEntries.length === 0) {
                    const parentIndex = this.timerManager.data.entries.indexOf(matchingItem.parent);
                    if (parentIndex > -1) {
                      this.timerManager.data.entries.splice(parentIndex, 1);
                    }
                  }
                }
              } else {
                const entryIndex = this.timerManager.data.entries.indexOf(matchingRaw);
                if (entryIndex > -1) {
                  this.timerManager.data.entries.splice(entryIndex, 1);
                }
              }
              await this.saveWithErrorHandling();
              this.softRefreshHistory();
            }
          };
          actionCell.appendChild(deleteBtn);
        }
        row.appendChild(actionCell);
      } else if (!isWide) {
        const actionCell = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.textContent = "\u270F\uFE0F";
        editBtn.style.padding = "4px 8px";
        editBtn.style.cursor = "pointer";
        editBtn.title = t("menu.editWork");
        editBtn.onclick = () => {
          this.showEditEntriesModal(e.date);
        };
        actionCell.appendChild(editBtn);
        row.appendChild(actionCell);
      }
      tbody.appendChild(row);
    });
    table.appendChild(tbody);
    section.appendChild(table);
    container.appendChild(section);
  }
  renderNarrowListView(container, years) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear().toString();
    Object.keys(years).sort().reverse().forEach((year, index) => {
      const yearSection = document.createElement("details");
      yearSection.className = "tf-history-year-section";
      yearSection.open = year === currentYear || index === 0 && !years[currentYear];
      const summary = document.createElement("summary");
      summary.style.cursor = "pointer";
      summary.style.padding = "8px 0";
      summary.style.fontWeight = "bold";
      summary.style.fontSize = "1.1em";
      summary.style.color = "var(--text-normal)";
      summary.style.listStyle = "none";
      summary.innerHTML = `<span style="margin-right: 8px;">${yearSection.open ? "\u25BC" : "\u25B6"}</span>${year}`;
      yearSection.appendChild(summary);
      yearSection.addEventListener("toggle", () => {
        const arrow = summary.querySelector("span");
        if (arrow)
          arrow.textContent = yearSection.open ? "\u25BC " : "\u25B6 ";
      });
      const yearDiv = document.createElement("div");
      yearDiv.style.paddingLeft = "8px";
      Object.keys(years[year]).sort().reverse().forEach((month) => {
        const monthEntries = years[year][month];
        const monthHeader = document.createElement("h5");
        monthHeader.textContent = getMonthName(new Date(parseInt(year), parseInt(month) - 1, 1));
        monthHeader.style.color = "var(--text-muted)";
        monthHeader.style.marginTop = "12px";
        monthHeader.style.marginBottom = "8px";
        monthHeader.style.fontSize = "0.95em";
        yearDiv.appendChild(monthHeader);
        const table = document.createElement("table");
        table.className = "tf-history-table-narrow";
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        [t("ui.date"), t("ui.type"), t("ui.hours"), t("ui.flextime"), ""].forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        monthEntries.forEach((e) => {
          const row = document.createElement("tr");
          if (e.isActive) {
            row.style.fontStyle = "italic";
            row.style.opacity = "0.8";
          }
          const dateCell = document.createElement("td");
          const dateStr = Utils.toLocalDateStr(e.date);
          const holidayInfo = this.data.getHolidayInfo(dateStr);
          const entryBehavior = this.settings.specialDayBehaviors.find(
            (b) => b.id === e.name.toLowerCase()
          );
          const isWorkEntry = (entryBehavior == null ? void 0 : entryBehavior.isWorkType) || ["jobb", "kurs", "studie"].includes(e.name.toLowerCase());
          const hasConflict = holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type) && isWorkEntry;
          if (e.isActive) {
            const activeIcon = document.createElement("span");
            activeIcon.textContent = "\u23F1\uFE0F ";
            activeIcon.title = t("ui.activeTimer");
            activeIcon.style.cursor = "help";
            dateCell.appendChild(activeIcon);
          } else if (hasConflict) {
            const flagIcon = document.createElement("span");
            flagIcon.textContent = "\u26A0\uFE0F ";
            flagIcon.title = t("info.workRegisteredOnSpecialDay").replace("{dayType}", translateSpecialDayName(holidayInfo.type));
            flagIcon.style.cursor = "help";
            dateCell.appendChild(flagIcon);
          }
          dateCell.appendChild(document.createTextNode(dateStr));
          row.appendChild(dateCell);
          const typeCell = document.createElement("td");
          const entryNameLower = e.name.toLowerCase();
          typeCell.textContent = translateSpecialDayName(entryNameLower, e.name);
          row.appendChild(typeCell);
          const hoursCell = document.createElement("td");
          const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
          hoursCell.textContent = e.isActive ? `${hoursText}...` : hoursText;
          row.appendChild(hoursCell);
          const flextimeCell = document.createElement("td");
          flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
          row.appendChild(flextimeCell);
          const actionCell = document.createElement("td");
          const editBtn = document.createElement("button");
          editBtn.textContent = "\u270F\uFE0F";
          editBtn.style.padding = "4px 8px";
          editBtn.style.cursor = "pointer";
          editBtn.title = t("menu.editWork");
          editBtn.onclick = () => {
            this.showEditEntriesModal(e.date);
          };
          actionCell.appendChild(editBtn);
          row.appendChild(actionCell);
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      yearSection.appendChild(yearDiv);
      container.appendChild(yearSection);
    });
  }
  renderWideListView(container, years) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear().toString();
    Object.keys(years).sort().reverse().forEach((year, index) => {
      const yearSection = document.createElement("details");
      yearSection.className = "tf-history-year-section";
      yearSection.open = year === currentYear || index === 0 && !years[currentYear];
      const summary = document.createElement("summary");
      summary.style.cursor = "pointer";
      summary.style.padding = "8px 0";
      summary.style.fontWeight = "bold";
      summary.style.fontSize = "1.1em";
      summary.style.color = "var(--text-normal)";
      summary.style.listStyle = "none";
      summary.innerHTML = `<span style="margin-right: 8px;">${yearSection.open ? "\u25BC" : "\u25B6"}</span>${year}`;
      yearSection.appendChild(summary);
      yearSection.addEventListener("toggle", () => {
        const arrow = summary.querySelector("span");
        if (arrow)
          arrow.textContent = yearSection.open ? "\u25BC " : "\u25B6 ";
      });
      const yearDiv = document.createElement("div");
      yearDiv.style.paddingLeft = "8px";
      Object.keys(years[year]).sort().reverse().forEach((month) => {
        const monthEntries = years[year][month];
        const monthHeader = document.createElement("h5");
        monthHeader.textContent = getMonthName(new Date(parseInt(year), parseInt(month) - 1, 1));
        monthHeader.style.color = "var(--text-muted)";
        monthHeader.style.marginTop = "12px";
        monthHeader.style.marginBottom = "8px";
        monthHeader.style.fontSize = "0.95em";
        yearDiv.appendChild(monthHeader);
        const table = document.createElement("table");
        table.className = "tf-history-table-wide";
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const headers = this.inlineEditMode ? [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.end"), t("ui.hours"), t("ui.flextime"), ""] : [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.end"), t("ui.hours"), t("ui.flextime")];
        headers.forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        const entriesByDate = {};
        monthEntries.forEach((e) => {
          const dateStr = Utils.toLocalDateStr(e.date);
          if (!entriesByDate[dateStr])
            entriesByDate[dateStr] = [];
          entriesByDate[dateStr].push(e);
        });
        const rawEntries = this.timerManager.data.entries;
        const flatRawEntries = [];
        rawEntries.forEach((entry) => {
          if (entry.collapsed && Array.isArray(entry.subEntries)) {
            entry.subEntries.forEach((sub, idx) => {
              if (sub.startTime) {
                flatRawEntries.push({ entry: sub, parent: entry, subIndex: idx });
              }
            });
          } else if (entry.startTime) {
            flatRawEntries.push({ entry });
          }
        });
        Object.keys(entriesByDate).sort().reverse().forEach((dateStr) => {
          const dayEntries = entriesByDate[dateStr];
          const rawDayEntries = flatRawEntries.filter((item) => {
            const entryDate = new Date(item.entry.startTime);
            return Utils.toLocalDateStr(entryDate) === dateStr;
          });
          const usedRawEntries = /* @__PURE__ */ new Set();
          dayEntries.forEach((e, idx) => {
            const row = document.createElement("tr");
            if (e.isActive) {
              row.style.fontStyle = "italic";
              row.style.opacity = "0.8";
            }
            const matchingItem = rawDayEntries.find(
              (item) => !usedRawEntries.has(item.entry) && item.entry.name.toLowerCase() === e.name.toLowerCase() && item.entry.startTime === e.startTime
            ) || rawDayEntries.find(
              (item) => !usedRawEntries.has(item.entry) && item.entry.name.toLowerCase() === e.name.toLowerCase()
            );
            const matchingRaw = matchingItem == null ? void 0 : matchingItem.entry;
            if (matchingRaw)
              usedRawEntries.add(matchingRaw);
            const dateCell = document.createElement("td");
            const holidayInfo = this.data.getHolidayInfo(dateStr);
            const entryBehavior = this.settings.specialDayBehaviors.find(
              (b) => b.id === e.name.toLowerCase()
            );
            const isWorkEntry = (entryBehavior == null ? void 0 : entryBehavior.isWorkType) || ["jobb", "kurs", "studie"].includes(e.name.toLowerCase());
            const hasSpecialDayConflict = holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type) && isWorkEntry;
            let hasTimeOverlap = false;
            let overlapDetails = "";
            if ((matchingRaw == null ? void 0 : matchingRaw.startTime) && (matchingRaw == null ? void 0 : matchingRaw.endTime)) {
              const thisStart = new Date(matchingRaw.startTime).getTime();
              const thisEnd = new Date(matchingRaw.endTime).getTime();
              for (const otherItem of rawDayEntries) {
                if (otherItem.entry === matchingRaw)
                  continue;
                if (!otherItem.entry.startTime || !otherItem.entry.endTime)
                  continue;
                const otherStart = new Date(otherItem.entry.startTime).getTime();
                const otherEnd = new Date(otherItem.entry.endTime).getTime();
                if (thisStart < otherEnd && thisEnd > otherStart) {
                  hasTimeOverlap = true;
                  const otherStartTime = new Date(otherItem.entry.startTime);
                  const otherEndTime = new Date(otherItem.entry.endTime);
                  overlapDetails = `${otherItem.entry.name} (${otherStartTime.getHours().toString().padStart(2, "0")}:${otherStartTime.getMinutes().toString().padStart(2, "0")}-${otherEndTime.getHours().toString().padStart(2, "0")}:${otherEndTime.getMinutes().toString().padStart(2, "0")})`;
                  break;
                }
              }
            }
            if (e.isActive) {
              const activeIcon = document.createElement("span");
              activeIcon.textContent = "\u23F1\uFE0F ";
              activeIcon.title = t("ui.activeTimer");
              activeIcon.style.cursor = "help";
              dateCell.appendChild(activeIcon);
            } else if (hasTimeOverlap) {
              const overlapIcon = document.createElement("span");
              overlapIcon.textContent = "\u{1F534} ";
              overlapIcon.title = `Overlapper med: ${overlapDetails}`;
              overlapIcon.style.cursor = "help";
              dateCell.appendChild(overlapIcon);
            } else if (hasSpecialDayConflict) {
              const flagIcon = document.createElement("span");
              flagIcon.textContent = "\u26A0\uFE0F ";
              flagIcon.title = t("info.workRegisteredOnSpecialDay").replace("{dayType}", translateSpecialDayName(holidayInfo.type));
              flagIcon.style.cursor = "help";
              dateCell.appendChild(flagIcon);
            }
            dateCell.appendChild(document.createTextNode(dateStr));
            row.appendChild(dateCell);
            const typeCell = document.createElement("td");
            if (this.inlineEditMode && matchingRaw) {
              const select = document.createElement("select");
              this.settings.specialDayBehaviors.forEach((behavior) => {
                const option = document.createElement("option");
                option.value = behavior.id;
                option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
                if (behavior.id === e.name.toLowerCase()) {
                  option.selected = true;
                }
                select.appendChild(option);
              });
              select.onchange = async () => {
                matchingRaw.name = select.value;
                await this.saveWithErrorHandling();
                this.softRefreshHistory();
              };
              typeCell.appendChild(select);
            } else {
              const entryNameLower = e.name.toLowerCase();
              typeCell.textContent = translateSpecialDayName(entryNameLower, e.name);
            }
            row.appendChild(typeCell);
            const startCell = document.createElement("td");
            if (matchingRaw == null ? void 0 : matchingRaw.startTime) {
              const startDate = new Date(matchingRaw.startTime);
              const startDateStr = Utils.toLocalDateStr(startDate);
              const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
              const endDateForCheck = matchingRaw.endTime ? new Date(matchingRaw.endTime) : null;
              const isMultiDay = endDateForCheck && Utils.toLocalDateStr(startDate) !== Utils.toLocalDateStr(endDateForCheck);
              if (this.inlineEditMode) {
                const container2 = document.createElement("div");
                container2.style.display = "flex";
                container2.style.flexDirection = "column";
                container2.style.gap = "4px";
                if (isMultiDay) {
                  const dateInput = document.createElement("input");
                  dateInput.type = "date";
                  dateInput.value = startDateStr;
                  dateInput.style.fontSize = "12px";
                  dateInput.onchange = async () => {
                    const newStart = /* @__PURE__ */ new Date(`${dateInput.value}T${timeInput.value}:00`);
                    matchingRaw.startTime = Utils.toLocalISOString(newStart);
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  };
                  container2.appendChild(dateInput);
                }
                const timeInput = this.createTimeInput(startTimeStr, async (newValue) => {
                  const parsed = this.parseTimeInput(newValue);
                  if (!parsed)
                    return;
                  const newStart = new Date(matchingRaw.startTime);
                  newStart.setHours(parsed.hours, parsed.minutes, 0, 0);
                  matchingRaw.startTime = Utils.toLocalISOString(newStart);
                  await this.saveWithErrorHandling();
                  this.softRefreshHistory();
                });
                container2.appendChild(timeInput);
                startCell.appendChild(container2);
              } else {
                startCell.textContent = isMultiDay ? `${startDateStr} ${startTimeStr}` : startTimeStr;
              }
            } else {
              startCell.textContent = "-";
            }
            row.appendChild(startCell);
            const endCell = document.createElement("td");
            const endDateParsed = (matchingRaw == null ? void 0 : matchingRaw.endTime) ? new Date(matchingRaw.endTime) : null;
            const hasValidEndTime = endDateParsed && !isNaN(endDateParsed.getTime());
            if (hasValidEndTime && matchingRaw) {
              const endDate = endDateParsed;
              const endDateStr = Utils.toLocalDateStr(endDate);
              const endTimeStr = `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}`;
              const startDateForCheck = matchingRaw.startTime ? new Date(matchingRaw.startTime) : null;
              const isMultiDay = startDateForCheck && Utils.toLocalDateStr(startDateForCheck) !== Utils.toLocalDateStr(endDate);
              if (this.inlineEditMode) {
                const container2 = document.createElement("div");
                container2.style.display = "flex";
                container2.style.flexDirection = "column";
                container2.style.gap = "4px";
                if (isMultiDay) {
                  const dateInput = document.createElement("input");
                  dateInput.type = "date";
                  dateInput.value = endDateStr;
                  dateInput.style.fontSize = "12px";
                  dateInput.onchange = async () => {
                    const newEnd = /* @__PURE__ */ new Date(`${dateInput.value}T${timeInput.value}:00`);
                    matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  };
                  container2.appendChild(dateInput);
                }
                const timeInput = this.createTimeInput(endTimeStr, async (newValue) => {
                  const parsed = this.parseTimeInput(newValue);
                  if (!parsed)
                    return;
                  const newEnd = new Date(matchingRaw.endTime);
                  newEnd.setHours(parsed.hours, parsed.minutes, 0, 0);
                  matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                  await this.saveWithErrorHandling();
                  this.softRefreshHistory();
                });
                container2.appendChild(timeInput);
                endCell.appendChild(container2);
              } else {
                endCell.textContent = isMultiDay ? `${endDateStr} ${endTimeStr}` : endTimeStr;
              }
            } else if (this.inlineEditMode && matchingRaw) {
              const startDate = matchingRaw.startTime ? new Date(matchingRaw.startTime) : /* @__PURE__ */ new Date();
              const container2 = document.createElement("div");
              container2.style.display = "flex";
              container2.style.flexDirection = "column";
              container2.style.gap = "4px";
              const timeInput = this.createTimeInput("", async (newValue) => {
                const parsed = this.parseTimeInput(newValue);
                if (!parsed)
                  return;
                const newEnd = new Date(startDate);
                newEnd.setHours(parsed.hours, parsed.minutes, 0, 0);
                if (newEnd <= startDate) {
                  newEnd.setDate(newEnd.getDate() + 1);
                  new import_obsidian4.Notice(t("validation.endTimeNextDay"));
                }
                matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                await this.saveWithErrorHandling();
                this.softRefreshHistory();
              });
              container2.appendChild(timeInput);
              endCell.appendChild(container2);
            } else {
              endCell.textContent = matchingRaw ? t("ui.ongoing") : "-";
            }
            row.appendChild(endCell);
            const hoursCell = document.createElement("td");
            const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
            hoursCell.textContent = e.isActive ? `${hoursText}...` : hoursText;
            row.appendChild(hoursCell);
            const flextimeCell = document.createElement("td");
            flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
            row.appendChild(flextimeCell);
            if (this.inlineEditMode) {
              const actionCell = document.createElement("td");
              if (matchingItem) {
                const deleteBtn = document.createElement("button");
                deleteBtn.className = "tf-history-delete-btn";
                deleteBtn.textContent = "\u{1F5D1}\uFE0F";
                deleteBtn.title = t("menu.deleteEntry");
                deleteBtn.onclick = async () => {
                  if (confirm(`${t("confirm.deleteEntryFor")} ${dateStr}?`)) {
                    if (matchingItem.parent && matchingItem.subIndex !== void 0) {
                      if (matchingItem.parent.subEntries) {
                        matchingItem.parent.subEntries.splice(matchingItem.subIndex, 1);
                        if (matchingItem.parent.subEntries.length === 0) {
                          const parentIndex = this.timerManager.data.entries.indexOf(matchingItem.parent);
                          if (parentIndex > -1) {
                            this.timerManager.data.entries.splice(parentIndex, 1);
                          }
                        }
                      }
                    } else {
                      const entryIndex = this.timerManager.data.entries.indexOf(matchingRaw);
                      if (entryIndex > -1) {
                        this.timerManager.data.entries.splice(entryIndex, 1);
                      }
                    }
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  }
                };
                actionCell.appendChild(deleteBtn);
              }
              row.appendChild(actionCell);
            }
            tbody.appendChild(row);
          });
        });
        if (this.inlineEditMode) {
          const addRow = document.createElement("tr");
          addRow.className = "tf-history-add-row";
          const addCell = document.createElement("td");
          addCell.colSpan = 7;
          addCell.textContent = t("ui.addNewEntry");
          addCell.onclick = () => {
            const lastEntry = monthEntries[0];
            const targetDate = (lastEntry == null ? void 0 : lastEntry.date) || /* @__PURE__ */ new Date();
            this.showAddEntryModal(targetDate);
          };
          addRow.appendChild(addCell);
          tbody.appendChild(addRow);
        }
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      yearSection.appendChild(yearDiv);
      container.appendChild(yearSection);
    });
  }
  showAddEntryModal(targetDate) {
    const dateStr = Utils.toLocalDateStr(targetDate);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.addEntryTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const typeLabel = document.createElement("div");
    typeLabel.textContent = t("ui.type") + ":";
    typeLabel.style.fontWeight = "bold";
    typeLabel.style.marginBottom = "5px";
    content.appendChild(typeLabel);
    const typeSelect = document.createElement("select");
    typeSelect.style.width = "100%";
    typeSelect.style.marginBottom = "15px";
    typeSelect.style.padding = "8px";
    this.settings.specialDayBehaviors.forEach((behavior) => {
      const option = document.createElement("option");
      option.value = behavior.id;
      option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const startLabel = document.createElement("div");
    startLabel.textContent = `${t("modals.startTime")}:`;
    startLabel.style.fontWeight = "bold";
    startLabel.style.marginBottom = "5px";
    content.appendChild(startLabel);
    const startInput = this.createTimeInput("08:00", () => {
    });
    startInput.style.width = "100%";
    startInput.style.marginBottom = "15px";
    startInput.style.padding = "8px";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = `${t("modals.endTime")}:`;
    endLabel.style.fontWeight = "bold";
    endLabel.style.marginBottom = "5px";
    content.appendChild(endLabel);
    const endInput = this.createTimeInput("16:00", () => {
    });
    endInput.style.width = "100%";
    endInput.style.marginBottom = "20px";
    endInput.style.padding = "8px";
    content.appendChild(endInput);
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonContainer.appendChild(cancelBtn);
    const saveBtn = document.createElement("button");
    saveBtn.className = "mod-cta";
    saveBtn.textContent = t("buttons.save");
    saveBtn.onclick = async () => {
      var _a, _b;
      const parsedStart = this.parseTimeInput(startInput.value);
      const parsedEnd = this.parseTimeInput(endInput.value);
      if (!parsedStart || !parsedEnd) {
        new import_obsidian4.Notice(t("validation.invalidTime"));
        return;
      }
      const startDate = new Date(targetDate);
      startDate.setHours(parsedStart.hours, parsedStart.minutes, 0, 0);
      const endDate = new Date(targetDate);
      endDate.setHours(parsedEnd.hours, parsedEnd.minutes, 0, 0);
      if (endDate <= startDate) {
        new import_obsidian4.Notice(t("validation.endAfterStart"));
        return;
      }
      this.timerManager.data.entries.push({
        name: typeSelect.value,
        startTime: Utils.toLocalISOString(startDate),
        endTime: Utils.toLocalISOString(endDate),
        subEntries: null
      });
      await this.saveWithErrorHandling();
      this.isModalOpen = false;
      modal.remove();
      const duration = (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
      new import_obsidian4.Notice(`\u2705 Lagt til ${duration.toFixed(1)} timer for ${dateStr}`);
      await ((_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a));
    };
    buttonContainer.appendChild(saveBtn);
    content.appendChild(buttonContainer);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  renderWeeklyView(container, years) {
    container.empty();
    const div = container.createDiv();
    div.style.padding = "20px";
    div.style.textAlign = "center";
    div.textContent = "Weekly view - Coming soon";
  }
  renderHeatmapView(container, years) {
    const heatmap = document.createElement("div");
    heatmap.className = "tf-heatmap";
    heatmap.style.gridTemplateColumns = `repeat(${this.settings.heatmapColumns}, 1fr)`;
    const today = /* @__PURE__ */ new Date();
    const daysToShow = this.settings.heatmapColumns * 8;
    for (let i = daysToShow; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-heatmap-cell";
      cell.title = dateKey;
      const dayEntries = this.data.daily[dateKey];
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      if (this.settings.heatmapShowSpecialDayColors) {
        let specialDayBehavior = void 0;
        if (holidayInfo) {
          specialDayBehavior = this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type);
        }
        if (!specialDayBehavior && dayEntries) {
          for (const entry of dayEntries) {
            const entryName = entry.name.toLowerCase();
            if (entryName === "jobb")
              continue;
            const entryBehavior = this.settings.specialDayBehaviors.find(
              (b) => b.id === entryName
            );
            if (entryBehavior) {
              specialDayBehavior = entryBehavior;
              break;
            }
          }
        }
        if (specialDayBehavior) {
          cell.style.background = specialDayBehavior.color;
          cell.title = `${dateKey} - ${specialDayBehavior.icon} ${specialDayBehavior.label}`;
        } else if (dayEntries) {
          if (!this.settings.enableGoalTracking) {
            const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
            cell.style.background = (workType == null ? void 0 : workType.simpleColor) || "#90caf9";
            cell.style.color = (workType == null ? void 0 : workType.simpleTextColor) || "#000000";
          } else {
            const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
            cell.style.background = this.flextimeColor(dayFlextime);
          }
        } else {
          cell.style.background = "var(--background-modifier-border)";
        }
      } else if (dayEntries) {
        if (!this.settings.enableGoalTracking) {
          const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
          cell.style.background = (workType == null ? void 0 : workType.simpleColor) || "#90caf9";
          cell.style.color = (workType == null ? void 0 : workType.simpleTextColor) || "#000000";
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.style.background = this.flextimeColor(dayFlextime);
        }
      } else {
        cell.style.background = "var(--background-modifier-border)";
      }
      heatmap.appendChild(cell);
    }
    container.appendChild(heatmap);
  }
  exportCurrentView() {
    const rows = [["Date", "Type", "Hours", "Flextime"]];
    Object.keys(this.data.daily).sort().forEach((dateKey) => {
      this.data.daily[dateKey].forEach((entry) => {
        rows.push([
          dateKey,
          entry.name,
          (entry.duration || 0).toFixed(2),
          (entry.flextime || 0).toFixed(2)
        ]);
      });
    });
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian4.Notice("Exported to CSV");
  }
  startUpdates() {
    const clockInterval = window.setInterval(() => {
      this.updateClock();
    }, this.settings.clockInterval);
    this.intervals.push(clockInterval);
    const dataInterval = window.setInterval(() => {
      this.updateAll();
    }, this.settings.updateInterval);
    this.intervals.push(dataInterval);
  }
  updateAll() {
    if (this.isModalOpen)
      return;
    this.updateBadge();
    this.updateTimerBadge();
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  /**
   * Soft refresh for inline editing - updates data and history view
   * without rebuilding the entire dashboard. Preserves edit mode state.
   */
  softRefreshHistory() {
    this.data.rawEntries = this.timerManager.convertToTimeEntries();
    this.data.processEntries();
    const activeSection = this.container.querySelector(".tf-active-entries-section");
    if (activeSection) {
      const parent = activeSection.parentElement;
      if (parent) {
        activeSection.remove();
        if (this.data.activeEntries.length > 0) {
          this.renderActiveEntriesSection(parent, this.data.activeEntries);
        }
      }
    }
    const historyContainer = this.container.querySelector(".tf-history-content");
    if (historyContainer) {
      this.refreshHistoryView(historyContainer);
    }
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  showDeleteConfirmation(entry, dateObj, onConfirm) {
    const overlay = document.createElement("div");
    overlay.className = "tf-confirm-overlay";
    const dialog = document.createElement("div");
    dialog.className = "tf-confirm-dialog";
    const title = document.createElement("div");
    title.className = "tf-confirm-title";
    title.textContent = "\u{1F5D1}\uFE0F Slett oppf\xF8ring";
    dialog.appendChild(title);
    const message = document.createElement("div");
    message.className = "tf-confirm-message";
    message.textContent = "Er du sikker p\xE5 at du vil slette denne oppf\xF8ringen?";
    dialog.appendChild(message);
    const details = document.createElement("div");
    details.className = "tf-confirm-details";
    const startDate = new Date(entry.startTime);
    const endDate = entry.endTime ? new Date(entry.endTime) : null;
    const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(2) : t("ui.ongoing");
    const dateRow = details.createDiv();
    dateRow.createEl("strong", { text: t("ui.date") + ":" });
    dateRow.appendText(" " + Utils.toLocalDateStr(dateObj));
    const typeRow = details.createDiv();
    typeRow.createEl("strong", { text: t("ui.type") + ":" });
    typeRow.appendText(" " + translateSpecialDayName(entry.name.toLowerCase(), entry.name));
    const startRow = details.createDiv();
    startRow.createEl("strong", { text: t("ui.start") + ":" });
    startRow.appendText(" " + formatTime(startDate));
    if (endDate) {
      const endRow = details.createDiv();
      endRow.createEl("strong", { text: t("ui.end") + ":" });
      endRow.appendText(" " + formatTime(endDate));
    }
    const durationRow = details.createDiv();
    durationRow.createEl("strong", { text: t("ui.duration") + ":" });
    durationRow.appendText(" " + (typeof duration === "string" ? duration : duration + " " + t("ui.hours").toLowerCase()));
    dialog.appendChild(details);
    const buttons = document.createElement("div");
    buttons.className = "tf-confirm-buttons";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "tf-confirm-cancel";
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => overlay.remove();
    buttons.appendChild(cancelBtn);
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "tf-confirm-delete";
    deleteBtn.textContent = "Slett";
    deleteBtn.onclick = () => {
      overlay.remove();
      onConfirm();
    };
    buttons.appendChild(deleteBtn);
    dialog.appendChild(buttons);
    overlay.appendChild(dialog);
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    };
    document.body.appendChild(overlay);
  }
  cleanup() {
    this.intervals.forEach((interval) => clearInterval(interval));
    this.intervals = [];
  }
  build() {
    this.injectStyles();
    this.container.appendChild(this.buildBadgeSection());
    const mainCardsWrapper = document.createElement("div");
    mainCardsWrapper.className = "tf-main-cards-wrapper";
    mainCardsWrapper.appendChild(this.createDayCard());
    mainCardsWrapper.appendChild(this.createWeekCard());
    mainCardsWrapper.appendChild(this.createMonthCard());
    mainCardsWrapper.appendChild(this.createStatsCard());
    this.container.appendChild(mainCardsWrapper);
    this.container.appendChild(this.buildInfoCard());
    this.container.appendChild(this.buildHistoryCard());
    this.container.appendChild(this.buildStatusBar());
    this.container.appendChild(this.buildViewToggle());
    return this.container;
  }
};

// src/view.ts
var VIEW_TYPE_TIMEFLOW = "timeflow-view";
var TimeFlowView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dataManager = null;
    this.uiBuilder = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TIMEFLOW;
  }
  getDisplayText() {
    return "timeflow Dashboard";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeflow-dashboard");
    await this.loadDashboard(container);
  }
  async onClose() {
    if (this.uiBuilder) {
      this.uiBuilder.cleanup();
    }
  }
  async loadDashboard(container) {
    try {
      const allEntries = this.plugin.timerManager.convertToTimeEntries();
      if (allEntries.length === 0) {
        container.createDiv({
          text: "No timer data yet. Start a timer to begin tracking!",
          cls: "timeflow-warning"
        });
      }
      this.dataManager = new DataManager(allEntries, this.plugin.settings, this.app);
      const holidayStatus = await this.dataManager.loadHolidays();
      const converted = await this.plugin.timerManager.convertPastPlannedDays(
        this.dataManager.holidays,
        this.plugin.settings
      );
      if (converted > 0) {
        const updatedEntries = this.plugin.timerManager.convertToTimeEntries();
        this.dataManager = new DataManager(updatedEntries, this.plugin.settings, this.app);
        await this.dataManager.loadHolidays();
      }
      this.dataManager.processEntries();
      const validationResults = this.dataManager.validateData();
      const systemStatus = {
        holiday: holidayStatus,
        validation: validationResults,
        activeTimers: this.dataManager.activeEntries.length
      };
      this.uiBuilder = new UIBuilder(
        this.dataManager,
        systemStatus,
        this.plugin.settings,
        this.app,
        this.plugin.timerManager,
        this.plugin
      );
      this.plugin.timerManager.onTimerChange = () => {
        this.refresh();
      };
      const dashboardEl = this.uiBuilder.build();
      container.empty();
      container.appendChild(dashboardEl);
      this.uiBuilder.startUpdates();
    } catch (error) {
      console.error("Error loading TimeFlow dashboard:", error);
      container.createDiv({
        text: `Error loading dashboard: ${error.message}`,
        cls: "timeflow-error"
      });
    }
  }
  // Method to refresh the dashboard
  async refresh() {
    const container = this.containerEl.children[1];
    await this.loadDashboard(container);
  }
};

// src/timerManager.ts
var import_obsidian6 = require("obsidian");
var TimerManager = class {
  constructor(app, settings) {
    this.isSaving = false;
    this.lastSaveTime = 0;
    this.app = app;
    this.settings = settings;
    this.dataFile = settings.dataFilePath;
    this.data = { entries: [] };
  }
  /**
   * Check if we should reload data from file.
   * Returns false if we're currently saving or just saved (within 500ms)
   * to prevent race conditions with the file watcher.
   */
  shouldReloadFromFile() {
    if (this.isSaving)
      return false;
    if (Date.now() - this.lastSaveTime < 500)
      return false;
    return true;
  }
  async load() {
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dataFile);
        const parsed = this.parseTimekeepData(content);
        if (parsed) {
          this.data = parsed;
          const needsSave = this.normalizeEntryTimestamps();
          if (needsSave) {
            await this.save();
            console.log("TimeFlow: Migrated entry timestamps to local ISO format");
          }
          if (parsed.settings) {
            return parsed.settings;
          }
        } else {
          console.warn("TimeFlow: Could not parse data from", this.dataFile);
          this.data = { entries: [] };
        }
      } else {
        await this.createDataFile();
      }
    } catch (error) {
      console.error("TimeFlow: Error loading timer data:", error);
      this.data = { entries: [] };
    }
    return null;
  }
  async createDataFile() {
    const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data)}
\`\`\`
`;
    const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
    const folderExists = await this.app.vault.adapter.exists(folderPath);
    if (!folderExists) {
      await this.app.vault.createFolder(folderPath);
    }
    await this.app.vault.create(this.dataFile, content);
  }
  parseTimekeepData(content) {
    try {
      const match = content.match(/```timekeep\s*\n([\s\S]*?)\n```/);
      if (match && match[1]) {
        return JSON.parse(match[1]);
      }
    } catch (error) {
      console.error("Error parsing timekeep data:", error);
    }
    return null;
  }
  async save() {
    var _a;
    this.isSaving = true;
    this.lastSaveTime = Date.now();
    try {
      const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data, null, 2)}
\`\`\`
`;
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      if (fileExists) {
        const file = this.app.vault.getAbstractFileByPath(this.dataFile);
        if (file && file instanceof import_obsidian6.TFile) {
          await this.app.vault.modify(file, content);
        } else {
          await this.app.vault.adapter.write(this.dataFile, content);
        }
      } else {
        const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
        const folderExists = await this.app.vault.adapter.exists(folderPath);
        if (!folderExists) {
          await this.app.vault.createFolder(folderPath);
        }
        try {
          await this.app.vault.create(this.dataFile, content);
        } catch (createError) {
          if ((_a = createError == null ? void 0 : createError.message) == null ? void 0 : _a.includes("File already exists")) {
            await this.app.vault.adapter.write(this.dataFile, content);
          } else {
            throw createError;
          }
        }
      }
    } catch (error) {
      console.error("TimeFlow: Error saving timer data:", error);
    } finally {
      this.isSaving = false;
    }
  }
  // Save settings to the data file for cross-device sync
  async saveSettings(settings) {
    this.settings = settings;
    this.data.settings = settings;
    await this.save();
  }
  async startTimer(name = "jobb") {
    const timer = {
      name,
      startTime: Utils.toLocalISOString(/* @__PURE__ */ new Date()),
      endTime: null,
      subEntries: null
    };
    this.data.entries.push(timer);
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    new import_obsidian6.Notice(`\u23F1\uFE0F Timer started: ${name}`);
    return timer;
  }
  async stopTimer(timer) {
    if (!timer.startTime || timer.endTime) {
      return null;
    }
    timer.endTime = Utils.toLocalISOString(/* @__PURE__ */ new Date());
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    const duration = Utils.hoursDiff(
      new Date(timer.startTime),
      new Date(timer.endTime)
    );
    new import_obsidian6.Notice(`\u2705 Timer stopped: ${timer.name} (${Utils.formatHoursToHM(duration)})`);
    return timer;
  }
  async stopAllTimers() {
    const activeTimers = this.getActiveTimers();
    for (const timer of activeTimers) {
      await this.stopTimer(timer);
    }
  }
  async deleteTimer(timer) {
    const index = this.data.entries.indexOf(timer);
    if (index !== -1) {
      this.data.entries.splice(index, 1);
      await this.save();
      if (this.onTimerChange) {
        this.onTimerChange();
      }
      new import_obsidian6.Notice("Timer deleted");
      return true;
    }
    return false;
  }
  /**
   * Normalize entry timestamps:
   * - Convert UTC 'Z' format to local ISO format
   * - Convert midnight T00:00:00 to T08:00:00 to avoid timezone parsing issues
   * Returns true if any entries were modified and need saving.
   */
  normalizeEntryTimestamps() {
    let modified = false;
    const normalizeTimestamp = (timestamp) => {
      if (!timestamp)
        return null;
      if (timestamp.endsWith("Z")) {
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
          const pad = (n) => n.toString().padStart(2, "0");
          const localISO = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
          modified = true;
          return localISO;
        }
      }
      if (timestamp.endsWith("T00:00:00")) {
        modified = true;
        return timestamp.replace("T00:00:00", "T08:00:00");
      }
      return timestamp;
    };
    const normalizeEntry = (entry) => {
      if (entry.startTime) {
        const normalized = normalizeTimestamp(entry.startTime);
        if (normalized !== entry.startTime) {
          entry.startTime = normalized;
        }
      }
      if (entry.endTime) {
        const normalized = normalizeTimestamp(entry.endTime);
        if (normalized !== entry.endTime) {
          entry.endTime = normalized;
        }
      }
      if (entry.subEntries && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub) => normalizeEntry(sub));
      }
    };
    this.data.entries.forEach((entry) => normalizeEntry(entry));
    return modified;
  }
  getActiveTimers() {
    return this.data.entries.filter((e) => e.startTime && !e.endTime && !e.collapsed);
  }
  getCompletedTimers() {
    return this.data.entries.filter((e) => e.startTime && e.endTime);
  }
  getAllTimers() {
    return this.data.entries;
  }
  // Flatten all entries including subEntries for DataManager
  convertToTimeEntries() {
    const flatEntries = [];
    const flattenEntry = (entry) => {
      if (entry.collapsed && entry.subEntries) {
        entry.subEntries.forEach((sub) => flattenEntry(sub));
      } else if (entry.startTime) {
        flatEntries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          subEntries: null
        });
      }
    };
    this.data.entries.forEach((entry) => flattenEntry(entry));
    return flatEntries;
  }
  // Get running time for active timer
  getRunningTime(timer) {
    if (!timer.startTime || timer.endTime)
      return 0;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(timer.startTime);
    return Utils.hoursDiff(start, now);
  }
  // Get total running time for all active timers
  getTotalRunningTime() {
    return this.getActiveTimers().reduce((total, timer) => {
      return total + this.getRunningTime(timer);
    }, 0);
  }
  // Load data from multiple sources (daily notes with timekeep codeblocks)
  async loadFromDailyNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const dailyNotesFolder = this.settings.dailyNotesFolder;
      let allEntries = [];
      for (const file of files) {
        if (file.path.startsWith(dailyNotesFolder)) {
          const content = await this.app.vault.read(file);
          const parsed = this.parseTimekeepData(content);
          if (parsed && parsed.entries) {
            allEntries = allEntries.concat(parsed.entries);
          }
        }
      }
      const currentEntries = this.data.entries;
      allEntries.forEach((entry) => {
        const isDuplicate = currentEntries.some(
          (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
        );
        if (!isDuplicate) {
          currentEntries.push(entry);
        }
      });
      this.data.entries = currentEntries;
      await this.save();
    } catch (error) {
      console.error("Error loading from daily notes:", error);
    }
  }
  // Export to Timekeep format for other tools
  exportTimekeepFormat() {
    return JSON.stringify(this.data, null, 2);
  }
  // Import from Timekeep JSON
  async importTimekeepData(jsonData) {
    try {
      const parsed = JSON.parse(jsonData);
      if (parsed && parsed.entries) {
        const currentEntries = this.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        parsed.entries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.data.entries = currentEntries;
        await this.save();
        if (this.onTimerChange) {
          this.onTimerChange();
        }
        if (skippedCount > 0) {
          new import_obsidian6.Notice(`\u2705 Imported ${addedCount} entries, skipped ${skippedCount} duplicates`);
        } else {
          new import_obsidian6.Notice(`\u2705 Imported ${addedCount} entries`);
        }
        return true;
      }
    } catch (error) {
      console.error("Error importing timekeep data:", error);
      new import_obsidian6.Notice("\u274C Error importing data");
    }
    return false;
  }
  // Convert past planned days (from holidays.md) to timer entries
  // This ensures planned days like ferie, avspasering appear in Historikk
  async convertPastPlannedDays(holidays, settings) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    let converted = 0;
    for (const [dateStr, info] of Object.entries(holidays)) {
      const plannedDate = new Date(dateStr);
      if (plannedDate >= today)
        continue;
      const behavior = settings.specialDayBehaviors.find((b) => b.id === info.type);
      if (!(behavior == null ? void 0 : behavior.noHoursRequired))
        continue;
      if (info.type === "helligdag")
        continue;
      const hasEntry = this.data.entries.some((e) => {
        if (!e.startTime)
          return false;
        const entryDate = new Date(e.startTime);
        return Utils.toLocalDateStr(entryDate) === dateStr && e.name.toLowerCase() === info.type;
      });
      if (hasEntry)
        continue;
      let startTime = `${dateStr}T08:00:00`;
      let endTime = `${dateStr}T08:00:00`;
      if (info.type === "avspasering") {
        if (info.startTime && info.endTime) {
          startTime = `${dateStr}T${info.startTime}:00`;
          endTime = `${dateStr}T${info.endTime}:00`;
        } else {
          const hours = settings.baseWorkday * settings.workPercent;
          const h = Math.floor(hours);
          const m = Math.round((hours - h) * 60);
          endTime = `${dateStr}T${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}:00`;
        }
      }
      const entry = {
        name: info.type,
        startTime,
        endTime,
        subEntries: null
      };
      this.data.entries.push(entry);
      converted++;
    }
    if (converted > 0) {
      await this.save();
    }
    return converted;
  }
};

// src/main.ts
var TimeFlowPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    var _a;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.timerManager = new TimerManager(this.app, this.settings);
    const syncedSettings = await this.timerManager.load();
    if (syncedSettings) {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, this.settings, syncedSettings);
      this.timerManager.settings = this.settings;
    }
    const needsSave = this.migrateWorkDaysSettings() || this.migrateSpecialDayBehaviors();
    const timestampMigrated = await this.migrateTimestamps();
    if (needsSave || timestampMigrated) {
      await this.saveSettings();
    }
    setLanguage((_a = this.settings.language) != null ? _a : "nb");
    this.registerView(
      VIEW_TYPE_TIMEFLOW,
      (leaf) => new TimeFlowView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open timeflow", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-timeflow",
      name: "Open timeflow Dashboard",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "start-timer",
      name: "Start Timer",
      callback: async () => {
        await this.timerManager.startTimer("jobb");
      }
    });
    this.addCommand({
      id: "stop-all-timers",
      name: "Stop All Timers",
      callback: async () => {
        await this.timerManager.stopAllTimers();
      }
    });
    this.addCommand({
      id: "import-timekeep-data",
      name: "Import Timekeep Data",
      callback: () => {
        new ImportModal(this.app, this.timerManager, () => {
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
          leaves.forEach((leaf) => {
            const view = leaf.view;
            if (view && view.refresh) {
              view.refresh();
            }
          });
        }).open();
      }
    });
    this.addSettingTab(new TimeFlowSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (file.path === this.settings.dataFilePath) {
            if (!this.timerManager.shouldReloadFromFile())
              return;
            await this.timerManager.load();
            const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
            leaves.forEach((leaf) => {
              const view = leaf.view;
              if (view && view.refresh) {
                view.refresh();
              }
            });
          }
        })
      );
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  migrateSpecialDayBehaviors() {
    let changed = false;
    if (!this.settings.specialDayBehaviors || this.settings.specialDayBehaviors.length === 0) {
      this.settings.specialDayBehaviors = DEFAULT_SPECIAL_DAY_BEHAVIORS.map((defaultBehavior) => {
        var _a, _b;
        return {
          ...defaultBehavior,
          label: ((_a = this.settings.specialDayLabels) == null ? void 0 : _a[defaultBehavior.id]) || defaultBehavior.label,
          color: ((_b = this.settings.specialDayColors) == null ? void 0 : _b[defaultBehavior.id]) || defaultBehavior.color
        };
      });
      changed = true;
    } else {
      DEFAULT_SPECIAL_DAY_BEHAVIORS.forEach((defaultBehavior) => {
        const existingIndex = this.settings.specialDayBehaviors.findIndex((b) => b.id === defaultBehavior.id);
        if (existingIndex === -1) {
          if (defaultBehavior.isWorkType) {
            this.settings.specialDayBehaviors.unshift({ ...defaultBehavior });
          } else {
            this.settings.specialDayBehaviors.push({ ...defaultBehavior });
          }
          changed = true;
        } else if (defaultBehavior.isWorkType && !this.settings.specialDayBehaviors[existingIndex].isWorkType) {
          this.settings.specialDayBehaviors[existingIndex].isWorkType = true;
          changed = true;
        }
      });
    }
    return changed;
  }
  /**
   * Migrate UTC timestamps (ending with Z) to local ISO format.
   * This ensures times display correctly regardless of timezone.
   */
  async migrateTimestamps() {
    if (this.settings.hasTimestampMigration) {
      return false;
    }
    let changed = false;
    const convertTimestamp = (timestamp) => {
      if (!timestamp)
        return null;
      if (timestamp.endsWith("Z")) {
        const date = new Date(timestamp);
        return Utils.toLocalISOString(date);
      }
      return timestamp;
    };
    const migrateEntry = (entry) => {
      const newStart = convertTimestamp(entry.startTime);
      const newEnd = convertTimestamp(entry.endTime);
      if (newStart !== entry.startTime || newEnd !== entry.endTime) {
        entry.startTime = newStart;
        entry.endTime = newEnd;
        changed = true;
      }
      if (entry.subEntries) {
        entry.subEntries.forEach((sub) => migrateEntry(sub));
      }
    };
    this.timerManager.data.entries.forEach((entry) => migrateEntry(entry));
    if (changed) {
      await this.timerManager.save();
      console.log("TimeFlow: Migrated timestamps to local format");
    }
    this.settings.hasTimestampMigration = true;
    return changed;
  }
  migrateWorkDaysSettings() {
    let changed = false;
    if (!this.settings.workDays || this.settings.workDays.length === 0) {
      const workDays = [1, 2, 3, 4, 5];
      if (this.settings.includeSaturdayInWorkWeek) {
        workDays.push(6);
      }
      if (this.settings.includeSundayInWorkWeek) {
        workDays.push(0);
      }
      this.settings.workDays = workDays.sort((a, b) => a - b);
      changed = true;
    }
    if (!this.settings.alternatingWeekWorkDays || this.settings.alternatingWeekWorkDays.length === 0) {
      this.settings.alternatingWeekWorkDays = [...this.settings.workDays];
      changed = true;
    }
    return changed;
  }
  /**
   * Validate and clamp settings to sensible bounds to prevent division by zero
   * and other edge cases.
   */
  validateSettings() {
    this.settings.workPercent = Math.max(0.01, Math.min(2, this.settings.workPercent));
    this.settings.baseWorkday = Math.max(0.5, Math.min(24, this.settings.baseWorkday));
    this.settings.baseWorkweek = Math.max(1, Math.min(168, this.settings.baseWorkweek));
    this.settings.workdaysPerWeek = Math.max(1, Math.min(7, this.settings.workdaysPerWeek));
    this.settings.workdaysPerMonth = Math.max(1, Math.min(31, this.settings.workdaysPerMonth));
    this.settings.workdaysPerYear = Math.max(1, Math.min(366, this.settings.workdaysPerYear));
    this.settings.lunchBreakMinutes = Math.max(0, Math.min(120, this.settings.lunchBreakMinutes));
    this.settings.halfDayHours = Math.max(0.5, Math.min(12, this.settings.halfDayHours));
    this.settings.maxEgenmeldingDays = Math.max(0, Math.min(365, this.settings.maxEgenmeldingDays));
    this.settings.maxFerieDays = Math.max(0, Math.min(365, this.settings.maxFerieDays));
    this.settings.heatmapColumns = Math.max(12, Math.min(96, this.settings.heatmapColumns));
    if (this.settings.halfDayHours >= this.settings.baseWorkday) {
      this.settings.halfDayHours = this.settings.baseWorkday / 2;
    }
    const t2 = this.settings.balanceThresholds;
    if (t2.criticalLow >= t2.warningLow)
      t2.warningLow = t2.criticalLow + 1;
    if (t2.warningLow >= t2.warningHigh)
      t2.warningHigh = t2.warningLow + 1;
    if (t2.warningHigh >= t2.criticalHigh)
      t2.criticalHigh = t2.warningHigh + 1;
    if (!this.settings.workDays || this.settings.workDays.length === 0) {
      this.settings.workDays = [1, 2, 3, 4, 5];
    }
  }
  async saveSettings() {
    this.validateSettings();
    await this.saveData(this.settings);
    await this.timerManager.saveSettings(this.settings);
  }
  async activateView(location) {
    const targetLocation = location != null ? location : this.settings.defaultViewLocation;
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      if (targetLocation === "main") {
        leaf = workspace.getLeaf("tab");
      } else {
        leaf = workspace.getRightLeaf(false);
      }
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TIMEFLOW, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async moveViewToLocation(location) {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    for (const leaf of leaves) {
      leaf.detach();
    }
    await this.activateView(location);
  }
};
