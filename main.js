/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeFlowPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils.ts
var FIXED_DAY_COLORS = {
  helligdag: "#ef5350",
  halfday: "#ffd54f",
  "Ingen registrering": "#cccccc"
};
function getSpecialDayColors(settings) {
  return {
    ...FIXED_DAY_COLORS,
    ...settings.specialDayColors
  };
}
var EMOJI_MAP = {
  avspasering: "\u{1F6CC}",
  kurs: "\u{1F4DA}",
  studie: "\u{1F4DA}",
  ferie: "\u{1F3D6}\uFE0F",
  velferdspermisjon: "\u{1F3E5}",
  egenmelding: "\u{1F912}",
  sykemelding: "\u{1F3E5}",
  helligdag: "\u{1F389}",
  jobb: "\u{1F4BC}"
};
var Utils = {
  parseDate: (str) => str ? new Date(str) : null,
  hoursDiff: (start, end) => (end.getTime() - start.getTime()) / 36e5,
  isWeekend: (date, settings) => {
    if (!date)
      return false;
    const day = date.getDay();
    if (!settings)
      return day === 0 || day === 6;
    const isSaturday = day === 6 && !settings.includeSaturdayInWorkWeek;
    const isSunday = day === 0 && !settings.includeSundayInWorkWeek;
    return isSaturday || isSunday;
  },
  formatHoursToHM: (hours, unit = "h") => {
    const h = Math.floor(hours);
    const m = Math.round((hours - h) * 60);
    return `${h}${unit} ${m.toString().padStart(2, "0")}m`;
  },
  toLocalDateStr: (date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  },
  getWeekNumber: (d) => {
    const date = new Date(d.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    const week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(
      ((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7
    );
  },
  getEmoji: (entry) => {
    const name = entry.name.toLowerCase();
    if (EMOJI_MAP[name])
      return EMOJI_MAP[name];
    if (!entry.endTime)
      return "\u23F3";
    if (Utils.isWeekend(entry.date))
      return "\u{1F319}";
    return "";
  },
  randMsg: (arr) => arr[Math.floor(Math.random() * arr.length)],
  getDayOfYear: (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    return Math.floor(diff / 864e5);
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  version: "1.0.0",
  theme: "light",
  hourUnit: "t",
  workPercent: 1,
  baseWorkday: 7.5,
  baseWorkweek: 37.5,
  lunchBreakMinutes: 0,
  includeSaturdayInWorkWeek: false,
  includeSundayInWorkWeek: false,
  maxEgenmeldingDays: 8,
  maxFerieDays: 25,
  updateInterval: 3e4,
  clockInterval: 1e3,
  holidaysFilePath: "timeflow/holidays.md",
  dailyNotesFolder: "Daily Notes",
  dailyNotesTemplatePath: "timeflow/templates/daily-notes.md",
  workdaysPerYear: 260,
  workdaysPerMonth: 21,
  workdaysPerWeek: 5,
  consecutiveFlextimeWarningDays: 5,
  defaultExportWeeks: 52,
  heatmapColumns: 48,
  noteTypes: [
    {
      id: "daily",
      label: "Daglig Notat",
      icon: "\u{1F4C5}",
      folder: "Daily Notes",
      template: "timeflow/templates/daily-notes.md",
      tags: [],
      filenamePattern: "{YYYY}-{MM}-{DD}"
    },
    {
      id: "meeting",
      label: "M\xF8tenotat",
      icon: "\u{1F465}",
      folder: "M\xF8ter",
      template: "timeflow/templates/meeting-note.md",
      tags: ["#m\xF8te", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} M\xF8te"
    },
    {
      id: "project",
      label: "Prosjektnotat",
      icon: "\u{1F4CB}",
      folder: "Prosjekter",
      template: "timeflow/templates/project-note.md",
      tags: ["#prosjekt", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Prosjekt"
    },
    {
      id: "review",
      label: "Ukesoppsummering",
      icon: "\u{1F50D}",
      folder: "Oppsummeringer",
      template: "timeflow/templates/weekly-review.md",
      tags: ["#oppsummering", "#uke", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Uke {WEEK}"
    },
    {
      id: "reflection",
      label: "Refleksjonsnotat",
      icon: "\u{1F4AD}",
      folder: "Refleksjoner",
      template: "timeflow/templates/reflection-note.md",
      tags: ["#refleksjon", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Refleksjon"
    }
  ],
  specialDayColors: {
    avspasering: "#ffe0b2",
    ferie: "#b3e5fc",
    velferdspermisjon: "#e1bee7",
    egenmelding: "#c8e6c9",
    sykemelding: "#c8e6c9",
    kurs: "#f8bbd0",
    studie: "#f8bbd0"
  },
  specialDayLabels: {
    avspasering: "Avspasering",
    ferie: "Ferie",
    velferdspermisjon: "Velferdspermisjon",
    egenmelding: "Egenmelding",
    sykemelding: "Sykemelding",
    kurs: "Kurs",
    studie: "Studie"
  }
};
var TimeFlowSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async refreshView() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("timeflow-view");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && typeof view.refresh === "function") {
        await view.refresh();
      }
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "TimeFlow Settings" });
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian.Setting(containerEl).setName("Theme").setDesc("Choose the color scheme for TimeFlow cards").addDropdown((dropdown) => dropdown.addOption("light", "Light (Colorful gradients)").addOption("system", "System (Match Obsidian theme)").addOption("dark", "Dark (Dark gradients)").setValue(this.plugin.settings.theme).onChange(async (value) => {
      this.plugin.settings.theme = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Hour Unit").setDesc('Choose the unit symbol for displaying hours: "h" for hours or "t" for timer').addDropdown((dropdown) => dropdown.addOption("h", "h (hours)").addOption("t", "t (timer)").setValue(this.plugin.settings.hourUnit).onChange(async (value) => {
      this.plugin.settings.hourUnit = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    containerEl.createEl("h4", { text: "Special Day Types" });
    containerEl.createEl("p", {
      text: "Customize names and colors for different types of special days. These day types affect flextime calculations.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Time Off (Compensatory Leave)").setDesc("Day off using banked flextime hours. Withdraws logged hours from flextime balance.").addText((text) => text.setPlaceholder("Avspasering").setValue(this.plugin.settings.specialDayLabels.avspasering).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.avspasering = value || "Avspasering";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.avspasering).onChange(async (value) => {
      this.plugin.settings.specialDayColors.avspasering = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Vacation").setDesc("Paid vacation day (no flextime change).").addText((text) => text.setPlaceholder("Ferie").setValue(this.plugin.settings.specialDayLabels.ferie).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.ferie = value || "Ferie";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.ferie).onChange(async (value) => {
      this.plugin.settings.specialDayColors.ferie = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Welfare Leave").setDesc("Personal/family emergency leave (no flextime change).").addText((text) => text.setPlaceholder("Velferdspermisjon").setValue(this.plugin.settings.specialDayLabels.velferdspermisjon).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.velferdspermisjon = value || "Velferdspermisjon";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.velferdspermisjon).onChange(async (value) => {
      this.plugin.settings.specialDayColors.velferdspermisjon = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Sick Leave (Self-Certified)").setDesc("Sick day without doctor's note (no flextime change).").addText((text) => text.setPlaceholder("Egenmelding").setValue(this.plugin.settings.specialDayLabels.egenmelding).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.egenmelding = value || "Egenmelding";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.egenmelding).onChange(async (value) => {
      this.plugin.settings.specialDayColors.egenmelding = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Sick Leave (Doctor's Note)").setDesc("Sick day with doctor's note (no flextime change).").addText((text) => text.setPlaceholder("Sykemelding").setValue(this.plugin.settings.specialDayLabels.sykemelding).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.sykemelding = value || "Sykemelding";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.sykemelding).onChange(async (value) => {
      this.plugin.settings.specialDayColors.sykemelding = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Course/Training").setDesc("Professional development/training day. Regular workday goal applies - hours beyond workday count as flextime.").addText((text) => text.setPlaceholder("Kurs").setValue(this.plugin.settings.specialDayLabels.kurs).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.kurs = value || "Kurs";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.kurs).onChange(async (value) => {
      this.plugin.settings.specialDayColors.kurs = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Study").setDesc("Educational leave/study day. Regular workday goal applies - hours beyond workday count as flextime.").addText((text) => text.setPlaceholder("Studie").setValue(this.plugin.settings.specialDayLabels.studie).onChange(async (value) => {
      this.plugin.settings.specialDayLabels.studie = value || "Studie";
      await this.plugin.saveSettings();
      await this.refreshView();
    })).addColorPicker((color) => color.setValue(this.plugin.settings.specialDayColors.studie).onChange(async (value) => {
      this.plugin.settings.specialDayColors.studie = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    containerEl.createEl("h3", { text: "Work Configuration" });
    const syncInfo = containerEl.createDiv();
    syncInfo.style.marginBottom = "15px";
    syncInfo.style.padding = "10px";
    syncInfo.style.background = "var(--background-secondary)";
    syncInfo.style.borderRadius = "5px";
    syncInfo.style.fontSize = "0.9em";
    syncInfo.innerHTML = `
			<strong>\u{1F4F1} Cross-Device Settings Sync</strong><br>
			Settings are automatically saved to <code>timeflow/data.md</code> and will sync across devices when using Obsidian Sync or any other vault sync solution. When you open the plugin on another device, your settings will be automatically loaded.
		`;
    new import_obsidian.Setting(containerEl).setName("Work Percentage").setDesc("Your employment percentage (1.0 = 100%, 0.8 = 80%, etc.)").addText((text) => text.setPlaceholder("1.0").setValue(this.plugin.settings.workPercent.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0 && num <= 1) {
        this.plugin.settings.workPercent = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Base Workday Hours").setDesc("Standard hours for a full workday (e.g., 7.5 for standard, 6 for 6-hour days)").addText((text) => text.setPlaceholder("7.5").setValue(this.plugin.settings.baseWorkday.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.baseWorkday = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Base Workweek Hours").setDesc("Standard hours for a full workweek (e.g., 37.5 for 5 days, 30 for 4 days)").addText((text) => text.setPlaceholder("37.5").setValue(this.plugin.settings.baseWorkweek.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.baseWorkweek = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Lunch Break Duration").setDesc("Daily lunch break in minutes (e.g., 30 for 30 minutes). This will be deducted from your work hours automatically.").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.lunchBreakMinutes.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.lunchBreakMinutes = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Include Saturday in Work Week").setDesc("Enable if you work Saturdays as part of your normal work week").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSaturdayInWorkWeek).onChange(async (value) => {
      this.plugin.settings.includeSaturdayInWorkWeek = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(containerEl).setName("Include Sunday in Work Week").setDesc("Enable if you work Sundays as part of your normal work week").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSundayInWorkWeek).onChange(async (value) => {
      this.plugin.settings.includeSundayInWorkWeek = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    containerEl.createEl("h4", { text: "Leave Limits" });
    containerEl.createEl("p", {
      text: "Set maximum allowed days for different leave types per year. The dashboard displays your usage against these limits in the yearly statistics view.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Max Sick Leave Days (Self-Reported)").setDesc("Maximum self-reported sick days (egenmelding) allowed per year (typically 8 in Norway)").addText((text) => text.setPlaceholder("8").setValue(this.plugin.settings.maxEgenmeldingDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.maxEgenmeldingDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Max Vacation Days").setDesc("Maximum vacation days (ferie) per year based on your contract (typically 25 in Norway)").addText((text) => text.setPlaceholder("25").setValue(this.plugin.settings.maxFerieDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.maxFerieDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    containerEl.createEl("h3", { text: "File Paths" });
    new import_obsidian.Setting(containerEl).setName("Holidays File Path").setDesc("Path to the file containing future planned days/holidays").addText((text) => text.setPlaceholder("timeflow/holidays.md").setValue(this.plugin.settings.holidaysFilePath).onChange(async (value) => {
      this.plugin.settings.holidaysFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Daily Notes Folder").setDesc("Folder where daily notes are stored").addText((text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
      this.plugin.settings.dailyNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Daily Notes Template Path").setDesc("Path to the template for daily notes").addText((text) => text.setPlaceholder("Templates/Daily Notes Template.md").setValue(this.plugin.settings.dailyNotesTemplatePath).onChange(async (value) => {
      this.plugin.settings.dailyNotesTemplatePath = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Settings" });
    new import_obsidian.Setting(containerEl).setName("Consecutive Flextime Warning Days").setDesc("Number of consecutive days with flextime before showing a warning").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.consecutiveFlextimeWarningDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.consecutiveFlextimeWarningDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Heatmap Columns").setDesc("Number of columns in the heatmap view (adjust for your screen width)").addText((text) => text.setPlaceholder("48").setValue(this.plugin.settings.heatmapColumns.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.heatmapColumns = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Update Interval (ms)").setDesc("How often to update the dashboard data (in milliseconds)").addText((text) => text.setPlaceholder("30000").setValue(this.plugin.settings.updateInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.updateInterval = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Note Types" });
    containerEl.createEl("p", {
      text: "Configure the types of notes available in the calendar context menu. Each note type can have its own template, folder, and filename pattern.",
      cls: "setting-item-description"
    });
    this.plugin.settings.noteTypes.forEach((noteType, index) => {
      new import_obsidian.Setting(containerEl).setName(`${noteType.icon} ${noteType.label}`).setDesc(`Folder: ${noteType.folder} | Template: ${noteType.template}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        this.showNoteTypeModal(noteType, index);
      })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        this.plugin.settings.noteTypes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.refreshView();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Add New Note Type").setDesc("Create a new note type for the context menu").addButton((button) => button.setButtonText("+ Add Note Type").setCta().onClick(() => {
      this.showNoteTypeModal(null, -1);
    }));
    containerEl.createEl("h3", { text: "Data Management" });
    new import_obsidian.Setting(containerEl).setName("Export Data to CSV").setDesc("Export all your time tracking data to a CSV file").addButton((button) => button.setButtonText("Export CSV").setCta().onClick(async () => {
      this.exportToCSV();
    }));
    new import_obsidian.Setting(containerEl).setName("Import Timekeep Data").setDesc("Import time tracking data from Timekeep JSON format").addButton((button) => button.setButtonText("Import Data").setCta().onClick(async () => {
      this.showImportModal();
    }));
  }
  exportToCSV() {
    const entries = this.plugin.timerManager.convertToTimeEntries();
    const rows = [["Name", "Start Time", "End Time", "Duration (hours)"]];
    entries.forEach((entry) => {
      if (entry.startTime && entry.endTime) {
        const start = new Date(entry.startTime);
        const end = new Date(entry.endTime);
        const durationHours = ((end.getTime() - start.getTime()) / (1e3 * 60 * 60)).toFixed(2);
        rows.push([
          entry.name,
          start.toISOString(),
          end.toISOString(),
          durationHours
        ]);
      }
    });
    const csv = rows.map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian.Notice("\u2705 Exported to CSV");
  }
  showImportModal() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Import Timekeep Data");
    const { contentEl } = modal;
    contentEl.createEl("p", {
      text: "Paste your Timekeep JSON data below. This can be from a timekeep codeblock or exported data.",
      cls: "setting-item-description"
    });
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "15",
        placeholder: '{"entries":[...]}'
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} How to get your data:" });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: "Open your file with Timekeep codeblocks" });
    list.createEl("li", { text: "Copy the entire JSON from inside the timekeep block" });
    list.createEl("li", { text: "Paste it in the text area above" });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const importBtn = buttonDiv.createEl("button", { text: "Import", cls: "mod-cta" });
    importBtn.onclick = async () => {
      const jsonText = textArea.value.trim();
      if (!jsonText) {
        new import_obsidian.Notice("\u26A0\uFE0F Please paste your Timekeep data");
        return;
      }
      try {
        const data = JSON.parse(jsonText);
        if (!data.entries || !Array.isArray(data.entries)) {
          new import_obsidian.Notice('\u26A0\uFE0F Invalid format: missing "entries" array');
          return;
        }
        if (data.entries.length > 0) {
          const firstEntry = data.entries[0];
          if (!firstEntry.hasOwnProperty("name") || !firstEntry.hasOwnProperty("startTime")) {
            new import_obsidian.Notice("\u26A0\uFE0F Invalid entry format: missing required fields (name, startTime)");
            return;
          }
        }
        const success = await this.plugin.timerManager.importTimekeepData(jsonText);
        if (success) {
          modal.close();
          await this.refreshView();
        }
      } catch (error) {
        if (error instanceof SyntaxError) {
          new import_obsidian.Notice("\u26A0\uFE0F Invalid JSON format. Please check your data.");
        } else {
          new import_obsidian.Notice(`\u274C Error: ${error.message}`);
        }
        console.error("Import error:", error);
      }
    };
    const hint = contentEl.createEl("div");
    hint.style.marginTop = "10px";
    hint.style.fontSize = "12px";
    hint.style.color = "var(--text-muted)";
    hint.textContent = '\u{1F4A1} Tip: You can also create "TimeFlow Data.md" manually in your vault root';
    modal.open();
  }
  showNoteTypeModal(noteType, index) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText(noteType ? "Edit Note Type" : "Add Note Type");
    const { contentEl } = modal;
    const formData = {
      id: (noteType == null ? void 0 : noteType.id) || "",
      label: (noteType == null ? void 0 : noteType.label) || "",
      icon: (noteType == null ? void 0 : noteType.icon) || "\u{1F4C4}",
      folder: (noteType == null ? void 0 : noteType.folder) || "",
      template: (noteType == null ? void 0 : noteType.template) || "",
      tags: (noteType == null ? void 0 : noteType.tags.join(", ")) || "",
      filenamePattern: (noteType == null ? void 0 : noteType.filenamePattern) || "{YYYY}-{MM}-{DD}"
    };
    new import_obsidian.Setting(contentEl).setName("ID").setDesc("Unique identifier for this note type (lowercase, no spaces)").addText((text) => {
      text.setPlaceholder("meeting").setValue(formData.id).onChange((value) => {
        formData.id = value.toLowerCase().replace(/\s+/g, "-");
      });
      if (noteType) {
        text.inputEl.disabled = true;
      }
    });
    new import_obsidian.Setting(contentEl).setName("Label").setDesc("Display name shown in the context menu").addText((text) => text.setPlaceholder("M\xF8tenotat").setValue(formData.label).onChange((value) => {
      formData.label = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Icon").setDesc("Emoji or icon to display (single character)").addText((text) => text.setPlaceholder("\u{1F465}").setValue(formData.icon).onChange((value) => {
      formData.icon = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Folder").setDesc("Folder where notes will be created").addText((text) => text.setPlaceholder("M\xF8ter").setValue(formData.folder).onChange((value) => {
      formData.folder = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Template Path").setDesc("Path to the template file (relative to vault root)").addText((text) => text.setPlaceholder("timeflow/templates/meeting-note.md").setValue(formData.template).onChange((value) => {
      formData.template = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Tags").setDesc("Comma-separated tags to add to notes (e.g., #m\xF8te, #timeflow)").addText((text) => text.setPlaceholder("#m\xF8te, #timeflow").setValue(formData.tags).onChange((value) => {
      formData.tags = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Filename Pattern").setDesc("Pattern for note filenames. Available: {YYYY}, {MM}, {DD}, {WEEK}").addText((text) => text.setPlaceholder("{YYYY}-{MM}-{DD} M\xF8te").setValue(formData.filenamePattern).onChange((value) => {
      formData.filenamePattern = value;
    }));
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginTop = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.style.fontSize = "0.9em";
    infoDiv.innerHTML = `
			<strong>\u{1F4CB} Pattern Variables:</strong>
			<ul style="margin: 8px 0 0 20px;">
				<li><code>{YYYY}</code> - Four-digit year (e.g., 2025)</li>
				<li><code>{MM}</code> - Two-digit month (e.g., 01)</li>
				<li><code>{DD}</code> - Two-digit day (e.g., 15)</li>
				<li><code>{WEEK}</code> - ISO week number (e.g., 07)</li>
			</ul>
		`;
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!formData.id || !formData.label || !formData.folder) {
        new import_obsidian.Notice("\u26A0\uFE0F Please fill in all required fields (ID, Label, Folder)");
        return;
      }
      const tagsArray = formData.tags.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      const newNoteType = {
        id: formData.id,
        label: formData.label,
        icon: formData.icon || "\u{1F4C4}",
        folder: formData.folder,
        template: formData.template,
        tags: tagsArray,
        filenamePattern: formData.filenamePattern || "{YYYY}-{MM}-{DD}"
      };
      if (index >= 0) {
        this.plugin.settings.noteTypes[index] = newNoteType;
      } else {
        const existingIndex = this.plugin.settings.noteTypes.findIndex((nt) => nt.id === newNoteType.id);
        if (existingIndex >= 0) {
          new import_obsidian.Notice("\u26A0\uFE0F A note type with this ID already exists");
          return;
        }
        this.plugin.settings.noteTypes.push(newNoteType);
      }
      await this.plugin.saveSettings();
      await this.refreshView();
      modal.close();
      this.display();
      new import_obsidian.Notice(`\u2705 Note type ${noteType ? "updated" : "added"} successfully`);
    };
    modal.open();
  }
};

// src/view.ts
var import_obsidian4 = require("obsidian");

// src/dataManager.ts
var import_obsidian2 = require("obsidian");
var DataManager = class {
  constructor(entries, settings, app) {
    this.daily = {};
    this.months = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.holidays = {};
    // Cache for expensive calculations
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries = entries;
    this.settings = settings;
    this.app = app;
    this.workdayHours = settings.baseWorkday * settings.workPercent;
    this.workweekHours = settings.baseWorkweek * settings.workPercent;
  }
  async loadHolidays() {
    const status = { success: false, message: "", count: 0, warning: null };
    try {
      const holidayFile = this.app.vault.getAbstractFileByPath(this.settings.holidaysFilePath);
      if (holidayFile && holidayFile instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(holidayFile);
        const lines = content.split("\n");
        lines.forEach((line) => {
          const match = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*(\w+)(?::half)?:\s*(.+)$/);
          if (match) {
            const [, date, type, description] = match;
            const isHalfDay = line.includes(":half:");
            this.holidays[date] = {
              type: type.trim().toLowerCase(),
              description: description.trim(),
              halfDay: isHalfDay
            };
          }
        });
        status.success = true;
        status.count = Object.keys(this.holidays).length;
        status.message = `Loaded ${status.count} planned days`;
        console.log(`Loaded ${status.count} future days`);
      } else {
        status.warning = `Holiday file not found: ${this.settings.holidaysFilePath}`;
        console.warn(status.warning);
      }
    } catch (error) {
      status.warning = `Error loading holidays: ${error.message}`;
      console.warn("Could not load future days file:", error);
    }
    return status;
  }
  isHoliday(dateStr) {
    return this.holidays.hasOwnProperty(dateStr);
  }
  getHolidayInfo(dateStr) {
    return this.holidays[dateStr] || null;
  }
  getDailyGoal(dateStr) {
    const date = new Date(dateStr);
    const isWeekend = Utils.isWeekend(date, this.settings);
    if (isWeekend)
      return 0;
    const holidayInfo = this.getHolidayInfo(dateStr);
    if (holidayInfo) {
      if (["ferie", "velferdspermisjon", "helligdag", "egenmelding"].includes(holidayInfo.type)) {
        return 0;
      }
      if (holidayInfo.halfDay) {
        return this.workdayHours / 2;
      }
    }
    return this.workdayHours;
  }
  processEntries() {
    this.rawEntries.forEach((e) => {
      if (!e.startTime)
        return;
      if (!e.endTime) {
        this.activeEntries.push(e);
        const start2 = Utils.parseDate(e.startTime);
        if (start2) {
          const dayKey2 = Utils.toLocalDateStr(start2);
          if (!this.activeEntriesByDate[dayKey2])
            this.activeEntriesByDate[dayKey2] = [];
          this.activeEntriesByDate[dayKey2].push(e);
        }
        return;
      }
      const start = Utils.parseDate(e.startTime);
      const end = Utils.parseDate(e.endTime);
      if (!start || !end)
        return;
      let duration = Utils.hoursDiff(start, end);
      if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
        const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
        duration = Math.max(0, duration - lunchBreakHours);
      }
      const dayKey = Utils.toLocalDateStr(start);
      if (!this.daily[dayKey])
        this.daily[dayKey] = [];
      this.daily[dayKey].push({ ...e, duration, date: start });
    });
    this.calculateFlextime();
    this.groupByMonths();
  }
  calculateFlextime() {
    for (let day in this.daily) {
      const dayGoal = this.getDailyGoal(day);
      this.daily[day].forEach((e) => {
        let flextime = 0;
        const name = e.name.toLowerCase();
        if (name === "avspasering") {
          flextime -= e.duration || 0;
        } else if (dayGoal === 0) {
          flextime += e.duration || 0;
        } else {
          if ((e.duration || 0) > dayGoal) {
            flextime += (e.duration || 0) - dayGoal;
          }
        }
        e.flextime = flextime;
      });
    }
  }
  groupByMonths() {
    for (let day of Object.keys(this.daily)) {
      const date = new Date(day);
      const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
      if (!this.months[monthKey])
        this.months[monthKey] = {};
      const weekNum = Math.ceil((date.getDate() - date.getDay() + 1) / 7);
      if (!this.months[monthKey][weekNum])
        this.months[monthKey][weekNum] = [];
      this.months[monthKey][weekNum].push(...this.daily[day]);
    }
  }
  getOngoing() {
    const now = /* @__PURE__ */ new Date();
    return this.activeEntries.reduce((sum, e) => {
      const start = Utils.parseDate(e.startTime);
      return start ? sum + Utils.hoursDiff(start, now) : sum;
    }, 0);
  }
  getBalanceUpToDate(endDate) {
    let balance = 0;
    const startDate = "2025-11-05";
    const sortedDays = Object.keys(this.daily).filter((day) => day >= startDate && day <= endDate).sort();
    for (const day of sortedDays) {
      const dayGoal = this.getDailyGoal(day);
      const dayEntries = this.daily[day] || [];
      let dayWorked = 0;
      let avspaseringHours = 0;
      dayEntries.forEach((e) => {
        if (e.name.toLowerCase() === "avspasering") {
          avspaseringHours += e.duration || 0;
        } else {
          dayWorked += e.duration || 0;
        }
      });
      if (dayGoal === 0) {
        balance += dayWorked;
      } else {
        balance += dayWorked - dayGoal;
      }
      balance -= avspaseringHours;
    }
    return balance;
  }
  getCurrentBalance() {
    const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    return this.getBalanceUpToDate(today);
  }
  getTotalFlextime() {
    return this.getCurrentBalance();
  }
  getCurrentWeekHours(today) {
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    const lastDayOfWeek = new Date(firstDayOfWeek);
    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
    let total = 0;
    for (let d = new Date(firstDayOfWeek); d <= lastDayOfWeek; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "egenmelding" && name !== "velferdspermisjon" && name !== "ferie") {
          total += entry.duration || 0;
        }
      });
    }
    return total + this.getOngoing();
  }
  getTodayHours(today) {
    const todayKey = Utils.toLocalDateStr(today);
    const todayEntries = this.daily[todayKey] || [];
    return todayEntries.reduce((sum, e) => sum + (e.duration || 0), 0) + this.getOngoing();
  }
  getAverages() {
    if (this._cachedAverages) {
      return this._cachedAverages;
    }
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const pastKeys = Object.keys(this.daily).filter((d) => d < todayKey);
    const weekdayKeys = pastKeys.filter((dk) => {
      const date = Utils.parseDate(dk);
      return date && !Utils.isWeekend(date, this.settings);
    });
    const totalHoursWorked = weekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const avgDaily = weekdayKeys.length > 0 ? totalHoursWorked / weekdayKeys.length : 0;
    const avgWeekly = totalHoursWorked / (weekdayKeys.length / this.settings.workdaysPerWeek || 1);
    this._cachedAverages = {
      avgDaily,
      avgWeekly,
      totalDaysWorked: weekdayKeys.length,
      totalHoursWorked
    };
    return this._cachedAverages;
  }
  getStatistics(timeframe = "total") {
    const today = /* @__PURE__ */ new Date();
    let filterFn;
    if (timeframe === "year") {
      const currentYear = today.getFullYear();
      filterFn = (dateStr) => new Date(dateStr).getFullYear() === currentYear;
    } else if (timeframe === "month") {
      const currentYear = today.getFullYear();
      const currentMonth = today.getMonth();
      filterFn = (dateStr) => {
        const d = new Date(dateStr);
        return d.getFullYear() === currentYear && d.getMonth() === currentMonth;
      };
    } else {
      filterFn = () => true;
    }
    const filteredDays = Object.keys(this.daily).filter(filterFn);
    const allEntries = filteredDays.flatMap((day) => this.daily[day]);
    const stats = {
      totalHours: allEntries.reduce((sum, e) => sum + (e.duration || 0), 0),
      totalFlextime: allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0),
      jobb: { count: 0, hours: 0 },
      avspasering: { count: 0, hours: 0, planned: 0 },
      ferie: { count: 0, hours: 0, max: this.settings.maxFerieDays, planned: 0 },
      velferdspermisjon: { count: 0, hours: 0, planned: 0 },
      egenmelding: { count: 0, hours: 0, max: this.settings.maxEgenmeldingDays },
      sykemelding: { count: 0, hours: 0 },
      studie: { count: 0, hours: 0, planned: 0 },
      kurs: { count: 0, hours: 0, planned: 0 },
      workDays: 0,
      weekendDays: 0,
      weekendHours: 0,
      avgDailyHours: 0,
      workloadPercent: 0
    };
    const daysByType = {
      jobb: /* @__PURE__ */ new Set(),
      avspasering: /* @__PURE__ */ new Set(),
      ferie: /* @__PURE__ */ new Set(),
      velferdspermisjon: /* @__PURE__ */ new Set(),
      egenmelding: /* @__PURE__ */ new Set(),
      sykemelding: /* @__PURE__ */ new Set(),
      studie: /* @__PURE__ */ new Set(),
      kurs: /* @__PURE__ */ new Set()
    };
    const uniqueDays = /* @__PURE__ */ new Set();
    const weekendDaysSet = /* @__PURE__ */ new Set();
    const workDaysSet = /* @__PURE__ */ new Set();
    filteredDays.forEach((dayKey) => {
      const dayDate = new Date(dayKey);
      const dayEntries = this.daily[dayKey];
      uniqueDays.add(dayKey);
      dayEntries.forEach((e) => {
        const name = e.name.toLowerCase();
        if (e.date && Utils.isWeekend(e.date, this.settings)) {
          weekendDaysSet.add(dayKey);
          stats.weekendHours += e.duration || 0;
        } else {
          workDaysSet.add(dayKey);
        }
        if (name === "jobb" || !["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType.jobb.add(dayKey);
          stats.jobb.hours += e.duration || 0;
        } else if (["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType[name].add(dayKey);
          stats[name].hours += e.duration || 0;
        }
      });
    });
    stats.weekendDays = weekendDaysSet.size;
    stats.workDays = workDaysSet.size;
    stats.jobb.count = daysByType.jobb.size;
    stats.avspasering.count = daysByType.avspasering.size;
    stats.ferie.count = daysByType.ferie.size;
    stats.velferdspermisjon.count = daysByType.velferdspermisjon.size;
    stats.egenmelding.count = daysByType.egenmelding.size;
    stats.studie.count = daysByType.studie.size;
    stats.kurs.count = daysByType.kurs.size;
    Object.keys(this.holidays).forEach((dateStr) => {
      const plannedInfo = this.holidays[dateStr];
      const plannedDate = new Date(dateStr);
      if (filterFn(dateStr) && plannedDate > today) {
        const type = plannedInfo.type;
        if (type === "ferie" && stats.ferie) {
          stats.ferie.planned++;
        } else if (type === "avspasering" && stats.avspasering) {
          stats.avspasering.planned++;
        } else if (type === "velferdspermisjon" && stats.velferdspermisjon) {
          stats.velferdspermisjon.planned++;
        } else if (type === "studie" && stats.studie) {
          stats.studie.planned++;
        } else if (type === "kurs" && stats.kurs) {
          stats.kurs.planned++;
        }
      }
    });
    stats.avgDailyHours = uniqueDays.size > 0 ? stats.totalHours / uniqueDays.size : 0;
    if (timeframe === "year" || timeframe === "month") {
      const expectedWorkdays = timeframe === "year" ? this.settings.workdaysPerYear : this.settings.workdaysPerMonth;
      const expectedHours = expectedWorkdays * this.workdayHours;
      stats.workloadPercent = expectedHours > 0 ? stats.totalHours / expectedHours * 100 : 0;
    }
    return stats;
  }
  getContextualData(today) {
    const todayKey = Utils.toLocalDateStr(today);
    if (this._cachedContextData[todayKey]) {
      return this._cachedContextData[todayKey];
    }
    const weekday = today.getDay();
    let consecutiveFlextimeDays = 0;
    const sortedDays = Object.keys(this.daily).sort().reverse();
    for (let day of sortedDays) {
      if (day >= todayKey)
        continue;
      const dayFlextime = this.daily[day].reduce(
        (sum, e) => sum + (e.flextime || 0),
        0
      );
      if (dayFlextime > 0) {
        consecutiveFlextimeDays++;
      } else {
        break;
      }
    }
    const sameWeekdayKeys = Object.keys(this.daily).filter((d) => {
      const date = new Date(d);
      return date.getDay() === weekday && d < todayKey;
    });
    const sameDayTotal = sameWeekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const sameDayAvg = sameWeekdayKeys.length > 0 ? sameDayTotal / sameWeekdayKeys.length : 0;
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const thisWeekMonday = new Date(today);
    thisWeekMonday.setDate(today.getDate() - daysFromMonday);
    const lastWeekStart = new Date(thisWeekMonday);
    lastWeekStart.setDate(thisWeekMonday.getDate() - 7);
    const lastWeekEnd = new Date(lastWeekStart);
    lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
    let lastWeekHours = 0;
    for (let d = new Date(lastWeekStart); d <= lastWeekEnd; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      lastWeekHours += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
    }
    const result = { consecutiveFlextimeDays, sameDayAvg, lastWeekHours };
    this._cachedContextData[todayKey] = result;
    return result;
  }
  getWeekTotals(numWeeks = 8) {
    const today = /* @__PURE__ */ new Date();
    const weekTotals = [];
    for (let i = numWeeks - 1; i >= 0; i--) {
      const d = new Date(today);
      d.setDate(today.getDate() - i * 7);
      const dayOfWeek = d.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const weekStart = new Date(d);
      weekStart.setDate(d.getDate() - daysFromMonday);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      let weekSum = 0;
      for (let wd = new Date(weekStart); wd <= weekEnd; wd = new Date(wd.getFullYear(), wd.getMonth(), wd.getDate() + 1)) {
        const dayKey = Utils.toLocalDateStr(wd);
        const dayEntries = this.daily[dayKey] || [];
        weekSum += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
      }
      weekTotals.push(weekSum);
    }
    return weekTotals;
  }
  validateData() {
    const issues = {
      errors: [],
      warnings: [],
      info: [],
      stats: {
        totalEntries: 0,
        entriesChecked: 0,
        entriesWithIssues: 0
      }
    };
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const createIssue = (severity, type, description, entry, dayKey) => {
      issues.stats.entriesWithIssues++;
      return {
        severity,
        type,
        description,
        date: dayKey,
        entry: {
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          duration: entry.duration
        }
      };
    };
    for (const dayKey in this.daily) {
      const dayEntries = this.daily[dayKey];
      issues.stats.totalEntries += dayEntries.length;
      dayEntries.forEach((entry) => {
        var _a, _b, _c;
        issues.stats.entriesChecked++;
        if (!entry.name || entry.name.trim() === "") {
          issues.errors.push(createIssue(
            "error",
            "Missing Entry Name",
            "Entry has no name/type",
            entry,
            dayKey
          ));
        }
        if (!entry.startTime) {
          issues.errors.push(createIssue(
            "error",
            "Missing Start Time",
            "Entry has no start time",
            entry,
            dayKey
          ));
          return;
        }
        if ((entry.duration || 0) < 0) {
          issues.errors.push(createIssue(
            "error",
            "Negative Duration",
            `End time is before start time (${(_a = entry.duration) == null ? void 0 : _a.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > 24) {
          issues.errors.push(createIssue(
            "error",
            "Excessive Duration",
            `Entry spans more than 24 hours (${(_b = entry.duration) == null ? void 0 : _b.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > 16 && (entry.duration || 0) <= 24) {
          issues.warnings.push(createIssue(
            "warning",
            "Very Long Session",
            `Entry duration exceeds 16 hours (${(_c = entry.duration) == null ? void 0 : _c.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) === 0) {
          issues.info.push(createIssue(
            "info",
            "Zero Duration",
            "Entry has zero duration",
            entry,
            dayKey
          ));
        }
        if (dayKey > todayStr) {
          issues.info.push(createIssue(
            "info",
            "Future Date",
            "Entry is dated in the future",
            entry,
            dayKey
          ));
        }
      });
    }
    issues.stats.totalEntries += this.activeEntries.length;
    this.activeEntries.forEach((entry) => {
      issues.stats.entriesChecked++;
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        const now = /* @__PURE__ */ new Date();
        const hoursRunning = Utils.hoursDiff(startTime, now);
        if (hoursRunning > 12) {
          issues.warnings.push({
            severity: "warning",
            type: "Long-Running Timer",
            description: `Active timer has been running for ${hoursRunning.toFixed(1)} hours`,
            date: Utils.toLocalDateStr(startTime),
            entry: {
              name: entry.name,
              startTime: entry.startTime,
              duration: hoursRunning
            }
          });
          issues.stats.entriesWithIssues++;
        }
      }
    });
    const currentWeekHours = this.getCurrentWeekHours(today);
    if (currentWeekHours > 60) {
      issues.info.push({
        severity: "info",
        type: "High Weekly Total",
        description: `Current week total exceeds 60 hours (${currentWeekHours.toFixed(1)}h)`,
        date: todayStr
      });
    }
    return {
      hasErrors: issues.errors.length > 0,
      hasWarnings: issues.warnings.length > 0,
      hasInfo: issues.info.length > 0,
      issues,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};

// src/uiBuilder.ts
var import_obsidian3 = require("obsidian");

// src/messageGenerator.ts
var MessageGenerator = class {
  static getDailyMessage(hours, goal, specials, isWeekendDay, avgDaily, context, consecutiveFlextimeWarningDays) {
    if (isWeekendDay) {
      const weekday = (/* @__PURE__ */ new Date()).getDay();
      if (weekday === 6) {
        if (hours === 0)
          return Utils.randMsg([
            "L\xF8rdag \u2013 ingen logg enn\xE5, perfekt for fri \u{1F6CC}",
            "Fri-modus: nyt l\xF8rdagen! \u{1F324}\uFE0F"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "Litt helgeinnsats \u2013 godt gjort!",
            "Rolig l\xF8rdag med litt arbeid \u2013 fin balanse \u2696\uFE0F"
          ]);
        return Utils.randMsg([
          "\u{1F525} Jobbing p\xE5 l\xF8rdagen \u2013 imponerende dedikasjon!",
          "L\xF8rdag med driv \u2013 pass p\xE5 \xE5 hvile litt ogs\xE5 \u{1F486}"
        ]);
      }
      if (weekday === 0) {
        if (hours === 0)
          return Utils.randMsg([
            "S\xF8ndag \u2013 helt fri, slik det skal v\xE6re \u2615",
            "S\xF8ndag \u2013 lade opp til en ny uke \u{1F33F}"
          ]);
        return Utils.randMsg([
          "Litt s\xF8ndagsjobbing \u2013 godt for samvittigheten \u{1F4AA}",
          "Rolig s\xF8ndag med litt innsats \u2013 flott balansert \u{1F31E}"
        ]);
      }
    }
    if (specials.length > 0) {
      const s = specials.join(", ").toLowerCase();
      const now2 = /* @__PURE__ */ new Date();
      const currentHour2 = now2.getHours();
      if (s.includes("ferie")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u2600\uFE0F Feriemorgen \u2013 sov lenge og slapp av!",
            "\u{1F3D6}\uFE0F Ferie \u2013 ingen tidlig start i dag!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u2600\uFE0F Nyt ferien \u2013 du har fortjent det!",
            "\u{1F334} Feriedag \u2013 gj\xF8r noe hyggelig!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Feriekveld \u2013 kos deg!",
          "\u2728 Ferieflyt \u2013 nyt kvelden!"
        ]);
      }
      if (s.includes("velferdspermisjon")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 ta vare p\xE5 deg selv",
            "\u{1F49A} Viktig dag for velv\xE6re \u2013 bruk tiden godt"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 h\xE5per alt g\xE5r bra",
            "\u{1F49A} Ta den tiden du trenger i dag"
          ]);
        return Utils.randMsg([
          "\u{1F319} Velferdspermisjon \u2013 hvil og ta vare p\xE5 deg",
          "\u2728 Viktig \xE5 prioritere eget velv\xE6re"
        ]);
      }
      if (s.includes("avspasering")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F6CC} Avspasering \u2013 perfekt dag for litt ekstra s\xF8vn!",
            "\u{1F634} Fri dag \u2013 du har fortjent denne hvilen!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F6CC} Godt med litt fri \u2013 du har fortjent det!",
            "\u{1F486} Avspasering \u2013 bruk dagen p\xE5 noe du liker!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Avspasering \u2013 slapp av resten av kvelden!",
          "\u2728 Fin fridag \u2013 h\xE5per du har hatt en god dag!"
        ]);
      }
      if (s.includes("egenmelding")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F912} Egenmelding \u2013 hvil og bli frisk!",
            "\u{1F48A} Ta det rolig \u2013 kroppen trenger hvile!"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "\u{1F912} Egenmelding, men du har v\xE6rt litt aktiv \u2013 ikke overdriv!",
            "\u{1F48A} H\xE5per du f\xF8ler deg bedre \u2013 husk \xE5 hvile!"
          ]);
        return Utils.randMsg([
          "\u{1F912} Egenmelding med mye aktivitet \u2013 pass p\xE5 \xE5 ikke presse deg!",
          "\u{1F48A} Ta vare p\xE5 deg selv \u2013 hvil er viktig!"
        ]);
      }
      if (s.includes("studie") || s.includes("kurs")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F4D6} Studiedag \u2013 tid for \xE5 l\xE6re noe nytt!",
            "\u{1F4DA} Studietid \u2013 lykke til med l\xE6ringen!"
          ]);
        if (hours < 3)
          return Utils.randMsg([
            "\u{1F4D6} God start p\xE5 studiedagen \u2013 fortsett s\xE5nn!",
            "\u{1F4DA} Fin studieflyt s\xE5 langt!"
          ]);
        if (hours < 5)
          return Utils.randMsg([
            "\u{1F4D6} Solid studieinnsats \u2013 godt jobbet!",
            "\u{1F4DA} Du l\xE6rer mye i dag \u2013 flott fremgang!"
          ]);
        return Utils.randMsg([
          "\u{1F4D6} Imponerende studieinnsats i dag \u2013 husk pauser!",
          "\u{1F4DA} Dedikert studiedag \u2013 fantastisk innsats!"
        ]);
      }
    }
    const diff = hours - goal;
    const now = /* @__PURE__ */ new Date();
    const currentHour = now.getHours();
    if (context.consecutiveFlextimeDays >= consecutiveFlextimeWarningDays) {
      return `\u26A0\uFE0F ${context.consecutiveFlextimeDays} dager p\xE5 rad med fleksitid \u2013 husk \xE5 ta vare p\xE5 deg selv!`;
    }
    if (context.sameDayAvg > 0) {
      const weekdayName = [
        "s\xF8ndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "l\xF8rdag"
      ][now.getDay()];
      if (hours > context.sameDayAvg + 1) {
        return `Mer aktiv enn vanlig for en ${weekdayName} \u{1F4AA} (snitt: ${context.sameDayAvg.toFixed(1)}t)`;
      }
      if (hours < context.sameDayAvg - 1 && hours > 2) {
        return `Roligere ${weekdayName} enn vanlig (snitt: ${context.sameDayAvg.toFixed(1)}t) \u{1F33F}`;
      }
    }
    if (currentHour < 12 && hours === 0) {
      return "God morgen! Dagen starter rolig \u2615";
    }
    if (currentHour >= 15 && diff < -2) {
      const hoursNeeded = (goal - hours).toFixed(1);
      return `${hoursNeeded}t igjen for \xE5 n\xE5 dagsm\xE5l \u2013 fortsatt mulig! \u{1F3AF}`;
    }
    if (currentHour >= 16 && hours >= goal) {
      return "Dagsm\xE5l n\xE5dd! \u{1F389} Ta en pause eller jobb videre mot fleksitid.";
    }
    if (avgDaily > 0) {
      if (hours > avgDaily + 1)
        return "Du ligger over snittet for de siste dagene \u{1F44D}";
      if (hours < avgDaily - 1)
        return "Litt roligere enn vanlig \u2013 fullt fortjent \u{1F486}";
    }
    if (hours === 0)
      return "Rolig start \u2013 kanskje planlegg dagen?";
    if (diff < -1)
      return "Dagen har s\xE5 vidt begynt \u2013 god tid til \xE5 n\xE5 m\xE5let.";
    if (diff >= -1 && diff <= 1)
      return "Du ligger helt perfekt an i dag \u{1F44C}";
    if (diff > 1 && diff <= 2)
      return "Sterk innsats \u2013 n\xE6rmer deg fleksitid \u{1F4AA}";
    if (diff > 2)
      return "\u{1F680} Ekstra innsats i dag! Husk \xE5 ta deg tid til en pause.";
    return "";
  }
  static getWeeklyMessage(hours, goal, specials, today, context, weekendWorkHours = 0) {
    const ferie = specials.some((s) => s.toLowerCase().includes("ferie"));
    const velferdspermisjon = specials.some((s) => s.toLowerCase().includes("velferdspermisjon"));
    const avsp = specials.some((s) => s.toLowerCase().includes("avspasering"));
    const studie = specials.some((s) => s.toLowerCase().includes("studie") || s.toLowerCase().includes("kurs"));
    if (ferie)
      return "\u{1F3D6}\uFE0F Ukas rytme er preget av ferie \u2013 nyt det! ";
    if (velferdspermisjon)
      return "\u{1F3E5} Velferdspermisjon denne uka \u2013 ta vare p\xE5 deg selv! ";
    if (avsp)
      return "\u{1F60C} Litt fri denne uka \u2013 god balanse. ";
    if (studie)
      return "\u{1F4DA} Denne uka har du prioritert studier \u2013 flott! ";
    const weekday = today.getDay();
    const isWeekendDay = weekday === 6 || weekday === 0;
    const workdaysPassed = Math.min(Math.max(weekday - 1, 0), 5);
    const totalWorkdays = 5;
    const expectedProgress = workdaysPassed / totalWorkdays * goal;
    const diffFromExpected = hours - expectedProgress;
    if (context.lastWeekHours > 0) {
      const diff2 = hours - context.lastWeekHours;
      if (Math.abs(diff2) > 5 && workdaysPassed >= 3) {
        if (diff2 > 0) {
          return `Mer travelt enn forrige uke (+${diff2.toFixed(1)}t) \u{1F4C8} `;
        } else {
          return `Roligere enn forrige uke (${diff2.toFixed(1)}t) \u{1F4C9} `;
        }
      }
    }
    if (isWeekendDay) {
      if (weekendWorkHours === 0)
        return "\u{1F319} Helg! Godt jobbet denne uka \u2013 nyt fritiden. ";
      if (weekendWorkHours < 2)
        return "\u{1F4C5} Litt helgeinnsats \u2013 ikke glem pauser og p\xE5fyll! ";
      if (hours >= goal)
        return "\u{1F525} Jobbing i helga \u2013 imponerende dedikasjon, men pass p\xE5 \xE5 hvile! ";
      return "\u{1F31E} En rolig helg etter en balansert uke. ";
    }
    if (workdaysPassed <= 1) {
      if (hours < expectedProgress)
        return "Uka er i gang \u2013 ta det i eget tempo \u{1F4AA} ";
      if (diffFromExpected >= 1)
        return "Sterk start p\xE5 uka! \u{1F31F} ";
      return "Fin rytme s\xE5 langt \u2013 fortsett s\xE5nn. ";
    }
    if (workdaysPassed >= 2 && workdaysPassed <= 3) {
      if (diffFromExpected < -2)
        return "Du ligger litt bak skjema \u2013 men fortsatt god tid til \xE5 hente inn \u{1F33F} ";
      if (diffFromExpected >= -2 && diffFromExpected <= 2)
        return "Jevn og fin flyt gjennom uka \u{1F44C} ";
      if (diffFromExpected > 2)
        return "Travle dager \u2013 men du h\xE5ndterer det godt \u{1F4AA} ";
    }
    if (weekday === 5) {
      if (hours < goal * 0.8)
        return "Fredag \u2013 snart helg! Du er nesten i m\xE5l \u{1F3AF} ";
      if (hours >= goal && hours <= goal + 3)
        return "\u{1F44D} Uka i boks \u2013 god innsats! ";
      if (hours > goal + 3)
        return "\u{1F525} Ekstra innsats denne uka \u2013 husk \xE5 logge fleksitid! ";
      return "Fredagsflyt \u{1F324}\uFE0F ";
    }
    const diff = hours - goal;
    if (diff < -3)
      return "Du ligger litt bak skjema \u2013 ingen fare, uka er ung! ";
    if (diff >= -3 && diff <= 2)
      return "Fin flyt denne uka \u{1F33F} ";
    if (diff > 2 && diff <= 5)
      return "Travelt, men godt jobbet! ";
    if (diff > 5)
      return "\u{1F525} Ekstra innsats denne uka \u2013 pass p\xE5 hvilen! ";
    return "";
  }
};

// src/uiBuilder.ts
var UIBuilder = class {
  constructor(dataManager, systemStatus, settings, app, timerManager) {
    this.intervals = [];
    this.statsTimeframe = "total";
    this.historyView = "list";
    this.currentMonthOffset = 0;
    this.data = dataManager;
    this.systemStatus = systemStatus;
    this.settings = settings;
    this.app = app;
    this.timerManager = timerManager;
    this.container = this.createContainer();
    this.today = /* @__PURE__ */ new Date();
    this.elements = {
      badge: null,
      timerBadge: null,
      clock: null,
      dayCard: null,
      weekCard: null,
      statsCard: null,
      monthCard: null
    };
  }
  createContainer() {
    const container = document.createElement("div");
    container.style.fontFamily = "sans-serif";
    container.style.maxWidth = "1200px";
    container.style.margin = "0 auto";
    container.style.padding = "20px";
    container.className = `timeflow-theme-${this.settings.theme}`;
    return container;
  }
  injectStyles() {
    const styleId = "timeflow-styles";
    if (document.getElementById(styleId))
      return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
			/* TimeFlow Dashboard Styles */
			.timeflow-dashboard {
				font-family: var(--font-text);
				padding: 20px;
				width: 100%;
			}

			.timeflow-error, .timeflow-warning {
				padding: 15px;
				border-radius: 5px;
				margin: 10px 0;
			}

			.timeflow-error {
				background: var(--background-modifier-error);
				color: var(--text-error);
			}

			.timeflow-warning {
				background: var(--background-modifier-warning);
				color: var(--text-warning);
			}

			/* Pulse animation for active entry indicator */
			@keyframes pulse {
				0%, 100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.6;
					transform: scale(1.1);
				}
			}

			.tf-badge-section {
				display: flex;
				align-items: stretch;
				margin: 16px 0;
				flex-wrap: wrap;
				gap: 12px;
			}

			/* Desktop: timer button on top right */
			@media (min-width: 601px) {
				.tf-badge-section {
					justify-content: space-between;
				}
				.tf-timer-badge {
					order: 3;
					margin-left: auto;
				}
				.tf-badge {
					order: 1;
				}
				.tf-clock {
					order: 2;
				}
			}

			@media (max-width: 600px) {
				.tf-badge-section {
					flex-direction: column;
					align-items: stretch;
				}
				.tf-badge-section > * {
					width: 100% !important;
					max-width: 100% !important;
				}
			}

			.tf-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			/* Light theme - Clock badge uses the same gradient as other light elements */
			.tf-clock {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				color: #1a1a1a;
				font-weight: bold;
				font-variant-numeric: tabular-nums;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			/* Dark theme - Clock badge uses consistent dark gradient */
			.timeflow-theme-dark .tf-clock {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				color: #e0e0e0;
			}

			/* System theme - Clock badge adapts to Obsidian theme */
			.timeflow-theme-system .tf-clock {
				background: var(--background-primary-alt);
				color: var(--text-normal);
				border: 1px solid var(--background-modifier-border);
			}

			.tf-timer-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
				white-space: normal;
				text-align: center;
				min-height: 44px;
				cursor: pointer;
				transition: all 0.2s;
				border: none;
				font-family: inherit;
				font-size: inherit;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				/* Background colors are set dynamically based on timer state */
			}

			.tf-timer-badge:hover {
				transform: translateY(-1px);
				box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			}

			.tf-timer-badge:active {
				transform: translateY(0);
			}

			.tf-summary-cards {
				display: grid;
				grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
				gap: 15px;
				margin-bottom: 20px;
			}

			/* Day and week cards stay side-by-side in row 1, calendar always below in row 2 */
			.tf-card-month {
				grid-column: 1 / -1; /* Calendar takes full width below */
			}

			/* On mobile, stack everything vertically */
			@media (max-width: 500px) {
				.tf-summary-cards {
					grid-template-columns: 1fr;
				}

				.tf-card-month {
					grid-column: 1;
				}
			}

			/* Default card styling - used for month card */
			.tf-card {
				padding: 20px;
				border-radius: 12px;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				color: #1a1a1a;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			}

			.tf-card-spaced {
				margin-top: 24px;
			}

			.tf-card h3 {
				margin-top: 0;
				margin-bottom: 15px;
				font-size: 18px;
				color: #1a1a1a;
			}

			/* Daily and Weekly cards use dynamic backgrounds set in updateDayCard/updateWeekCard */
			.tf-card-day,
			.tf-card-week {
				/* Background and color set dynamically based on progress */
			}

			/* System theme - match Obsidian's theme */
			.timeflow-theme-system .tf-card {
				background: var(--background-primary-alt);
				color: var(--text-normal);
				border: 1px solid var(--background-modifier-border);
			}

			.timeflow-theme-system .tf-card h3 {
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-card-stats {
				background: var(--background-primary-alt) !important;
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-stats h3 {
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-history {
				background: var(--background-primary-alt) !important;
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-history h3 {
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-stat-item {
				background: var(--background-secondary);
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-stat-label {
				color: var(--text-muted);
			}

			.timeflow-theme-system .tf-stat-value {
				color: var(--text-normal);
			}

			/* System theme - ensure all text inside stat items is readable */
			.timeflow-theme-system .tf-stat-item div {
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-stat-item .tf-stat-label {
				color: var(--text-muted);
			}

			/* Dark theme - internally consistent with dark greens and blues */
			.timeflow-theme-dark .tf-card {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				color: #e0e0e0;
			}

			.timeflow-theme-dark .tf-card h3 {
				color: #e0e0e0;
			}

			.timeflow-theme-dark .tf-badge {
				/* Badge colors are set dynamically in updateBadge() */
			}

			/* Light theme - Progress bar */
			.tf-progress-bar {
				width: 100%;
				height: 12px;
				background: #ddd;
				border-radius: 6px;
				overflow: hidden;
				margin: 10px 0;
			}

			.timeflow-theme-dark .tf-progress-bar {
				background: rgba(255, 255, 255, 0.1);
			}

			/* Light theme - Progress fill uses green gradient from timeflow.js */
			.tf-progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #4caf50, #2e7d32);
				transition: width 0.3s ease;
			}

			.timeflow-theme-dark .tf-progress-fill {
				background: linear-gradient(90deg, #4caf50, #2e7d32);
			}

			.tf-month-grid {
				display: grid;
				grid-template-columns: repeat(7, 1fr);
				gap: 12px;
				margin-top: 15px;
			}

			/* Day cells - consistent text colors across all themes since backgrounds are always the same */
			.tf-day-cell {
				aspect-ratio: 1;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 6px;
				font-size: clamp(12px, 2.5vw, 16px);
				font-weight: bold;
				cursor: pointer;
				transition: all 0.2s;
				position: relative;
				border: 2px solid transparent;
				text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
			}

			/* Days with entries - black text in all themes */
			.tf-day-cell.has-entry {
				color: #000000;
			}

			/* Days without entries - dark grey text in all themes */
			.tf-day-cell.no-entry {
				color: #4a4a4a;
			}

			.tf-day-cell:hover {
				transform: scale(1.05);
				box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			}

			.tf-day-cell.today {
				border-color: #4caf50;
				font-weight: bold;
			}

			.timeflow-theme-system .tf-day-cell.today {
				border-color: var(--interactive-accent);
			}

			/* Light theme - Stats card uses green gradient from timeflow.js */
			.tf-card-stats {
				background: linear-gradient(135deg, #e8f5e9, #c8e6c9) !important;
				color: #1a1a1a !important;
			}

			.tf-card-stats h3 {
				color: #1a1a1a !important;
			}

			/* Dark theme - Stats card uses darker consistent greens */
			.timeflow-theme-dark .tf-card-stats {
				background: linear-gradient(135deg, #253d25, #2d4d3d) !important;
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-card-stats h3 {
				color: #e0e0e0 !important;
			}

			/* Light theme - History card uses darker green from timeflow.js */
			.tf-card-history {
				background: linear-gradient(135deg, #a8d5ab, #8dc491) !important;
				color: #1a1a1a !important;
			}

			.tf-card-history h3 {
				color: #1a1a1a !important;
			}

			/* Dark theme - History card uses consistent dark greens */
			.timeflow-theme-dark .tf-card-history {
				background: linear-gradient(135deg, #2d4528, #2d5035) !important;
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-card-history h3 {
				color: #e0e0e0 !important;
			}

			.tf-stats-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 15px;
				margin-top: 15px;
			}

			/* Light theme - Stat items match timeflow.js */
			.tf-stat-item {
				padding: 15px;
				background: rgba(155, 155, 155, 0.4);
				border-radius: 8px;
				color: #1a1a1a;
			}

			/* Dark theme - Stat items use semi-transparent white for consistency */
			.timeflow-theme-dark .tf-stat-item {
				background: rgba(255, 255, 255, 0.1);
				color: #e0e0e0;
			}

			.tf-stat-label {
				font-size: 12px;
				margin-bottom: 5px;
			}

			/* Light theme - stat labels should be dark but slightly muted */
			.tf-card-stats .tf-stat-label {
				color: rgba(26, 26, 26, 0.7);
			}

			/* Dark theme - stat labels should be light but slightly muted */
			.timeflow-theme-dark .tf-card-stats .tf-stat-label {
				color: rgba(224, 224, 224, 0.7);
			}

			.tf-stat-value {
				font-size: 20px;
				font-weight: bold;
			}

			/* Light theme - stat values should be dark */
			.tf-card-stats .tf-stat-value {
				color: #1a1a1a;
			}

			/* Dark theme - stat values should be light */
			.timeflow-theme-dark .tf-card-stats .tf-stat-value {
				color: #e0e0e0;
			}

			/* Timeframe label styling */
			.tf-timeframe-label {
				color: #1a1a1a;
			}

			.timeflow-theme-dark .tf-timeframe-label {
				color: #e0e0e0;
			}

			.timeflow-theme-system .tf-timeframe-label {
				color: var(--text-normal);
			}

			.tf-tabs {
				display: flex;
				gap: 8px;
				margin-bottom: 15px;
				border-bottom: 2px solid var(--background-modifier-border);
			}

			.tf-tab {
				padding: 6px 12px;
				cursor: pointer;
				border: none;
				background: rgba(0, 0, 0, 0.1);
				color: #1a1a1a !important;
				font-size: 0.9em;
				border-radius: 6px;
				transition: all 0.2s;
				font-weight: 500;
			}

			.tf-tab.active {
				background: rgba(0, 0, 0, 0.2);
				color: #1a1a1a !important;
				font-weight: bold;
			}

			.tf-tab:hover {
				background: rgba(0, 0, 0, 0.15);
				color: #1a1a1a !important;
			}

			.timeflow-theme-dark .tf-tab {
				background: rgba(255, 255, 255, 0.1);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-tab.active {
				background: rgba(255, 255, 255, 0.2);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-tab:hover {
				background: rgba(255, 255, 255, 0.15);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-system .tf-tab {
				background: var(--background-modifier-border);
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-tab.active {
				background: var(--interactive-accent);
				color: var(--text-on-accent) !important;
			}

			.timeflow-theme-system .tf-tab:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal) !important;
			}

			.tf-button {
				padding: 8px 16px;
				border-radius: 6px;
				border: 1px solid var(--background-modifier-border);
				background: var(--interactive-normal);
				color: var(--text-normal);
				cursor: pointer;
				font-size: 14px;
				transition: all 0.2s;
			}

			.tf-button:hover {
				background: var(--interactive-hover);
			}

			.tf-heatmap {
				display: grid;
				gap: 4px;
				margin-top: 15px;
			}

			.tf-heatmap-cell {
				width: 100%;
				aspect-ratio: 1;
				border-radius: 3px;
				cursor: pointer;
				transition: transform 0.2s;
			}

			.tf-heatmap-cell:hover {
				transform: scale(1.2);
			}

			/* Context menu - uses same styling as submenu for consistency */
			/* Context menu - uses Obsidian native styling for all themes */
			.tf-context-menu {
				position: absolute;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				z-index: 1000;
				min-width: 200px;
				display: flex;
				gap: 0;
			}

			.tf-context-menu-main {
				flex: 0 0 auto;
				min-width: 200px;
			}

			.tf-context-menu-info {
				flex: 0 0 auto;
				width: 250px;
				padding: 12px;
				border-left: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				font-size: 0.85em;
				line-height: 1.4;
			}

			.timeflow-theme-dark .tf-context-menu-info {
				background: rgba(0, 0, 0, 0.2);
			}

			.tf-context-menu-info h4 {
				margin: 0 0 8px 0;
				font-size: 0.95em;
				color: var(--text-normal);
			}

			.tf-context-menu-info p {
				margin: 4px 0;
				color: var(--text-muted);
			}

			.tf-context-menu-info strong {
				color: var(--text-normal);
			}

			.tf-menu-item {
				padding: 8px 16px;
				cursor: pointer;
				transition: background 0.2s;
				display: flex;
				align-items: center;
				gap: 10px;
				color: #1a1a1a;
			}

			.timeflow-theme-dark .tf-menu-item {
				color: #e0e0e0;
			}

			.timeflow-theme-system .tf-menu-item {
				color: var(--text-normal);
			}

			.tf-menu-item:hover {
				background: rgba(76, 175, 80, 0.2);
			}

			.timeflow-theme-system .tf-menu-item:hover {
				background: var(--background-modifier-hover);
			}

			.tf-menu-separator {
				height: 1px;
				background: rgba(0, 0, 0, 0.2);
				margin: 4px 0;
			}

			.timeflow-theme-dark .tf-menu-separator {
				background: rgba(255, 255, 255, 0.2);
			}

			.timeflow-theme-system .tf-menu-separator {
				background: var(--background-modifier-border);
			}

			/* Submenu styles */
			.tf-menu-item-with-submenu {
				position: relative;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.tf-submenu {
				display: none;
				position: absolute;
				left: 100%;
				top: 0;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				border: 2px solid #4caf50;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				min-width: 180px;
				z-index: 1001;
			}

			.timeflow-theme-dark .tf-submenu {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				border: 2px solid #4caf50;
			}

			.timeflow-theme-system .tf-submenu {
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
			}

			.tf-menu-item-with-submenu:hover .tf-submenu {
				display: block;
			}

			.tf-submenu-arrow {
				font-size: 0.8em;
				opacity: 0.7;
			}

			.tf-status-bar {
				margin-top: 20px;
				padding: 15px;
				background: var(--background-secondary-alt);
				border-radius: 6px;
				border-left: 4px solid var(--interactive-accent);
			}

			.tf-collapsible {
				cursor: pointer;
				user-select: none;
			}

			.tf-collapsible-content {
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.3s ease;
			}

			.tf-collapsible-content.open {
				max-height: 1000px;
			}

			@media (max-width: 768px) {
				.tf-stats-grid {
					grid-template-columns: 1fr;
				}

				.tf-month-grid {
					gap: 4px;
				}
			}
		`;
    document.head.appendChild(style);
  }
  buildBadgeSection() {
    const section = document.createElement("div");
    section.className = "tf-badge-section";
    const badge = document.createElement("div");
    badge.className = "tf-badge";
    this.elements.badge = badge;
    const timerBadge = document.createElement("button");
    timerBadge.className = "tf-timer-badge";
    this.elements.timerBadge = timerBadge;
    const clock = document.createElement("div");
    clock.className = "tf-clock";
    this.elements.clock = clock;
    section.appendChild(badge);
    section.appendChild(timerBadge);
    section.appendChild(clock);
    this.updateBadge();
    this.updateTimerBadge();
    this.updateClock();
    return section;
  }
  updateTimerBadge() {
    if (!this.elements.timerBadge)
      return;
    const activeTimers = this.timerManager.getActiveTimers();
    if (activeTimers.length === 0) {
      this.elements.timerBadge.textContent = "Start";
      this.elements.timerBadge.style.background = "linear-gradient(90deg, #4caf50, #2e7d32)";
      this.elements.timerBadge.style.color = "white";
      this.elements.timerBadge.onclick = async () => {
        await this.timerManager.startTimer("jobb");
        this.updateTimerBadge();
      };
    } else {
      this.elements.timerBadge.textContent = "Stopp";
      this.elements.timerBadge.style.background = "linear-gradient(90deg, #f44336, #c62828)";
      this.elements.timerBadge.style.color = "white";
      this.elements.timerBadge.onclick = async () => {
        for (const timer of activeTimers) {
          await this.timerManager.stopTimer(timer);
        }
        this.updateTimerBadge();
      };
    }
  }
  buildSummaryCards() {
    const container = document.createElement("div");
    container.className = "tf-summary-cards";
    container.appendChild(this.createDayCard());
    container.appendChild(this.createWeekCard());
    container.appendChild(this.createMonthCard());
    return container;
  }
  createDayCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-day";
    this.elements.dayCard = card;
    this.updateDayCard();
    return card;
  }
  createWeekCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-week";
    this.elements.weekCard = card;
    this.updateWeekCard();
    return card;
  }
  createMonthCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-month";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "15px";
    const title = document.createElement("h3");
    title.textContent = "M\xE5nedskalender";
    title.style.margin = "0";
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    const prevBtn = document.createElement("button");
    prevBtn.textContent = "\u2190";
    prevBtn.className = "tf-button";
    prevBtn.onclick = () => {
      this.currentMonthOffset--;
      this.updateMonthCard();
    };
    const todayBtn = document.createElement("button");
    todayBtn.textContent = "I dag";
    todayBtn.className = "tf-button";
    todayBtn.onclick = () => {
      this.currentMonthOffset = 0;
      this.updateMonthCard();
    };
    const nextBtn = document.createElement("button");
    nextBtn.textContent = "\u2192";
    nextBtn.className = "tf-button";
    nextBtn.onclick = () => {
      this.currentMonthOffset++;
      this.updateMonthCard();
    };
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const gridContainer = document.createElement("div");
    this.elements.monthCard = gridContainer;
    card.appendChild(gridContainer);
    this.updateMonthCard();
    return card;
  }
  createStatsCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-stats tf-card-spaced";
    const headerRow = document.createElement("div");
    headerRow.style.display = "flex";
    headerRow.style.justifyContent = "space-between";
    headerRow.style.alignItems = "center";
    headerRow.style.marginBottom = "15px";
    headerRow.style.flexWrap = "wrap";
    headerRow.style.gap = "10px";
    const header = document.createElement("h3");
    header.textContent = "Statistikk";
    header.style.margin = "0";
    headerRow.appendChild(header);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const timeframes = ["total", "year", "month"];
    const labels = { total: "Totalt", year: "\xC5r", month: "M\xE5ned" };
    timeframes.forEach((tf) => {
      const tab = document.createElement("button");
      tab.className = `tf-tab ${tf === this.statsTimeframe ? "active" : ""}`;
      tab.textContent = labels[tf];
      tab.onclick = () => {
        this.statsTimeframe = tf;
        this.updateStatsCard();
      };
      tabs.appendChild(tab);
    });
    headerRow.appendChild(tabs);
    card.appendChild(headerRow);
    const timeframeLabel = document.createElement("div");
    timeframeLabel.className = "tf-timeframe-label";
    timeframeLabel.style.marginBottom = "15px";
    timeframeLabel.style.fontSize = "1.1em";
    timeframeLabel.style.fontWeight = "bold";
    card.appendChild(timeframeLabel);
    const statsContainer = document.createElement("div");
    statsContainer.className = "tf-stats-grid";
    this.elements.statsCard = statsContainer;
    card.appendChild(statsContainer);
    this.updateStatsCard();
    return card;
  }
  buildInfoCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    header.innerHTML = "<h3 style='margin:0'>Informasjon</h3>";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const halfDayHours = this.settings.baseWorkday / 2;
    const halfDayReduction = this.settings.baseWorkday - halfDayHours;
    const specialDayInfo = [
      { key: "avspasering", emoji: "\u{1F6CC}", desc: "Trekkes fra fleksitid" },
      { key: "egenmelding", emoji: "\u{1F912}", desc: "P\xE5virker ikke fleksitid" },
      { key: "ferie", emoji: "\u{1F3D6}\uFE0F", desc: "P\xE5virker ikke fleksitid" },
      { key: "velferdspermisjon", emoji: "\u{1F3E5}", desc: "P\xE5virker ikke fleksitid" },
      { key: "studie", emoji: "\u{1F4D6}", desc: `Teller som fleksitid ved mer enn ${this.settings.baseWorkday}t` },
      { key: "kurs", emoji: "\u{1F4DA}", desc: `Teller som fleksitid ved mer enn ${this.settings.baseWorkday}t` },
      { key: "helligdag", emoji: "\u{1F389}", desc: "Offentlig fridag - p\xE5virker ikke fleksitid" },
      { key: "halfday", emoji: "\u23F0", desc: `Halv arbeidsdag (${halfDayHours}t) - reduserer ukem\xE5let med ${halfDayReduction}t` },
      { key: "Ingen registrering", emoji: "\u26AA", desc: "Ingen data for den dagen" }
    ];
    content.innerHTML = `
			<div style="margin-top: 15px;">
				<h4>Spesielle dagtyper</h4>
				<ul style="list-style: none; padding-left: 0; margin-bottom: 20px;">
					${specialDayInfo.map((item) => {
      const color = getSpecialDayColors(this.settings)[item.key] || "transparent";
      const label = this.settings.specialDayLabels[item.key] || item.key;
      return `<li style="display: flex; align-items: center; margin-bottom: 8px; font-size: 0.95em;">
							<div style="width: 16px; height: 16px; background: ${color}; border-radius: 3px; border: 1px solid var(--background-modifier-border); margin-right: 8px; flex-shrink: 0;"></div>
							<span>${item.emoji} <strong>${label}</strong>: ${item.desc}</span>
						</li>`;
    }).join("")}
				</ul>

				<div style="margin-top: 20px; padding: 12px; background: var(--background-primary); border-radius: 8px;">
					<h4 style="margin-top: 0;">Kalenderkontekstmeny</h4>
					<p style="margin: 8px 0; font-size: 0.9em;">
						H\xF8yreklikk p\xE5 en dag i kalenderen for \xE5 f\xE5 opp en meny med flere alternativer:
					</p>
					<ul style="margin: 8px 0 0 20px; font-size: 0.9em;">
						<li>Opprett daglig notat for valgt dag</li>
						<li>Opprett m\xF8tenotat, prosjektnotat eller refleksjonsnotat</li>
						<li>Rediger fleksitid for dagen manuelt</li>
						<li>Registrer spesielle dagtyper (ferie, kurs, avspasering, etc.)</li>
					</ul>
				</div>

				<div style="margin-top: 20px; padding: 12px; background: var(--background-primary); border-radius: 8px;">
					<h4 style="margin-top: 0;">Timesaldo - advarselsoner</h4>
					<div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.9em;">
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: #4caf50; flex-shrink: 0;"></span>
							<span><strong>Gr\xF8nn sone:</strong> 0t til +80t (trygg)</span>
						</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: #ff9800; flex-shrink: 0;"></span>
							<span><strong>Gul sone:</strong> -15t til -1t ELLER +80t til +95t (forsiktig)</span>
						</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: #f44336; flex-shrink: 0;"></span>
							<span><strong>R\xF8d sone:</strong> Under -15t ELLER over +95t (kritisk)</span>
						</div>
					</div>
					<div style="margin-top: 10px; font-size: 0.85em; opacity: 0.8;">
						<em>Grenser: -20t til +100t</em>
					</div>
				</div>

				<div style="margin-top: 20px;">
					<h4>Arbeidsdager - fargegradient</h4>
					<p style="margin: 8px 0; font-size: 0.9em;">
						Arbeidsdager vises med farge basert p\xE5 hvor mye du jobbet i forhold til dagens m\xE5l (${this.settings.baseWorkday}t):
					</p>
					<div style="margin-top: 10px;">
						<div style="height: 16px; border-radius: 8px; background: linear-gradient(to right, rgb(144,238,144), rgb(89,188,89), rgb(34,139,34)); margin: 4px 0; border: 1px solid var(--background-modifier-border);"></div>
						<div style="display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-muted); margin-bottom: 12px;">
							<span>0t over m\xE5l</span><span>+1,5t</span><span>+3t eller mer</span>
						</div>
						<div style="height: 16px; border-radius: 8px; background: linear-gradient(to right, rgb(100,150,255), rgb(150,200,255), rgb(200,220,255)); margin: 4px 0; border: 1px solid var(--background-modifier-border);"></div>
						<div style="display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-muted);">
							<span>-3t eller mindre</span><span>-1,5t</span><span>0t fra m\xE5l</span>
						</div>
					</div>
				</div>
			</div>
		`;
    header.onclick = () => {
      content.classList.toggle("open");
    };
    card.appendChild(header);
    card.appendChild(content);
    return card;
  }
  buildHistoryCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-history tf-card-spaced";
    const headerRow = document.createElement("div");
    headerRow.style.display = "flex";
    headerRow.style.justifyContent = "space-between";
    headerRow.style.alignItems = "center";
    headerRow.style.marginBottom = "15px";
    headerRow.style.flexWrap = "wrap";
    headerRow.style.gap = "10px";
    const title = document.createElement("h3");
    title.textContent = "Historikk";
    title.style.margin = "0";
    headerRow.appendChild(title);
    const detailsElement = document.createElement("div");
    detailsElement.style.maxHeight = "500px";
    detailsElement.style.overflow = "auto";
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const views = [
      { id: "list", label: "Liste" },
      { id: "heatmap", label: "Heatmap" }
    ];
    views.forEach((view) => {
      const tab = document.createElement("button");
      tab.textContent = view.label;
      tab.className = `tf-tab ${this.historyView === view.id ? "active" : ""}`;
      tab.onclick = () => {
        this.historyView = view.id;
        tabs.querySelectorAll(".tf-tab").forEach((t) => t.classList.remove("active"));
        tab.classList.add("active");
        this.refreshHistoryView(detailsElement);
      };
      tabs.appendChild(tab);
    });
    headerRow.appendChild(tabs);
    card.appendChild(headerRow);
    card.appendChild(detailsElement);
    this.refreshHistoryView(detailsElement);
    return card;
  }
  buildStatusBar() {
    var _a, _b, _c, _d, _e, _f;
    const bar = document.createElement("div");
    bar.className = "tf-status-bar";
    const status = this.systemStatus;
    const statusIcon = ((_a = status.validation) == null ? void 0 : _a.hasErrors) ? "\u274C" : ((_b = status.validation) == null ? void 0 : _b.hasWarnings) ? "\u26A0\uFE0F" : "\u2705";
    bar.innerHTML = `
			<div style="display: flex; align-items: center; gap: 10px;">
				<span>${statusIcon}</span>
				<div>
					<div><strong>System Status</strong></div>
					<div style="font-size: 12px; color: var(--text-muted);">
						${((_c = status.holiday) == null ? void 0 : _c.message) || "Holiday data not loaded"} \u2022
						${status.activeTimers || 0} active timer(s) \u2022
						${((_f = (_e = (_d = status.validation) == null ? void 0 : _d.issues) == null ? void 0 : _e.stats) == null ? void 0 : _f.totalEntries) || 0} entries checked
					</div>
				</div>
			</div>
		`;
    return bar;
  }
  updateClock() {
    if (!this.elements.clock)
      return;
    const now = /* @__PURE__ */ new Date();
    this.elements.clock.textContent = now.toLocaleTimeString("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  updateBadge() {
    if (!this.elements.badge)
      return;
    const balance = this.data.getCurrentBalance();
    const formatted = Utils.formatHoursToHM(Math.abs(balance), this.settings.hourUnit);
    const sign = balance >= 0 ? "+" : "-";
    let color = "#4caf50";
    if (balance < -15 || balance > 95) {
      color = "#f44336";
    } else if (balance < 0 || balance > 80) {
      color = "#ff9800";
    }
    this.elements.badge.style.background = color;
    this.elements.badge.style.color = "white";
    this.elements.badge.textContent = `Timesaldo: ${sign}${formatted}`;
  }
  updateDayCard() {
    if (!this.elements.dayCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    const goal = this.data.getDailyGoal(todayKey);
    const isWeekendDay = Utils.isWeekend(today, this.settings);
    const context = this.data.getContextualData(today);
    const { avgDaily } = this.data.getAverages();
    const specials = [];
    const holidayInfo = this.data.getHolidayInfo(todayKey);
    if (holidayInfo) {
      specials.push(holidayInfo.type);
    }
    const message = MessageGenerator.getDailyMessage(
      todayHours,
      goal,
      specials,
      isWeekendDay,
      avgDaily,
      context,
      this.settings.consecutiveFlextimeWarningDays
    );
    const progress = goal > 0 ? Math.min(todayHours / goal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (todayHours <= goal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (todayHours <= goal + 1.75) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.dayCard.style.background = bgColor;
    this.elements.dayCard.style.color = textColor;
    this.elements.dayCard.innerHTML = `
			<h3 style="color: ${textColor};">I dag</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(todayHours, this.settings.hourUnit)}
			</div>
			<div style="font-size: 14px; opacity: 0.9; margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(goal, this.settings.hourUnit)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%"></div>
			</div>
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		`;
  }
  updateWeekCard() {
    if (!this.elements.weekCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const weekHours = this.data.getCurrentWeekHours(today);
    const baseGoal = this.settings.baseWorkweek * this.settings.workPercent;
    const context = this.data.getContextualData(today);
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    let adjustedGoal = 0;
    let specials = [];
    let weekendWorkHours = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(firstDayOfWeek);
      d.setDate(firstDayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayGoal = this.data.getDailyGoal(dayKey);
      adjustedGoal += dayGoal;
      const holidayInfo = this.data.getHolidayInfo(dayKey);
      if (holidayInfo) {
        specials.push(holidayInfo.type);
      }
      if (Utils.isWeekend(d, this.settings)) {
        const dayEntries = this.data.daily[dayKey] || [];
        weekendWorkHours += dayEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
      }
    }
    const message = MessageGenerator.getWeeklyMessage(
      weekHours,
      adjustedGoal,
      specials,
      today,
      context,
      weekendWorkHours
    );
    const progress = adjustedGoal > 0 ? Math.min(weekHours / adjustedGoal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (weekHours <= adjustedGoal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (weekHours <= adjustedGoal + 3.5) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.weekCard.style.background = bgColor;
    this.elements.weekCard.style.color = textColor;
    this.elements.weekCard.innerHTML = `
			<h3 style="color: ${textColor};">Denne uken</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(weekHours, this.settings.hourUnit)}
			</div>
			<div style="font-size: 14px; opacity: 0.9; margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(adjustedGoal, this.settings.hourUnit)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%"></div>
			</div>
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		`;
  }
  updateStatsCard() {
    var _a, _b;
    if (!this.elements.statsCard)
      return;
    const stats = this.data.getStatistics(this.statsTimeframe);
    const balance = this.data.getCurrentBalance();
    const { avgDaily, avgWeekly } = this.data.getAverages();
    const workloadPct = (avgWeekly / this.settings.baseWorkweek * 100).toFixed(0);
    let timeframeLabel = "";
    const today = /* @__PURE__ */ new Date();
    if (this.statsTimeframe === "year") {
      timeframeLabel = today.getFullYear().toString();
    } else if (this.statsTimeframe === "month") {
      const monthName = today.toLocaleString("nb-NO", { month: "long" });
      timeframeLabel = monthName.charAt(0).toUpperCase() + monthName.slice(1);
    } else {
      timeframeLabel = "Totalt";
    }
    const context = this.data.getContextualData(today);
    let weekComparisonText = "";
    if (context.lastWeekHours > 0) {
      const currWeekHours = this.data.getCurrentWeekHours(today);
      const diff = currWeekHours - context.lastWeekHours;
      if (Math.abs(diff) > 2) {
        const arrow = diff > 0 ? "\u{1F4C8}" : "\u{1F4C9}";
        const sign2 = diff > 0 ? "+" : "";
        weekComparisonText = `<div style="font-size: 0.75em; margin-top: 4px;">vs forrige uke: ${sign2}${diff.toFixed(1)}t ${arrow}</div>`;
      }
    }
    const sign = balance >= 0 ? "+" : "";
    let timesaldoColor = "#4caf50";
    if (balance < -15 || balance > 95) {
      timesaldoColor = "#f44336";
    } else if (balance >= -15 && balance < 0 || balance >= 80 && balance <= 95) {
      timesaldoColor = "#ff9800";
    }
    let ferieDisplay = `${stats.ferie.count} dager`;
    if (this.statsTimeframe === "year" && stats.ferie.max > 0) {
      const feriePercent = (stats.ferie.count / stats.ferie.max * 100).toFixed(0);
      ferieDisplay = `${stats.ferie.count}/${stats.ferie.max} dager (${feriePercent}%)`;
    }
    let egenmeldingDisplay = `${stats.egenmelding.count} dager`;
    if (this.statsTimeframe === "year" && stats.egenmelding.max > 0) {
      const egenmeldingPercent = (stats.egenmelding.count / stats.egenmelding.max * 100).toFixed(0);
      egenmeldingDisplay = `${stats.egenmelding.count}/${stats.egenmelding.max} dager (${egenmeldingPercent}%)`;
    }
    const timeframeLabelElement = (_a = this.elements.statsCard.parentElement) == null ? void 0 : _a.querySelector(".tf-timeframe-label");
    if (timeframeLabelElement) {
      timeframeLabelElement.textContent = timeframeLabel;
    }
    this.elements.statsCard.innerHTML = `
			<div class="tf-stat-item" style="background: ${timesaldoColor}; color: white;">
				<div class="tf-stat-label">Timesaldo</div>
				<div class="tf-stat-value">${sign}${balance.toFixed(1)}t</div>
				<div style="font-size: 0.75em; margin-top: 4px;">Total saldo</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u23F1\uFE0F Timer</div>
				<div class="tf-stat-value">${stats.totalHours.toFixed(1)}t</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4CA} Snitt/dag</div>
				<div class="tf-stat-value">${avgDaily.toFixed(1)}t</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4C5} Snitt/uke</div>
				<div class="tf-stat-value">${avgWeekly.toFixed(1)}t</div>
				${weekComparisonText}
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4AA} Arbeidsbelastning</div>
				<div class="tf-stat-value">${workloadPct}%</div>
				<div style="font-size: 0.75em; margin-top: 4px;">av norm</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4BC} Jobb</div>
				<div class="tf-stat-value">${stats.jobb.count} ${stats.jobb.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.jobb.hours.toFixed(1)}t</div>
			</div>
			${stats.weekendDays > 0 ? `<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F319} Helgedager jobbet</div>
				<div class="tf-stat-value">${stats.weekendDays} ${stats.weekendDays === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.weekendHours.toFixed(1)}t</div>
			</div>` : ""}
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F6CC} Avspasering</div>
				<div class="tf-stat-value">${stats.avspasering.count} ${stats.avspasering.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.avspasering.hours.toFixed(1)}t${stats.avspasering.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.avspasering.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3D6}\uFE0F Ferie</div>
				<div class="tf-stat-value" style="font-size: ${this.statsTimeframe === "year" ? "0.9em" : "1.3em"};">${ferieDisplay}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.ferie.planned > 0 ? `\u{1F4C5} Planlagt: ${stats.ferie.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3E5} Velferdspermisjon</div>
				<div class="tf-stat-value">${stats.velferdspermisjon.count} ${stats.velferdspermisjon.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.velferdspermisjon.planned > 0 ? `\u{1F4C5} Planlagt: ${stats.velferdspermisjon.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F912} Egenmelding</div>
				<div class="tf-stat-value" style="font-size: ${this.statsTimeframe === "year" ? "0.9em" : "1.3em"};">${egenmeldingDisplay}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${this.statsTimeframe === "year" ? "(365d)" : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3E5} Sykemelding</div>
				<div class="tf-stat-value">${stats.sykemelding.count} ${stats.sykemelding.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.sykemelding.hours.toFixed(1)}t</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4DA} Studie</div>
				<div class="tf-stat-value">${stats.studie.count} ${stats.studie.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.studie.hours.toFixed(1)}t${stats.studie.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.studie.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4DA} Kurs</div>
				<div class="tf-stat-value">${stats.kurs.count} ${stats.kurs.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.kurs.hours.toFixed(1)}t${stats.kurs.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.kurs.planned}` : ""}</div>
			</div>
		`;
    const tabs = (_b = this.elements.statsCard.parentElement) == null ? void 0 : _b.querySelectorAll(".tf-tab");
    tabs == null ? void 0 : tabs.forEach((tab) => {
      var _a2;
      const timeframe = (_a2 = tab.textContent) == null ? void 0 : _a2.toLowerCase();
      if (timeframe === "totalt" && this.statsTimeframe === "total" || timeframe === "\xE5r" && this.statsTimeframe === "year" || timeframe === "m\xE5ned" && this.statsTimeframe === "month") {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
  }
  updateMonthCard() {
    if (!this.elements.monthCard)
      return;
    const displayDate = new Date(this.today);
    displayDate.setMonth(this.today.getMonth() + this.currentMonthOffset);
    const grid = this.createMonthGrid(displayDate);
    this.elements.monthCard.innerHTML = "";
    this.elements.monthCard.appendChild(grid);
  }
  createMonthGrid(displayDate) {
    const year = displayDate.getFullYear();
    const month = displayDate.getMonth();
    const monthName = displayDate.toLocaleDateString("nb-NO", { month: "long", year: "numeric" });
    const container = document.createElement("div");
    const monthTitle = document.createElement("div");
    monthTitle.textContent = monthName;
    monthTitle.style.textAlign = "center";
    monthTitle.style.fontWeight = "bold";
    monthTitle.style.marginBottom = "10px";
    container.appendChild(monthTitle);
    const grid = document.createElement("div");
    grid.className = "tf-month-grid";
    const dayNames = ["Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r", "S\xF8n"];
    dayNames.forEach((name) => {
      const header = document.createElement("div");
      header.textContent = name;
      header.style.textAlign = "center";
      header.style.fontWeight = "bold";
      header.style.fontSize = "12px";
      header.style.color = "var(--text-muted)";
      grid.appendChild(header);
    });
    const firstDay = new Date(year, month, 1);
    let firstDayOfWeek = firstDay.getDay() - 1;
    if (firstDayOfWeek === -1)
      firstDayOfWeek = 6;
    for (let i = 0; i < firstDayOfWeek; i++) {
      const emptyCell = document.createElement("div");
      grid.appendChild(emptyCell);
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const todayKey = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-day-cell";
      cell.textContent = day.toString();
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      const dayEntries = this.data.daily[dateKey];
      const specialDayColors = getSpecialDayColors(this.settings);
      const specialEntry = dayEntries == null ? void 0 : dayEntries.find(
        (e) => specialDayColors[e.name.toLowerCase()]
      );
      const hasEntry = !!(holidayInfo || specialEntry || dayEntries);
      if (holidayInfo) {
        const colorKey = holidayInfo.halfDay ? "halfday" : holidayInfo.type;
        cell.style.background = specialDayColors[colorKey] || specialDayColors[holidayInfo.type] || "#eee";
      } else if (specialEntry) {
        cell.style.background = specialDayColors[specialEntry.name.toLowerCase()];
      } else if (dayEntries) {
        const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
        cell.style.background = this.flextimeColor(dayFlextime);
      } else if (Utils.isWeekend(date, this.settings)) {
        cell.style.background = "#b0b0b0";
      } else {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (cellDate < today) {
          cell.style.background = "#e0e0e0";
        } else {
          cell.style.background = "transparent";
        }
      }
      if (hasEntry) {
        cell.classList.add("has-entry");
      } else {
        cell.classList.add("no-entry");
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (!Utils.isWeekend(date, this.settings) && cellDate >= today) {
          cell.style.color = "#ffffff";
        }
      }
      if (dateKey === todayKey) {
        cell.classList.add("today");
      }
      const hasActiveEntry = dayEntries == null ? void 0 : dayEntries.some((e) => !e.endTime);
      if (hasActiveEntry) {
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.top = "4px";
        indicator.style.right = "4px";
        indicator.style.width = "8px";
        indicator.style.height = "8px";
        indicator.style.borderRadius = "50%";
        indicator.style.background = "#4caf50";
        indicator.style.animation = "pulse 2s infinite";
        indicator.style.boxShadow = "0 0 4px rgba(76, 175, 80, 0.8)";
        cell.appendChild(indicator);
      }
      cell.onclick = (e) => {
        e.stopPropagation();
        const cellRect = cell.getBoundingClientRect();
        this.showNoteTypeMenu(cellRect, date);
      };
      grid.appendChild(cell);
    }
    container.appendChild(grid);
    return container;
  }
  flextimeColor(val) {
    if (val < 0) {
      const t = Math.min(Math.abs(val) / 3, 1);
      const r = Math.floor(100 + 50 * t);
      const g = Math.floor(150 + 50 * t);
      const b = Math.floor(200 + 55 * t);
      return `rgb(${r},${g},${b})`;
    } else {
      const t = Math.min(val / 3, 1);
      const r = Math.floor(144 - 110 * t);
      const g = Math.floor(238 - 99 * t);
      const b = Math.floor(144 - 110 * t);
      return `rgb(${r},${g},${b})`;
    }
  }
  showNoteTypeMenu(cellRect, dateObj) {
    const existingMenu = document.querySelector(".tf-context-menu");
    if (existingMenu)
      existingMenu.remove();
    const menu = document.createElement("div");
    menu.className = "tf-context-menu";
    const themeClass = `timeflow-theme-${this.settings.theme}`;
    menu.classList.add(themeClass);
    const menuMain = document.createElement("div");
    menuMain.className = "tf-context-menu-main";
    let menuLeft = cellRect.right;
    let menuTop = cellRect.top;
    document.body.appendChild(menu);
    const menuWidth = 450;
    if (menuLeft + menuWidth > window.innerWidth) {
      menuLeft = cellRect.left - menuWidth;
    }
    setTimeout(() => {
      const menuHeight = menu.offsetHeight;
      if (menuTop + menuHeight > window.innerHeight) {
        menu.style.top = `${Math.max(10, window.innerHeight - menuHeight - 10)}px`;
      }
    }, 0);
    menu.style.left = `${menuLeft}px`;
    menu.style.top = `${menuTop}px`;
    const dateStr = Utils.toLocalDateStr(dateObj);
    const dateEntries = this.data.daily[dateStr];
    const hasWorkEntriesInDaily = dateEntries && dateEntries.some((e) => e.name.toLowerCase() === "jobb");
    const hasRunningTimerForDate = this.timerManager.data.entries.some((entry) => {
      if (!entry.startTime || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    const hasWorkEntries = hasWorkEntriesInDaily || hasRunningTimerForDate;
    const workTimeItem = document.createElement("div");
    workTimeItem.className = "tf-menu-item";
    workTimeItem.innerHTML = `<span>\u23F1\uFE0F</span><span>Legg til arbeidstid</span>`;
    workTimeItem.onclick = () => {
      menu.remove();
      this.showWorkTimeModal(dateObj);
    };
    menuMain.appendChild(workTimeItem);
    if (hasWorkEntries) {
      const editItem = document.createElement("div");
      editItem.className = "tf-menu-item";
      editItem.innerHTML = `<span>\u270F\uFE0F</span><span>Rediger arbeidstid</span>`;
      editItem.onclick = () => {
        menu.remove();
        this.showEditEntriesModal(dateObj);
      };
      menuMain.appendChild(editItem);
    }
    const specialDayItem = document.createElement("div");
    specialDayItem.className = "tf-menu-item";
    specialDayItem.innerHTML = `<span>\u{1F4C5}</span><span>Registrer spesialdag</span>`;
    specialDayItem.onclick = () => {
      menu.remove();
      this.showSpecialDayModal(dateObj);
    };
    menuMain.appendChild(specialDayItem);
    const separator1 = document.createElement("div");
    separator1.className = "tf-menu-separator";
    menuMain.appendChild(separator1);
    this.settings.noteTypes.forEach((noteType) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.innerHTML = `<span>${noteType.icon}</span><span>${noteType.label}</span>`;
      item.onclick = async () => {
        await this.createNoteFromType(dateObj, noteType);
        menu.remove();
      };
      menuMain.appendChild(item);
    });
    menu.appendChild(menuMain);
    const menuInfo = document.createElement("div");
    menuInfo.className = "tf-context-menu-info";
    const allEntries = dateEntries || [];
    const plannedInfo = this.data.getHolidayInfo(dateStr);
    const isPlannedDay = plannedInfo !== null;
    const isPastDay = dateObj < /* @__PURE__ */ new Date();
    const isFutureDay = dateObj > /* @__PURE__ */ new Date();
    const runningTimersForDate = this.timerManager.data.entries.filter((entry) => {
      if (!entry.startTime || !entry.endTime === false || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr && !entry.endTime;
    });
    let infoHTML = `<h4>\u{1F4C5} ${dateStr}</h4>`;
    if (isPlannedDay && plannedInfo) {
      const emoji = Utils.getEmoji({ name: plannedInfo.type, date: dateObj });
      const halfDayText = plannedInfo.halfDay ? " (halv dag)" : "";
      infoHTML += `<p><strong>${emoji} ${plannedInfo.description}${halfDayText}</strong></p>`;
    }
    if (runningTimersForDate.length > 0) {
      infoHTML += "<p><strong>P\xE5g\xE5ende timer:</strong></p>";
      runningTimersForDate.forEach((timer) => {
        const startTime = new Date(timer.startTime);
        const startTimeStr = `${startTime.getHours().toString().padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;
        const now = /* @__PURE__ */ new Date();
        const elapsed = ((now.getTime() - startTime.getTime()) / (1e3 * 60 * 60)).toFixed(1);
        infoHTML += `<p style="margin-left: 8px;">\u23F1\uFE0F ${timer.name}: ${startTimeStr} - P\xE5g\xE5r (${elapsed}t)</p>`;
      });
    }
    const completedEntries = allEntries.filter((e) => e.duration && e.duration > 0);
    if (completedEntries.length > 0) {
      infoHTML += "<p><strong>Registreringer:</strong></p>";
      completedEntries.forEach((e) => {
        const emoji = Utils.getEmoji(e);
        const duration = `${e.duration.toFixed(1)}t`;
        infoHTML += `<p style="margin-left: 8px;">${emoji} ${e.name}: ${duration}</p>`;
      });
      if (!isFutureDay) {
        const totalHours = allEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
        const dayGoal = this.data.getDailyGoal(dateStr);
        const dailyDelta = dayGoal === 0 ? totalHours : totalHours - dayGoal;
        const runningBalance = this.data.getBalanceUpToDate(dateStr);
        infoHTML += `<p style="margin-top: 8px;"><strong>M\xE5l:</strong> ${dayGoal.toFixed(1)}t</p>`;
        infoHTML += `<p><strong>Dagssaldo:</strong> ${dailyDelta >= 0 ? "+" : ""}${dailyDelta.toFixed(1)}t</p>`;
        infoHTML += `<p><strong>L\xF8pende saldo:</strong> ${runningBalance >= 0 ? "+" : ""}${Utils.formatHoursToHM(runningBalance, this.settings.hourUnit)}</p>`;
      }
    } else if (isPastDay && !isPlannedDay && runningTimersForDate.length === 0) {
      infoHTML += '<p style="color: var(--text-muted);">Ingen registrering</p>';
    }
    infoHTML += '<p style="margin-top: 12px; font-size: 0.8em; color: var(--text-muted); border-top: 1px solid var(--background-modifier-border); padding-top: 8px;">\u{1F4A1} Velg et alternativ fra menyen til venstre</p>';
    menuInfo.innerHTML = infoHTML;
    menu.appendChild(menuInfo);
    setTimeout(() => {
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  showWorkTimeModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `Legg til arbeidstid for ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const startLabel = document.createElement("div");
    startLabel.textContent = "Starttid (HH:MM):";
    startLabel.style.marginBottom = "5px";
    startLabel.style.fontWeight = "bold";
    content.appendChild(startLabel);
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.value = "08:00";
    startInput.placeholder = "HH:MM";
    startInput.style.width = "100%";
    startInput.style.marginBottom = "15px";
    startInput.style.padding = "8px";
    startInput.style.fontSize = "14px";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = "Sluttid (HH:MM):";
    endLabel.style.marginBottom = "5px";
    endLabel.style.fontWeight = "bold";
    content.appendChild(endLabel);
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.value = "15:30";
    endInput.placeholder = "HH:MM";
    endInput.style.width = "100%";
    endInput.style.marginBottom = "20px";
    endInput.style.padding = "8px";
    endInput.style.fontSize = "14px";
    content.appendChild(endInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Avbryt";
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = "Legg til";
    addBtn.className = "mod-cta";
    addBtn.onclick = () => {
      const startTime = startInput.value.trim();
      const endTime = endInput.value.trim();
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
        new import_obsidian3.Notice("\u274C Ugyldig tidsformat. Bruk HH:MM format.");
        return;
      }
      const [startHour, startMin] = startTime.split(":").map(Number);
      const [endHour, endMin] = endTime.split(":").map(Number);
      const startDate = new Date(dateObj);
      startDate.setHours(startHour, startMin, 0, 0);
      const endDate = new Date(dateObj);
      endDate.setHours(endHour, endMin, 0, 0);
      if (endDate <= startDate) {
        new import_obsidian3.Notice("\u274C Sluttid m\xE5 v\xE6re etter starttid.");
        return;
      }
      try {
        this.timerManager.data.entries.push({
          name: "jobb",
          startTime: startDate.toISOString(),
          endTime: endDate.toISOString(),
          subEntries: null,
          collapsed: false
        });
        this.timerManager.save();
        const duration = (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
        new import_obsidian3.Notice(`\u2705 Lagt til ${duration.toFixed(1)} timer arbeidstid for ${dateStr}`);
        this.data.rawEntries = this.timerManager.convertToTimeEntries();
        this.data.processEntries();
        this.updateDayCard();
        this.updateWeekCard();
        this.updateStatsCard();
        this.updateMonthCard();
        modal.remove();
      } catch (error) {
        console.error("Failed to add work time:", error);
        new import_obsidian3.Notice("\u274C Kunne ikke legge til arbeidstid");
      }
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    startInput.focus();
    startInput.select();
  }
  showEditEntriesModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const allEntries = this.timerManager.data.entries;
    const workEntries = allEntries.filter((entry) => {
      if (!entry.startTime || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    if (workEntries.length === 0) {
      new import_obsidian3.Notice("Ingen arbeidstidsoppf\xF8ringer funnet for denne datoen");
      return;
    }
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "500px";
    modalContent.style.maxHeight = "80vh";
    modalContent.style.overflow = "auto";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `Rediger arbeidstid for ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    workEntries.forEach((entry, index) => {
      const entryDiv = document.createElement("div");
      entryDiv.style.padding = "15px";
      entryDiv.style.marginBottom = "10px";
      entryDiv.style.background = "var(--background-secondary)";
      entryDiv.style.borderRadius = "8px";
      entryDiv.style.border = "1px solid var(--background-modifier-border)";
      const startDate = new Date(entry.startTime);
      const endDate = entry.endTime ? new Date(entry.endTime) : null;
      const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
      const endTimeStr = endDate ? `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}` : "P\xE5g\xE5ende";
      const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(1) : "N/A";
      const infoDiv = document.createElement("div");
      infoDiv.style.marginBottom = "10px";
      infoDiv.innerHTML = `
				<div style="font-weight: bold; margin-bottom: 5px;">Oppf\xF8ring ${index + 1}</div>
				<div>\u23F0 ${startTimeStr} - ${endTimeStr}</div>
				<div>\u23F1\uFE0F ${duration} timer</div>
			`;
      entryDiv.appendChild(infoDiv);
      const editDiv = document.createElement("div");
      editDiv.style.display = "none";
      editDiv.style.marginTop = "10px";
      const startLabel = document.createElement("div");
      startLabel.textContent = "Starttid:";
      startLabel.style.marginBottom = "5px";
      startLabel.style.fontWeight = "bold";
      editDiv.appendChild(startLabel);
      const startInput = document.createElement("input");
      startInput.type = "text";
      startInput.value = startTimeStr;
      startInput.style.width = "100%";
      startInput.style.marginBottom = "10px";
      startInput.style.padding = "6px";
      editDiv.appendChild(startInput);
      const endLabel = document.createElement("div");
      endLabel.textContent = "Sluttid:";
      endLabel.style.marginBottom = "5px";
      endLabel.style.fontWeight = "bold";
      editDiv.appendChild(endLabel);
      const endInput = document.createElement("input");
      endInput.type = "text";
      endInput.value = endTimeStr !== "P\xE5g\xE5ende" ? endTimeStr : "";
      endInput.style.width = "100%";
      endInput.style.marginBottom = "10px";
      endInput.style.padding = "6px";
      editDiv.appendChild(endInput);
      entryDiv.appendChild(editDiv);
      const buttonDiv = document.createElement("div");
      buttonDiv.style.display = "flex";
      buttonDiv.style.gap = "8px";
      buttonDiv.style.marginTop = "10px";
      const editBtn = document.createElement("button");
      editBtn.textContent = "\u270F\uFE0F Rediger";
      editBtn.style.flex = "1";
      editBtn.onclick = () => {
        if (editDiv.style.display === "none") {
          editDiv.style.display = "block";
          editBtn.textContent = "\u{1F4BE} Lagre";
        } else {
          const newStartTime = startInput.value.trim();
          const newEndTime = endInput.value.trim();
          const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
          if (!timeRegex.test(newStartTime) || newEndTime && !timeRegex.test(newEndTime)) {
            new import_obsidian3.Notice("\u274C Ugyldig tidsformat. Bruk HH:MM format.");
            return;
          }
          const [startHour, startMin] = newStartTime.split(":").map(Number);
          const newStartDate = new Date(dateObj);
          newStartDate.setHours(startHour, startMin, 0, 0);
          let newEndDate = null;
          if (newEndTime) {
            const [endHour, endMin] = newEndTime.split(":").map(Number);
            newEndDate = new Date(dateObj);
            newEndDate.setHours(endHour, endMin, 0, 0);
            if (newEndDate <= newStartDate) {
              new import_obsidian3.Notice("\u274C Sluttid m\xE5 v\xE6re etter starttid.");
              return;
            }
          }
          entry.startTime = newStartDate.toISOString();
          entry.endTime = newEndDate ? newEndDate.toISOString() : null;
          this.timerManager.save();
          new import_obsidian3.Notice("\u2705 Oppf\xF8ring oppdatert");
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          modal.remove();
        }
      };
      buttonDiv.appendChild(editBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "\u{1F5D1}\uFE0F Slett";
      deleteBtn.style.flex = "1";
      deleteBtn.onclick = () => {
        const entryIndex = this.timerManager.data.entries.indexOf(entry);
        if (entryIndex > -1) {
          this.timerManager.data.entries.splice(entryIndex, 1);
          this.timerManager.save();
          new import_obsidian3.Notice("\u2705 Oppf\xF8ring slettet");
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          modal.remove();
        }
      };
      buttonDiv.appendChild(deleteBtn);
      entryDiv.appendChild(buttonDiv);
      content.appendChild(entryDiv);
    });
    const closeDiv = document.createElement("div");
    closeDiv.style.marginTop = "20px";
    closeDiv.style.display = "flex";
    closeDiv.style.justifyContent = "flex-end";
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "Lukk";
    closeBtn.onclick = () => modal.remove();
    closeDiv.appendChild(closeBtn);
    content.appendChild(closeDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  showSpecialDayModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = "Registrer spesialdag";
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const dateDisplay = document.createElement("div");
    dateDisplay.textContent = `Dato: ${dateStr}`;
    dateDisplay.style.marginBottom = "15px";
    dateDisplay.style.fontSize = "16px";
    dateDisplay.style.fontWeight = "bold";
    content.appendChild(dateDisplay);
    const typeLabel = document.createElement("div");
    typeLabel.textContent = "Type dag:";
    typeLabel.style.marginBottom = "5px";
    typeLabel.style.fontWeight = "bold";
    content.appendChild(typeLabel);
    const dayTypes = [
      { type: "ferie", label: `\u{1F3D6}\uFE0F ${this.settings.specialDayLabels.ferie}` },
      { type: "avspasering", label: `\u{1F6CC} ${this.settings.specialDayLabels.avspasering}` },
      { type: "velferdspermisjon", label: `\u{1F3E5} ${this.settings.specialDayLabels.velferdspermisjon}` },
      { type: "egenmelding", label: `\u{1F912} ${this.settings.specialDayLabels.egenmelding}` },
      { type: "sykemelding", label: `\u{1F3E5} ${this.settings.specialDayLabels.sykemelding}` },
      { type: "kurs", label: `\u{1F4DA} ${this.settings.specialDayLabels.kurs}` },
      { type: "studie", label: `\u{1F4D6} ${this.settings.specialDayLabels.studie}` }
    ];
    const typeSelect = document.createElement("select");
    typeSelect.style.width = "100%";
    typeSelect.style.marginBottom = "15px";
    typeSelect.style.padding = "8px";
    typeSelect.style.fontSize = "14px";
    dayTypes.forEach(({ type, label }) => {
      const option = document.createElement("option");
      option.value = type;
      option.textContent = label;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const noteLabel = document.createElement("div");
    noteLabel.textContent = "Kommentar (valgfritt):";
    noteLabel.style.marginBottom = "5px";
    noteLabel.style.fontWeight = "bold";
    content.appendChild(noteLabel);
    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.placeholder = 'F.eks. "Ferie i Spania"';
    noteInput.style.width = "100%";
    noteInput.style.marginBottom = "20px";
    noteInput.style.padding = "8px";
    noteInput.style.fontSize = "14px";
    content.appendChild(noteInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Avbryt";
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = "Legg til";
    addBtn.className = "mod-cta";
    addBtn.onclick = async () => {
      const dayType = typeSelect.value;
      const note = noteInput.value.trim();
      await this.addSpecialDay(dateObj, dayType, note);
      modal.remove();
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    typeSelect.focus();
  }
  async addSpecialDay(dateObj, dayType, note = "") {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        new import_obsidian3.Notice(`\u274C Fant ikke filen: ${filePath}`);
        return;
      }
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      const dateStr = `${year}-${month}-${day}`;
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian3.Notice('\u274C Fant ikke seksjonen "Planlagte egne fridager"');
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian3.Notice("\u274C Fant ikke kodeblokk i seksjonen");
        return;
      }
      const newEntry = `- ${dateStr}: ${dayType}: ${note}`;
      const beforeClosing = content.substring(0, codeBlockEnd);
      const afterClosing = content.substring(codeBlockEnd);
      const needsNewline = !beforeClosing.endsWith("\n");
      content = beforeClosing + (needsNewline ? "\n" : "") + newEntry + "\n" + afterClosing;
      await this.app.vault.modify(file, content);
      const label = this.settings.specialDayLabels[dayType] || dayType;
      new import_obsidian3.Notice(`\u2705 Lagt til ${dateStr} (${label})`);
      this.updateMonthCard();
    } catch (error) {
      console.error("Failed to add special day:", error);
      new import_obsidian3.Notice("\u274C Kunne ikke legge til spesialdag");
    }
  }
  async createNoteFromType(dateObj, noteType) {
    try {
      const dateStr = Utils.toLocalDateStr(dateObj);
      const weekNum = Utils.getWeekNumber(dateObj);
      let filename = noteType.filenamePattern.replace("{YYYY}", dateObj.getFullYear().toString()).replace("{MM}", (dateObj.getMonth() + 1).toString().padStart(2, "0")).replace("{DD}", dateObj.getDate().toString().padStart(2, "0")).replace("{WEEK}", weekNum.toString());
      const filePath = `${noteType.folder}/${filename}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        await this.app.workspace.getLeaf(false).openFile(existingFile);
        new import_obsidian3.Notice(`Opened existing note: ${filename}`);
        return;
      }
      const folderPath = noteType.folder;
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      let content = "";
      const templateFile = this.app.vault.getAbstractFileByPath(noteType.template);
      if (templateFile && templateFile instanceof import_obsidian3.TFile) {
        content = await this.app.vault.read(templateFile);
      }
      content = content.replace(/{date}/g, dateStr).replace(/{time}/g, (/* @__PURE__ */ new Date()).toLocaleTimeString("nb-NO")).replace(/{week}/g, weekNum.toString());
      if (noteType.tags && noteType.tags.length > 0) {
        content += `

${noteType.tags.join(" ")}`;
      }
      const file = await this.app.vault.create(filePath, content);
      await this.app.workspace.getLeaf(false).openFile(file);
      new import_obsidian3.Notice(`Created note: ${filename}`);
    } catch (error) {
      new import_obsidian3.Notice(`Error creating note: ${error.message}`);
      console.error("Error creating note:", error);
    }
  }
  refreshHistoryView(container) {
    container.innerHTML = "";
    const years = {};
    Object.keys(this.data.daily).sort().reverse().forEach((dateKey) => {
      const year = dateKey.split("-")[0];
      if (!years[year])
        years[year] = {};
      const month = dateKey.split("-")[1];
      if (!years[year][month])
        years[year][month] = [];
      years[year][month].push(...this.data.daily[dateKey]);
    });
    if (this.historyView === "list") {
      this.renderListView(container, years);
    } else if (this.historyView === "weekly") {
      this.renderWeeklyView(container, years);
    } else if (this.historyView === "heatmap") {
      this.renderHeatmapView(container, years);
    }
  }
  renderListView(container, years) {
    Object.keys(years).forEach((year) => {
      const yearDiv = document.createElement("div");
      yearDiv.innerHTML = `<h4 style="color: var(--text-normal);">${year}</h4>`;
      Object.keys(years[year]).forEach((month) => {
        const monthEntries = years[year][month];
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginBottom = "15px";
        const thead = document.createElement("thead");
        thead.innerHTML = `
					<tr style="background: var(--background-secondary); color: var(--text-normal);">
						<th style="padding: 8px; color: var(--text-normal);">Dato</th>
						<th style="padding: 8px; color: var(--text-normal);">Type</th>
						<th style="padding: 8px; color: var(--text-normal);">Timer</th>
						<th style="padding: 8px; color: var(--text-normal);">Fleksitid</th>
						<th style="padding: 8px; color: var(--text-normal);">Handling</th>
					</tr>
				`;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        monthEntries.forEach((e) => {
          const row = document.createElement("tr");
          row.style.borderBottom = "1px solid var(--background-modifier-border)";
          row.style.color = "var(--text-normal)";
          const dateCell = document.createElement("td");
          dateCell.style.padding = "8px";
          dateCell.style.color = "var(--text-normal)";
          dateCell.textContent = Utils.toLocalDateStr(e.date);
          row.appendChild(dateCell);
          const typeCell = document.createElement("td");
          typeCell.style.padding = "8px";
          typeCell.style.color = "var(--text-normal)";
          const entryNameLower = e.name.toLowerCase();
          const customLabel = this.settings.specialDayLabels[entryNameLower];
          typeCell.textContent = customLabel || e.name;
          row.appendChild(typeCell);
          const hoursCell = document.createElement("td");
          hoursCell.style.padding = "8px";
          hoursCell.style.color = "var(--text-normal)";
          hoursCell.textContent = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
          row.appendChild(hoursCell);
          const flextimeCell = document.createElement("td");
          flextimeCell.style.padding = "8px";
          flextimeCell.style.color = "var(--text-normal)";
          flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
          row.appendChild(flextimeCell);
          const actionCell = document.createElement("td");
          actionCell.style.padding = "8px";
          actionCell.style.color = "var(--text-normal)";
          if (e.name.toLowerCase() === "jobb") {
            const editBtn = document.createElement("button");
            editBtn.textContent = "\u270F\uFE0F";
            editBtn.style.padding = "4px 8px";
            editBtn.style.cursor = "pointer";
            editBtn.title = "Rediger arbeidstid";
            editBtn.onclick = () => {
              this.showEditEntriesModal(e.date);
            };
            actionCell.appendChild(editBtn);
          }
          row.appendChild(actionCell);
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      container.appendChild(yearDiv);
    });
  }
  renderWeeklyView(container, years) {
    container.innerHTML = '<div style="padding: 20px; text-align: center;">Weekly view - Coming soon</div>';
  }
  renderHeatmapView(container, years) {
    const heatmap = document.createElement("div");
    heatmap.className = "tf-heatmap";
    heatmap.style.gridTemplateColumns = `repeat(${this.settings.heatmapColumns}, 1fr)`;
    const today = /* @__PURE__ */ new Date();
    const daysToShow = this.settings.heatmapColumns * 8;
    for (let i = daysToShow; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-heatmap-cell";
      cell.title = dateKey;
      const dayEntries = this.data.daily[dateKey];
      if (dayEntries) {
        const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
        cell.style.background = this.flextimeColor(dayFlextime);
      } else {
        cell.style.background = "#eee";
      }
      heatmap.appendChild(cell);
    }
    container.appendChild(heatmap);
  }
  exportCurrentView() {
    const rows = [["Date", "Type", "Hours", "Flextime"]];
    Object.keys(this.data.daily).sort().forEach((dateKey) => {
      this.data.daily[dateKey].forEach((entry) => {
        rows.push([
          dateKey,
          entry.name,
          (entry.duration || 0).toFixed(2),
          (entry.flextime || 0).toFixed(2)
        ]);
      });
    });
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian3.Notice("Exported to CSV");
  }
  startUpdates() {
    const clockInterval = window.setInterval(() => {
      this.updateClock();
    }, this.settings.clockInterval);
    this.intervals.push(clockInterval);
    const dataInterval = window.setInterval(() => {
      this.updateAll();
    }, this.settings.updateInterval);
    this.intervals.push(dataInterval);
  }
  updateAll() {
    this.updateBadge();
    this.updateTimerBadge();
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  cleanup() {
    this.intervals.forEach((interval) => clearInterval(interval));
    this.intervals = [];
  }
  build() {
    this.injectStyles();
    this.container.appendChild(this.buildBadgeSection());
    this.container.appendChild(this.buildSummaryCards());
    this.container.appendChild(this.createStatsCard());
    this.container.appendChild(this.buildInfoCard());
    this.container.appendChild(this.buildHistoryCard());
    this.container.appendChild(this.buildStatusBar());
    return this.container;
  }
};

// src/view.ts
var VIEW_TYPE_TIMEFLOW = "timeflow-view";
var TimeFlowView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dataManager = null;
    this.uiBuilder = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TIMEFLOW;
  }
  getDisplayText() {
    return "TimeFlow Dashboard";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeflow-dashboard");
    await this.loadDashboard(container);
  }
  async onClose() {
    if (this.uiBuilder) {
      this.uiBuilder.cleanup();
    }
  }
  async loadDashboard(container) {
    try {
      const allEntries = this.plugin.timerManager.convertToTimeEntries();
      if (allEntries.length === 0) {
        container.createDiv({
          text: "No timer data yet. Start a timer to begin tracking!",
          cls: "timeflow-warning"
        });
      }
      this.dataManager = new DataManager(allEntries, this.plugin.settings, this.app);
      const holidayStatus = await this.dataManager.loadHolidays();
      this.dataManager.processEntries();
      const validationResults = this.dataManager.validateData();
      const systemStatus = {
        holiday: holidayStatus,
        validation: validationResults,
        activeTimers: this.dataManager.activeEntries.length
      };
      this.uiBuilder = new UIBuilder(
        this.dataManager,
        systemStatus,
        this.plugin.settings,
        this.app,
        this.plugin.timerManager
      );
      this.plugin.timerManager.onTimerChange = () => {
        this.refresh();
      };
      const dashboardEl = this.uiBuilder.build();
      container.empty();
      container.appendChild(dashboardEl);
      this.uiBuilder.startUpdates();
    } catch (error) {
      console.error("Error loading TimeFlow dashboard:", error);
      container.createDiv({
        text: `Error loading dashboard: ${error.message}`,
        cls: "timeflow-error"
      });
    }
  }
  // Method to refresh the dashboard
  async refresh() {
    const container = this.containerEl.children[1];
    await this.loadDashboard(container);
  }
};

// src/timerManager.ts
var import_obsidian5 = require("obsidian");
var TimerManager = class {
  constructor(app, settings) {
    this.dataFile = "timeflow/data.md";
    this.app = app;
    this.settings = settings;
    this.data = { entries: [] };
  }
  async load() {
    console.log("TimeFlow: Starting load() from", this.dataFile);
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      console.log("TimeFlow: File exists check:", fileExists);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dataFile);
        console.log("TimeFlow: Read content, length:", content.length);
        const parsed = this.parseTimekeepData(content);
        console.log("TimeFlow: Parsed data:", parsed ? `${parsed.entries.length} entries` : "null");
        if (parsed) {
          this.data = parsed;
          console.log("TimeFlow: Loaded", this.data.entries.length, "entries from", this.dataFile);
          if (parsed.settings) {
            console.log("TimeFlow: Found synced settings in data file");
            return parsed.settings;
          }
        } else {
          console.warn("TimeFlow: Could not parse data from", this.dataFile);
          this.data = { entries: [] };
        }
      } else {
        console.log("TimeFlow: Data file not found, creating new one");
        await this.createDataFile();
      }
    } catch (error) {
      console.error("TimeFlow: Error loading timer data:", error);
      this.data = { entries: [] };
    }
    return null;
  }
  async createDataFile() {
    const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data)}
\`\`\`
`;
    const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
    const folderExists = await this.app.vault.adapter.exists(folderPath);
    if (!folderExists) {
      await this.app.vault.createFolder(folderPath);
    }
    await this.app.vault.create(this.dataFile, content);
  }
  parseTimekeepData(content) {
    try {
      const match = content.match(/```timekeep\s*\n([\s\S]*?)\n```/);
      if (match && match[1]) {
        return JSON.parse(match[1]);
      }
    } catch (error) {
      console.error("Error parsing timekeep data:", error);
    }
    return null;
  }
  async save() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.dataFile);
      const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data, null, 2)}
\`\`\`
`;
      if (file && file instanceof import_obsidian5.TFile) {
        await this.app.vault.modify(file, content);
        console.log("TimeFlow: Saved", this.data.entries.length, "entries to", this.dataFile);
      } else {
        const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
        const folderExists = await this.app.vault.adapter.exists(folderPath);
        if (!folderExists) {
          await this.app.vault.createFolder(folderPath);
        }
        await this.app.vault.create(this.dataFile, content);
        console.log("TimeFlow: Created", this.dataFile, "with", this.data.entries.length, "entries");
      }
    } catch (error) {
      console.error("TimeFlow: Error saving timer data:", error);
    }
  }
  // Save settings to the data file for cross-device sync
  async saveSettings(settings) {
    this.settings = settings;
    this.data.settings = settings;
    await this.save();
    console.log("TimeFlow: Saved settings to data file for sync");
  }
  async startTimer(name = "Jobb") {
    const timer = {
      name,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      endTime: null,
      subEntries: null
    };
    this.data.entries.push(timer);
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    new import_obsidian5.Notice(`\u23F1\uFE0F Timer started: ${name}`);
    return timer;
  }
  async stopTimer(timer) {
    if (!timer.startTime || timer.endTime) {
      return null;
    }
    timer.endTime = (/* @__PURE__ */ new Date()).toISOString();
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    const duration = Utils.hoursDiff(
      new Date(timer.startTime),
      new Date(timer.endTime)
    );
    new import_obsidian5.Notice(`\u2705 Timer stopped: ${timer.name} (${Utils.formatHoursToHM(duration)})`);
    return timer;
  }
  async stopAllTimers() {
    const activeTimers = this.getActiveTimers();
    for (const timer of activeTimers) {
      await this.stopTimer(timer);
    }
  }
  async deleteTimer(timer) {
    const index = this.data.entries.indexOf(timer);
    if (index !== -1) {
      this.data.entries.splice(index, 1);
      await this.save();
      if (this.onTimerChange) {
        this.onTimerChange();
      }
      new import_obsidian5.Notice("Timer deleted");
      return true;
    }
    return false;
  }
  getActiveTimers() {
    return this.data.entries.filter((e) => e.startTime && !e.endTime && !e.collapsed);
  }
  getCompletedTimers() {
    return this.data.entries.filter((e) => e.startTime && e.endTime);
  }
  getAllTimers() {
    return this.data.entries;
  }
  // Flatten all entries including subEntries for DataManager
  convertToTimeEntries() {
    const flatEntries = [];
    const flattenEntry = (entry) => {
      if (entry.collapsed && entry.subEntries) {
        entry.subEntries.forEach((sub) => flattenEntry(sub));
      } else if (entry.startTime) {
        flatEntries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          subEntries: null
        });
      }
    };
    this.data.entries.forEach((entry) => flattenEntry(entry));
    return flatEntries;
  }
  // Get running time for active timer
  getRunningTime(timer) {
    if (!timer.startTime || timer.endTime)
      return 0;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(timer.startTime);
    return Utils.hoursDiff(start, now);
  }
  // Get total running time for all active timers
  getTotalRunningTime() {
    return this.getActiveTimers().reduce((total, timer) => {
      return total + this.getRunningTime(timer);
    }, 0);
  }
  // Load data from multiple sources (daily notes with timekeep codeblocks)
  async loadFromDailyNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const dailyNotesFolder = this.settings.dailyNotesFolder;
      let allEntries = [];
      for (const file of files) {
        if (file.path.startsWith(dailyNotesFolder)) {
          const content = await this.app.vault.read(file);
          const parsed = this.parseTimekeepData(content);
          if (parsed && parsed.entries) {
            allEntries = allEntries.concat(parsed.entries);
          }
        }
      }
      const currentEntries = this.data.entries;
      allEntries.forEach((entry) => {
        const isDuplicate = currentEntries.some(
          (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
        );
        if (!isDuplicate) {
          currentEntries.push(entry);
        }
      });
      this.data.entries = currentEntries;
      await this.save();
    } catch (error) {
      console.error("Error loading from daily notes:", error);
    }
  }
  // Export to Timekeep format for other tools
  exportTimekeepFormat() {
    return JSON.stringify(this.data, null, 2);
  }
  // Import from Timekeep JSON
  async importTimekeepData(jsonData) {
    try {
      const parsed = JSON.parse(jsonData);
      if (parsed && parsed.entries) {
        const currentEntries = this.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        parsed.entries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.data.entries = currentEntries;
        await this.save();
        if (this.onTimerChange) {
          this.onTimerChange();
        }
        if (skippedCount > 0) {
          new import_obsidian5.Notice(`\u2705 Imported ${addedCount} entries, skipped ${skippedCount} duplicates`);
        } else {
          new import_obsidian5.Notice(`\u2705 Imported ${addedCount} entries`);
        }
        return true;
      }
    } catch (error) {
      console.error("Error importing timekeep data:", error);
      new import_obsidian5.Notice("\u274C Error importing data");
    }
    return false;
  }
};

// src/importModal.ts
var import_obsidian6 = require("obsidian");
var ImportModal = class extends import_obsidian6.Modal {
  constructor(app, timerManager, onSuccess) {
    super(app);
    this.timerManager = timerManager;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Import Timekeep Data" });
    contentEl.createEl("p", {
      text: "Paste your Timekeep JSON data below. This can be from a timekeep codeblock or exported data.",
      cls: "setting-item-description"
    });
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "15",
        placeholder: '{"entries":[...]}'
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} How to get your data:" });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: "Open your file with Timekeep codeblocks" });
    list.createEl("li", { text: "Copy the entire JSON from inside the timekeep block" });
    list.createEl("li", { text: "Paste it in the text area above" });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const importBtn = buttonDiv.createEl("button", { text: "Import", cls: "mod-cta" });
    importBtn.onclick = async () => {
      const jsonText = textArea.value.trim();
      if (!jsonText) {
        new import_obsidian6.Notice("\u26A0\uFE0F Please paste your Timekeep data");
        return;
      }
      try {
        const data = JSON.parse(jsonText);
        if (!data.entries || !Array.isArray(data.entries)) {
          new import_obsidian6.Notice('\u26A0\uFE0F Invalid format: missing "entries" array');
          return;
        }
        if (data.entries.length > 0) {
          const firstEntry = data.entries[0];
          if (!firstEntry.hasOwnProperty("name") || !firstEntry.hasOwnProperty("startTime")) {
            new import_obsidian6.Notice("\u26A0\uFE0F Invalid entry format: missing required fields (name, startTime)");
            return;
          }
        }
        const success = await this.timerManager.importTimekeepData(jsonText);
        if (success) {
          new import_obsidian6.Notice(`\u2705 Successfully imported ${data.entries.length} entries!`);
          this.close();
          this.onSuccess();
        } else {
          new import_obsidian6.Notice("\u274C Failed to import data");
        }
      } catch (error) {
        if (error instanceof SyntaxError) {
          new import_obsidian6.Notice("\u26A0\uFE0F Invalid JSON format. Please check your data.");
        } else {
          new import_obsidian6.Notice(`\u274C Error: ${error.message}`);
        }
        console.error("Import error:", error);
      }
    };
    const hint = contentEl.createEl("div");
    hint.style.marginTop = "10px";
    hint.style.fontSize = "12px";
    hint.style.color = "var(--text-muted)";
    hint.textContent = '\u{1F4A1} Tip: You can also create "TimeFlow Data.md" manually in your vault root';
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var TimeFlowPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    console.log("Loading TimeFlow plugin");
    await this.loadSettings();
    this.timerManager = new TimerManager(this.app, this.settings);
    const syncedSettings = await this.timerManager.load();
    if (syncedSettings) {
      console.log("TimeFlow: Merging synced settings from data file");
      this.settings = Object.assign({}, DEFAULT_SETTINGS, this.settings, syncedSettings);
      this.timerManager.settings = this.settings;
      await this.saveSettings();
    }
    this.registerView(
      VIEW_TYPE_TIMEFLOW,
      (leaf) => new TimeFlowView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open timeflow", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-timeflow",
      name: "Open timeflow Dashboard",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "start-timer",
      name: "Start Timer",
      callback: async () => {
        await this.timerManager.startTimer("jobb");
      }
    });
    this.addCommand({
      id: "stop-all-timers",
      name: "Stop All Timers",
      callback: async () => {
        await this.timerManager.stopAllTimers();
      }
    });
    this.addCommand({
      id: "import-timekeep-data",
      name: "Import Timekeep Data",
      callback: () => {
        new ImportModal(this.app, this.timerManager, () => {
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
          leaves.forEach((leaf) => {
            const view = leaf.view;
            if (view && view.refresh) {
              view.refresh();
            }
          });
        }).open();
      }
    });
    this.addSettingTab(new TimeFlowSettingTab(this.app, this));
  }
  onunload() {
    console.log("Unloading TimeFlow plugin");
    this.timerManager.stopAllTimers();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.timerManager.saveSettings(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TIMEFLOW, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
