/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeFlowPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils.ts
var FIXED_DAY_COLORS = {
  helligdag: "#ef5350",
  halfday: "#ffd54f",
  "Ingen registrering": "#cccccc"
};
function getSpecialDayColors(settings) {
  const colors = { ...FIXED_DAY_COLORS };
  settings.specialDayBehaviors.forEach((behavior) => {
    colors[behavior.id] = behavior.color;
  });
  if (settings.specialDayColors) {
    Object.assign(colors, settings.specialDayColors);
  }
  return colors;
}
var EMOJI_MAP = {
  avspasering: "\u{1F6CC}",
  kurs: "\u{1F4DA}",
  studie: "\u{1F4DA}",
  ferie: "\u{1F3D6}\uFE0F",
  velferdspermisjon: "\u{1F3E5}",
  egenmelding: "\u{1F912}",
  sykemelding: "\u{1F3E5}",
  helligdag: "\u{1F389}",
  jobb: "\u{1F4BC}"
};
var Utils = {
  parseDate: (str) => str ? new Date(str) : null,
  hoursDiff: (start, end) => (end.getTime() - start.getTime()) / 36e5,
  isWeekend: (date, settings) => {
    if (!date)
      return false;
    const day = date.getDay();
    if (!settings)
      return day === 0 || day === 6;
    if (settings.enableAlternatingWeeks) {
      const onejan = new Date(date.getFullYear(), 0, 1);
      const weekNum = Math.ceil(((date.getTime() - onejan.getTime()) / 864e5 + onejan.getDay() + 1) / 7);
      const isAlternatingWeek = weekNum % 2 === 0;
      const workDays = isAlternatingWeek ? settings.alternatingWeekWorkDays : settings.workDays;
      return !workDays.includes(day);
    }
    return !settings.workDays.includes(day);
  },
  formatHoursToHM: (hours, unit = "h") => {
    const h = Math.floor(hours);
    const m = Math.round((hours - h) * 60);
    return `${h}${unit} ${m.toString().padStart(2, "0")}m`;
  },
  toLocalDateStr: (date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  },
  getWeekNumber: (d) => {
    const date = new Date(d.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    const week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(
      ((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7
    );
  },
  getEmoji: (entry) => {
    const name = entry.name.toLowerCase();
    if (EMOJI_MAP[name])
      return EMOJI_MAP[name];
    if (!entry.endTime)
      return "\u23F3";
    if (Utils.isWeekend(entry.date))
      return "\u{1F319}";
    return "";
  },
  randMsg: (arr) => arr[Math.floor(Math.random() * arr.length)],
  getDayOfYear: (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    return Math.floor(diff / 864e5);
  }
};

// src/settings.ts
var DEFAULT_SPECIAL_DAY_BEHAVIORS = [
  {
    id: "ferie",
    label: "Ferie",
    icon: "\u{1F3D6}\uFE0F",
    color: "#b3e5fc",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true,
    maxDaysPerYear: 25
  },
  {
    id: "avspasering",
    label: "Avspasering",
    icon: "\u{1F6CC}",
    color: "#ffe0b2",
    noHoursRequired: true,
    flextimeEffect: "withdraw",
    includeInStats: true
  },
  {
    id: "egenmelding",
    label: "Egenmelding",
    icon: "\u{1F912}",
    color: "#c8e6c9",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true,
    maxDaysPerYear: 24,
    countingPeriod: "rolling365"
  },
  {
    id: "sykemelding",
    label: "Sykemelding",
    icon: "\u{1F3E5}",
    color: "#c8e6c9",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  },
  {
    id: "velferdspermisjon",
    label: "Velferdspermisjon",
    icon: "\u{1F3E5}",
    color: "#e1bee7",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  },
  {
    id: "kurs",
    label: "Kurs",
    icon: "\u{1F4DA}",
    color: "#f8bbd0",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true
  },
  {
    id: "studie",
    label: "Studie",
    icon: "\u{1F4D6}",
    color: "#f8bbd0",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true
  },
  {
    id: "helligdag",
    label: "Helligdag",
    icon: "\u{1F389}",
    color: "#ef5350",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  }
];
var DEFAULT_SETTINGS = {
  version: "1.0.0",
  theme: "light",
  hourUnit: "t",
  workPercent: 1,
  baseWorkday: 7.5,
  baseWorkweek: 37.5,
  lunchBreakMinutes: 0,
  includeSaturdayInWorkWeek: false,
  // DEPRECATED
  includeSundayInWorkWeek: false,
  // DEPRECATED
  workDays: [1, 2, 3, 4, 5],
  // Monday-Friday by default
  enableAlternatingWeeks: false,
  alternatingWeekWorkDays: [1, 2, 3, 4, 5],
  // Same as workDays by default
  enableGoalTracking: true,
  // NEW: Default to goal-based tracking (current behavior)
  enableWeeklyGoals: true,
  maxEgenmeldingDays: 8,
  maxFerieDays: 25,
  updateInterval: 3e4,
  clockInterval: 1e3,
  dataFilePath: "timeflow/data.md",
  holidaysFilePath: "timeflow/holidays.md",
  dailyNotesFolder: "Daily Notes",
  dailyNotesTemplatePath: "timeflow/templates/daily-notes.md",
  workdaysPerYear: 260,
  workdaysPerMonth: 21,
  workdaysPerWeek: 5,
  consecutiveFlextimeWarningDays: 5,
  defaultExportWeeks: 52,
  heatmapColumns: 48,
  noteTypes: [
    {
      id: "daily",
      label: "Daglig Notat",
      icon: "\u{1F4C5}",
      folder: "Daily Notes",
      template: "timeflow/templates/daily-notes.md",
      tags: [],
      filenamePattern: "{YYYY}-{MM}-{DD}"
    },
    {
      id: "meeting",
      label: "M\xF8tenotat",
      icon: "\u{1F465}",
      folder: "M\xF8ter",
      template: "timeflow/templates/meeting-note.md",
      tags: ["#m\xF8te", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} M\xF8te"
    },
    {
      id: "project",
      label: "Prosjektnotat",
      icon: "\u{1F4CB}",
      folder: "Prosjekter",
      template: "timeflow/templates/project-note.md",
      tags: ["#prosjekt", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Prosjekt"
    },
    {
      id: "review",
      label: "Ukesoppsummering",
      icon: "\u{1F50D}",
      folder: "Oppsummeringer",
      template: "timeflow/templates/weekly-review.md",
      tags: ["#oppsummering", "#uke", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Uke {WEEK}"
    },
    {
      id: "reflection",
      label: "Refleksjonsnotat",
      icon: "\u{1F4AD}",
      folder: "Refleksjoner",
      template: "timeflow/templates/reflection-note.md",
      tags: ["#refleksjon", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Refleksjon"
    }
  ],
  specialDayBehaviors: DEFAULT_SPECIAL_DAY_BEHAVIORS,
  specialDayColors: {
    avspasering: "#ffe0b2",
    ferie: "#b3e5fc",
    velferdspermisjon: "#e1bee7",
    egenmelding: "#c8e6c9",
    sykemelding: "#c8e6c9",
    kurs: "#f8bbd0",
    studie: "#f8bbd0"
  },
  specialDayLabels: {
    avspasering: "Avspasering",
    ferie: "Ferie",
    velferdspermisjon: "Velferdspermisjon",
    egenmelding: "Egenmelding",
    sykemelding: "Sykemelding",
    kurs: "Kurs",
    studie: "Studie"
  },
  // Advanced configuration settings
  balanceStartDate: "2025-01-01",
  halfDayHours: 4,
  halfDayMode: "fixed",
  balanceThresholds: {
    criticalLow: -15,
    warningLow: 0,
    warningHigh: 80,
    criticalHigh: 95
  },
  validationThresholds: {
    longRunningTimerHours: 12,
    veryLongSessionHours: 16,
    maxDurationHours: 24,
    highWeeklyTotalHours: 50
  },
  // NEW: Custom colors
  customColors: {
    balanceOk: "#4caf50",
    balanceWarning: "#ff9800",
    balanceCritical: "#f44336",
    progressBar: "#4caf50"
  },
  // NEW: Message preferences
  enableMotivationalMessages: true,
  // Norwegian labor law compliance settings
  complianceSettings: {
    enableWarnings: true,
    dailyHoursLimit: 9,
    weeklyHoursLimit: 40,
    minimumRestHours: 11
  }
};
var SpecialDayBehaviorModal = class extends import_obsidian.Modal {
  constructor(app, plugin, behavior, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.behavior = behavior;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.behavior ? "Edit Special Day Type" : "Add Special Day Type" });
    if (this.behavior) {
      const norwegianTerms = {
        "egenmelding": "Norwegian self-reported sick leave (max 8 days/year per Norwegian labor law)",
        "velferdspermisjon": "Norwegian welfare leave for personal/family health matters",
        "avspasering": "Norwegian term: Time off as compensation for accumulated flextime"
      };
      const explanation = norwegianTerms[this.behavior.id];
      if (explanation) {
        const infoBox = contentEl.createDiv({ cls: "setting-item-description" });
        infoBox.style.padding = "10px";
        infoBox.style.marginBottom = "15px";
        infoBox.style.background = "var(--background-secondary)";
        infoBox.style.borderRadius = "5px";
        infoBox.style.fontSize = "0.9em";
        infoBox.innerHTML = `\u2139\uFE0F ${explanation}`;
      }
    }
    const formData = {
      id: ((_a = this.behavior) == null ? void 0 : _a.id) || "",
      label: ((_b = this.behavior) == null ? void 0 : _b.label) || "",
      icon: ((_c = this.behavior) == null ? void 0 : _c.icon) || "",
      color: ((_d = this.behavior) == null ? void 0 : _d.color) || "#b3e5fc",
      noHoursRequired: (_f = (_e = this.behavior) == null ? void 0 : _e.noHoursRequired) != null ? _f : true,
      flextimeEffect: ((_g = this.behavior) == null ? void 0 : _g.flextimeEffect) || "none",
      includeInStats: (_i = (_h = this.behavior) == null ? void 0 : _h.includeInStats) != null ? _i : true,
      maxDaysPerYear: ((_j = this.behavior) == null ? void 0 : _j.maxDaysPerYear) || void 0,
      countingPeriod: ((_k = this.behavior) == null ? void 0 : _k.countingPeriod) || "calendar"
    };
    new import_obsidian.Setting(contentEl).setName("ID").setDesc("Unique identifier (lowercase, no spaces). Used in holiday file format.").addText((text) => {
      text.setPlaceholder("ferie").setValue(formData.id).onChange((value) => formData.id = value.toLowerCase().replace(/\s+/g, ""));
      if (this.behavior) {
        text.setDisabled(true);
      }
    });
    new import_obsidian.Setting(contentEl).setName("Label").setDesc("Display name shown in the dashboard").addText((text) => text.setPlaceholder("Ferie").setValue(formData.label).onChange((value) => formData.label = value));
    new import_obsidian.Setting(contentEl).setName("Icon").setDesc("Emoji to display").addText((text) => text.setPlaceholder("\u{1F3D6}\uFE0F").setValue(formData.icon).onChange((value) => formData.icon = value));
    new import_obsidian.Setting(contentEl).setName("Color").setDesc("Background color for this day type in calendar").addColorPicker((color) => color.setValue(formData.color).onChange((value) => formData.color = value));
    new import_obsidian.Setting(contentEl).setName("No hours required").setDesc("If enabled, you don't need to log any work hours this day (e.g., vacation, sick leave). If disabled, regular workday goal applies.").addToggle((toggle) => toggle.setValue(formData.noHoursRequired).onChange((value) => formData.noHoursRequired = value));
    new import_obsidian.Setting(contentEl).setName("Flextime effect").setDesc("How this day type affects your flextime balance").addDropdown((dropdown) => dropdown.addOption("none", "No effect (counts as full workday)").addOption("withdraw", "Withdraw (uses flextime balance)").addOption("accumulate", "Accumulate (excess hours add to flextime)").setValue(formData.flextimeEffect).onChange((value) => formData.flextimeEffect = value));
    new import_obsidian.Setting(contentEl).setName("Include in statistics").setDesc("Show this day type in yearly statistics").addToggle((toggle) => toggle.setValue(formData.includeInStats).onChange((value) => formData.includeInStats = value));
    new import_obsidian.Setting(contentEl).setName("Max days per year (optional)").setDesc("Yearly limit for this day type (e.g., 25 for vacation). Leave empty for no limit.").addText((text) => {
      var _a2;
      return text.setPlaceholder("25").setValue(((_a2 = formData.maxDaysPerYear) == null ? void 0 : _a2.toString()) || "").onChange((value) => {
        const num = parseInt(value);
        formData.maxDaysPerYear = isNaN(num) ? void 0 : num;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Counting period").setDesc("How to count the max days limit. Calendar year resets each January 1st. Rolling 365 days counts backwards from today.").addDropdown((dropdown) => dropdown.addOption("calendar", "Calendar year").addOption("rolling365", "Rolling 365 days").setValue(formData.countingPeriod).onChange((value) => formData.countingPeriod = value));
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = () => {
      if (!formData.id) {
        new import_obsidian.Notice("\u26A0\uFE0F ID is required");
        return;
      }
      if (!formData.label) {
        new import_obsidian.Notice("\u26A0\uFE0F Label is required");
        return;
      }
      if (!formData.icon) {
        new import_obsidian.Notice("\u26A0\uFE0F Icon is required");
        return;
      }
      if (!this.behavior || this.behavior.id !== formData.id) {
        const isDuplicate = this.plugin.settings.specialDayBehaviors.some(
          (b, i) => b.id === formData.id && i !== this.index
        );
        if (isDuplicate) {
          new import_obsidian.Notice("\u26A0\uFE0F A special day type with this ID already exists");
          return;
        }
      }
      const behavior = {
        id: formData.id,
        label: formData.label,
        icon: formData.icon,
        color: formData.color,
        noHoursRequired: formData.noHoursRequired,
        flextimeEffect: formData.flextimeEffect,
        includeInStats: formData.includeInStats,
        maxDaysPerYear: formData.maxDaysPerYear,
        countingPeriod: formData.countingPeriod
      };
      this.onSave(behavior, this.index);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TimeFlowSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async refreshView() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("timeflow-view");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && typeof view.refresh === "function") {
        await view.refresh();
      }
    }
  }
  addResetButton(setting, settingKey, defaultValue, refreshCallback) {
    setting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[settingKey] = defaultValue;
        await this.plugin.saveSettings();
        this.display();
        if (refreshCallback) {
          await refreshCallback();
        }
      })
    );
  }
  validateNumber(value, min, max, settingName) {
    const num = parseFloat(value);
    if (isNaN(num)) {
      new import_obsidian.Notice(`\u274C ${settingName}: Please enter a valid number`);
      return null;
    }
    if (num < min) {
      new import_obsidian.Notice(`\u274C ${settingName}: Value must be at least ${min}`);
      return null;
    }
    if (num > max) {
      new import_obsidian.Notice(`\u274C ${settingName}: Value must be at most ${max}`);
      return null;
    }
    return num;
  }
  validateDateFormat(dateStr) {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      new import_obsidian.Notice("\u274C Balance start date: Format must be YYYY-MM-DD");
      return false;
    }
    const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
    if (isNaN(date.getTime())) {
      new import_obsidian.Notice("\u274C Balance start date: Invalid date");
      return false;
    }
    if (date > /* @__PURE__ */ new Date()) {
      new import_obsidian.Notice("\u274C Balance start date: Cannot be in the future");
      return false;
    }
    return true;
  }
  createCollapsibleSubsection(container, title, startOpen = false) {
    const header = container.createDiv({
      cls: startOpen ? "tf-collapsible-subsection open" : "tf-collapsible-subsection"
    });
    header.createSpan({ text: title });
    const content = container.createDiv({
      cls: startOpen ? "tf-collapsible-content open" : "tf-collapsible-content"
    });
    header.onclick = () => {
      header.classList.toggle("open");
      content.classList.toggle("open");
    };
    return { header, content };
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "TimeFlow Settings" });
    const searchContainer = containerEl.createDiv({ cls: "tf-settings-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u{1F50D} Search settings...",
      cls: "tf-search-input"
    });
    const settingsContainer = containerEl.createDiv({ cls: "tf-settings-container" });
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase();
      const allSettings = settingsContainer.querySelectorAll(".setting-item");
      allSettings.forEach((setting) => {
        var _a, _b, _c, _d;
        const name = ((_b = (_a = setting.querySelector(".setting-item-name")) == null ? void 0 : _a.textContent) == null ? void 0 : _b.toLowerCase()) || "";
        const desc = ((_d = (_c = setting.querySelector(".setting-item-description")) == null ? void 0 : _c.textContent) == null ? void 0 : _d.toLowerCase()) || "";
        if (name.includes(query) || desc.includes(query)) {
          setting.style.display = "";
        } else {
          setting.style.display = "none";
        }
      });
    });
    new import_obsidian.Setting(settingsContainer).setName("Quick Start").setDesc("Essential settings to get started with TimeFlow").setHeading();
    const syncInfo = settingsContainer.createDiv();
    syncInfo.style.marginBottom = "15px";
    syncInfo.style.padding = "10px";
    syncInfo.style.background = "var(--background-secondary)";
    syncInfo.style.borderRadius = "5px";
    syncInfo.style.fontSize = "0.9em";
    syncInfo.innerHTML = `
			<strong>\u{1F4F1} Cross-Device Settings Sync</strong><br>
			Settings are automatically saved to <code>timeflow/data.md</code> and will sync across devices when using Obsidian Sync or any other vault sync solution. When you open the plugin on another device, your settings will be automatically loaded.
		`;
    new import_obsidian.Setting(settingsContainer).setName("Data file path").setDesc("Path to the file containing timer data and settings").addText((text) => text.setPlaceholder("timeflow/data.md").setValue(this.plugin.settings.dataFilePath).onChange(async (value) => {
      this.plugin.settings.dataFilePath = value;
      await this.plugin.saveSettings();
      this.plugin.timerManager.dataFile = value;
    }));
    new import_obsidian.Setting(settingsContainer).setName("Holidays file path").setDesc("Path to the file containing future planned days/holidays").addText((text) => text.setPlaceholder("timeflow/holidays.md").setValue(this.plugin.settings.holidaysFilePath).onChange(async (value) => {
      this.plugin.settings.holidaysFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Work Configuration").setDesc("Configure your work schedule and goals").setHeading();
    new import_obsidian.Setting(settingsContainer).setName("Enable goal tracking").setDesc("Enable flextime calculations and daily/weekly goals. Disable for simple hour tracking without goals (e.g., shift workers, freelancers).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableGoalTracking).onChange(async (value) => {
      this.plugin.settings.enableGoalTracking = value;
      await this.plugin.saveSettings();
      this.display();
      await this.refreshView();
    }));
    if (this.plugin.settings.enableGoalTracking) {
      new import_obsidian.Setting(settingsContainer).setName("Base workday hours").setDesc("Standard hours for a full workday (e.g., 7.5 for standard, 6 for 6-hour days)").addText((text) => text.setPlaceholder("7.5").setValue(this.plugin.settings.baseWorkday.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.baseWorkday = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      new import_obsidian.Setting(settingsContainer).setName("Enable weekly/monthly goals").setDesc("Disable if you don't have a specific amount of work each week/month. This will hide goal progress bars and weekly/monthly targets.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWeeklyGoals).onChange(async (value) => {
        this.plugin.settings.enableWeeklyGoals = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableWeeklyGoals) {
        new import_obsidian.Setting(settingsContainer).setName("Work percentage").setDesc("Your employment percentage. Adjusts weekly work goal. Example: 0.8 (80%) = 30h/week if base is 37.5h").addText((text) => text.setPlaceholder("1.0").setValue(this.plugin.settings.workPercent.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0 && num <= 1) {
            this.plugin.settings.workPercent = num;
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
        new import_obsidian.Setting(settingsContainer).setName("Base workweek hours").setDesc("Standard hours for a full workweek (e.g., 37.5 for 5 days, 30 for 4 days)").addText((text) => text.setPlaceholder("37.5").setValue(this.plugin.settings.baseWorkweek.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.baseWorkweek = num;
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
      }
      new import_obsidian.Setting(settingsContainer).setName("Lunch break duration").setDesc("Daily lunch break in minutes (e.g., 30 for 30 minutes). This will be deducted from your work hours automatically.").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.lunchBreakMinutes.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.lunchBreakMinutes = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const workDaysSetting = new import_obsidian.Setting(settingsContainer).setName("Work days").setDesc("Select which days are part of your work week");
      const workDaysContainer = settingsContainer.createDiv();
      workDaysContainer.style.display = "flex";
      workDaysContainer.style.flexWrap = "wrap";
      workDaysContainer.style.gap = "8px";
      workDaysContainer.style.marginBottom = "15px";
      dayNames.forEach((dayName, dayIndex) => {
        const dayButton = workDaysContainer.createEl("button");
        dayButton.textContent = dayName.substring(0, 3);
        dayButton.className = "tf-day-button";
        dayButton.style.padding = "8px 12px";
        dayButton.style.border = "1px solid var(--background-modifier-border)";
        dayButton.style.borderRadius = "4px";
        dayButton.style.cursor = "pointer";
        dayButton.style.background = this.plugin.settings.workDays.includes(dayIndex) ? "var(--interactive-accent)" : "var(--background-secondary)";
        dayButton.style.color = this.plugin.settings.workDays.includes(dayIndex) ? "var(--text-on-accent)" : "var(--text-normal)";
        dayButton.onclick = async () => {
          const currentWorkDays = [...this.plugin.settings.workDays];
          const index = currentWorkDays.indexOf(dayIndex);
          if (index > -1) {
            currentWorkDays.splice(index, 1);
          } else {
            currentWorkDays.push(dayIndex);
            currentWorkDays.sort((a, b) => a - b);
          }
          this.plugin.settings.workDays = currentWorkDays;
          await this.plugin.saveSettings();
          this.display();
        };
      });
      new import_obsidian.Setting(settingsContainer).setName("Enable alternating weeks").setDesc("Enable if you have different work days in alternating weeks (e.g., every other weekend)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAlternatingWeeks).onChange(async (value) => {
        this.plugin.settings.enableAlternatingWeeks = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableAlternatingWeeks) {
        const altWorkDaysSetting = new import_obsidian.Setting(settingsContainer).setName("Alternating week work days").setDesc("Select which days are work days in the alternating week");
        const altWorkDaysContainer = settingsContainer.createDiv();
        altWorkDaysContainer.style.display = "flex";
        altWorkDaysContainer.style.flexWrap = "wrap";
        altWorkDaysContainer.style.gap = "8px";
        altWorkDaysContainer.style.marginBottom = "15px";
        dayNames.forEach((dayName, dayIndex) => {
          const dayButton = altWorkDaysContainer.createEl("button");
          dayButton.textContent = dayName.substring(0, 3);
          dayButton.className = "tf-day-button";
          dayButton.style.padding = "8px 12px";
          dayButton.style.border = "1px solid var(--background-modifier-border)";
          dayButton.style.borderRadius = "4px";
          dayButton.style.cursor = "pointer";
          dayButton.style.background = this.plugin.settings.alternatingWeekWorkDays.includes(dayIndex) ? "var(--interactive-accent)" : "var(--background-secondary)";
          dayButton.style.color = this.plugin.settings.alternatingWeekWorkDays.includes(dayIndex) ? "var(--text-on-accent)" : "var(--text-normal)";
          dayButton.onclick = async () => {
            const currentAltWorkDays = [...this.plugin.settings.alternatingWeekWorkDays];
            const index = currentAltWorkDays.indexOf(dayIndex);
            if (index > -1) {
              currentAltWorkDays.splice(index, 1);
            } else {
              currentAltWorkDays.push(dayIndex);
              currentAltWorkDays.sort((a, b) => a - b);
            }
            this.plugin.settings.alternatingWeekWorkDays = currentAltWorkDays;
            await this.plugin.saveSettings();
            this.display();
          };
        });
      }
    }
    const complianceSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Arbeidstidsgrenser (Work Time Limits)",
      false
    );
    complianceSection.content.addClass("tf-compliance-settings");
    new import_obsidian.Setting(complianceSection.content).setName("Enable compliance warnings").setDesc("Show warnings when approaching or exceeding Norwegian labor law limits").addToggle((toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) != null ? _b : true).onChange(async (value) => {
        if (!this.plugin.settings.complianceSettings) {
          this.plugin.settings.complianceSettings = {
            enableWarnings: true,
            dailyHoursLimit: 9,
            weeklyHoursLimit: 40,
            minimumRestHours: 11
          };
        }
        this.plugin.settings.complianceSettings.enableWarnings = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian.Setting(complianceSection.content).setName("Daily hours limit").setDesc("Maximum hours per day before showing a warning (Norwegian law: 9 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("9").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.dailyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian.Setting(complianceSection.content).setName("Weekly hours limit").setDesc("Maximum hours per week before showing a warning (Norwegian law: 40 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("40").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.weeklyHoursLimit) != null ? _b : 40).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.weeklyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian.Setting(complianceSection.content).setName("Minimum rest hours").setDesc("Minimum consecutive hours of rest between work sessions (Norwegian law: 11 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("11").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.minimumRestHours = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian.Setting(settingsContainer).setName("Special Day Types").setDesc("Configure how different types of special days affect your workday and flextime balance. These settings determine how days are counted in flextime calculations.").setHeading();
    const getBehaviorDescription = (behavior) => {
      const parts = [];
      parts.push(behavior.noHoursRequired ? "No hours required" : "Regular workday applies");
      if (behavior.flextimeEffect === "withdraw") {
        parts.push("withdraws from flextime");
      } else if (behavior.flextimeEffect === "accumulate") {
        parts.push("excess counts as flextime");
      } else {
        parts.push("no flextime change");
      }
      if (behavior.maxDaysPerYear) {
        parts.push(`max ${behavior.maxDaysPerYear} days/year`);
      }
      return parts.join(", ");
    };
    this.plugin.settings.specialDayBehaviors.forEach((behavior, index) => {
      const colorDot = settingsContainer.createEl("span");
      colorDot.style.display = "inline-block";
      colorDot.style.width = "12px";
      colorDot.style.height = "12px";
      colorDot.style.borderRadius = "50%";
      colorDot.style.backgroundColor = behavior.color;
      colorDot.style.marginRight = "6px";
      colorDot.style.verticalAlign = "middle";
      new import_obsidian.Setting(settingsContainer).setName(`${behavior.icon} ${behavior.label}`).setDesc(getBehaviorDescription(behavior)).addButton((btn) => btn.setButtonText("Edit").onClick(() => {
        new SpecialDayBehaviorModal(
          this.app,
          this.plugin,
          behavior,
          index,
          async (updatedBehavior, idx) => {
            this.plugin.settings.specialDayBehaviors[idx] = updatedBehavior;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      })).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(async () => {
        const confirmation = confirm(
          `Are you sure you want to delete "${behavior.label}"?

Note: Historical data in your holidays file using "${behavior.id}" will no longer be recognized.`
        );
        if (confirmation) {
          this.plugin.settings.specialDayBehaviors.splice(index, 1);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      }));
    });
    new import_obsidian.Setting(settingsContainer).setName("Add new special day type").setDesc("Create a custom day type with your own rules").addButton((btn) => btn.setButtonText("+ Add").setCta().onClick(() => {
      new SpecialDayBehaviorModal(
        this.app,
        this.plugin,
        null,
        // New behavior
        this.plugin.settings.specialDayBehaviors.length,
        // Index at end
        async (newBehavior) => {
          this.plugin.settings.specialDayBehaviors.push(newBehavior);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      ).open();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Display & Interface").setDesc("Customize the appearance and behavior of the TimeFlow interface").setHeading();
    new import_obsidian.Setting(settingsContainer).setName("Theme").setDesc("Choose the color scheme for TimeFlow cards").addDropdown((dropdown) => dropdown.addOption("light", "Light (Colorful gradients)").addOption("system", "System (Match Obsidian theme)").addOption("dark", "Dark (Dark gradients)").setValue(this.plugin.settings.theme).onChange(async (value) => {
      this.plugin.settings.theme = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Hour unit").setDesc('Choose the unit symbol for displaying hours: "h" for hours or "t" for timer').addDropdown((dropdown) => dropdown.addOption("h", "h (hours)").addOption("t", "t (timer)").setValue(this.plugin.settings.hourUnit).onChange(async (value) => {
      this.plugin.settings.hourUnit = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Enable motivational messages").setDesc("Show contextual messages in day/week cards (e.g., encouraging messages, progress updates)").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.enableMotivationalMessages) != null ? _a : true).onChange(async (value) => {
        this.plugin.settings.enableMotivationalMessages = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian.Setting(settingsContainer).setName("Consecutive flextime warning days").setDesc("Number of consecutive days with flextime before showing a warning").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.consecutiveFlextimeWarningDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.consecutiveFlextimeWarningDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(settingsContainer).setName("Heatmap columns").setDesc("Number of columns in the heatmap view (adjust for your screen width)").addText((text) => text.setPlaceholder("48").setValue(this.plugin.settings.heatmapColumns.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.heatmapColumns = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(settingsContainer).setName("Update interval (ms)").setDesc("How often to update the dashboard data (in milliseconds)").addText((text) => text.setPlaceholder("30000").setValue(this.plugin.settings.updateInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.updateInterval = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(settingsContainer).setName("File Paths & Templates").setDesc("Configure file paths and note templates").setHeading();
    new import_obsidian.Setting(settingsContainer).setName("Daily notes folder").setDesc("Folder where daily notes are stored").addText((text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
      this.plugin.settings.dailyNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Daily notes template path").setDesc("Path to the template for daily notes").addText((text) => text.setPlaceholder("Templates/Daily Notes Template.md").setValue(this.plugin.settings.dailyNotesTemplatePath).onChange(async (value) => {
      this.plugin.settings.dailyNotesTemplatePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Note types").setDesc("Configure the types of notes available in the calendar context menu. Each note type can have its own template, folder, and filename pattern.").setHeading();
    this.plugin.settings.noteTypes.forEach((noteType, index) => {
      new import_obsidian.Setting(settingsContainer).setName(`${noteType.icon} ${noteType.label}`).setDesc(`Folder: ${noteType.folder} | Template: ${noteType.template}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        this.showNoteTypeModal(noteType, index);
      })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        this.plugin.settings.noteTypes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.refreshView();
        this.display();
      }));
    });
    new import_obsidian.Setting(settingsContainer).setName("Add new note type").setDesc("Create a new note type for the context menu").addButton((button) => button.setButtonText("+ Add note type").setCta().onClick(() => {
      this.showNoteTypeModal(null, -1);
    }));
    new import_obsidian.Setting(settingsContainer).setName("Data Management").setDesc("Import and export your time tracking data").setHeading();
    new import_obsidian.Setting(settingsContainer).setName("Export data to CSV").setDesc("Export all your time tracking data to a CSV file").addButton((button) => button.setButtonText("Export CSV").setCta().onClick(async () => {
      this.exportToCSV();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Import Timekeep data").setDesc("Import time tracking data from Timekeep JSON format").addButton((button) => button.setButtonText("Import data").setCta().onClick(async () => {
      this.showImportModal();
    }));
    new import_obsidian.Setting(settingsContainer).setName("Advanced Settings").setDesc("Fine-tune balance calculations, thresholds, and visual customization").setHeading();
    const advancedInfo = settingsContainer.createDiv();
    advancedInfo.style.marginBottom = "15px";
    advancedInfo.style.padding = "10px";
    advancedInfo.style.background = "var(--background-secondary)";
    advancedInfo.style.borderRadius = "5px";
    advancedInfo.style.fontSize = "0.9em";
    advancedInfo.innerHTML = `
			<strong>\u2699\uFE0F Advanced Settings</strong><br>
			These settings affect balance calculations and visual indicators. Settings sync across devices via your data file.
		`;
    const balanceCalcSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance Calculation",
      false
    );
    new import_obsidian.Setting(balanceCalcSection.content).setName("Balance start date").setDesc("Set the date from which flextime balance is calculated. Earlier entries are ignored in balance calculations. Format: YYYY-MM-DD").addText((text) => text.setPlaceholder("2025-01-01").setValue(this.plugin.settings.balanceStartDate).onChange(async (value) => {
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          this.plugin.settings.balanceStartDate = value;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }
    }));
    new import_obsidian.Setting(balanceCalcSection.content).setName("Half-day calculation mode").setDesc("How half-day hours should be calculated").addDropdown((dropdown) => dropdown.addOption("fixed", "Fixed hours (set specific value)").addOption("percentage", "Percentage (half of base workday)").setValue(this.plugin.settings.halfDayMode).onChange(async (value) => {
      this.plugin.settings.halfDayMode = value;
      await this.plugin.saveSettings();
      await this.refreshView();
      this.display();
    }));
    if (this.plugin.settings.halfDayMode === "fixed") {
      new import_obsidian.Setting(balanceCalcSection.content).setName("Half-day hours").setDesc("Hours counted for a half workday").addText((text) => text.setPlaceholder("4.0").setValue(this.plugin.settings.halfDayHours.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0 && num < this.plugin.settings.baseWorkday) {
          this.plugin.settings.halfDayHours = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
    }
    const balanceThresholdsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance Color Thresholds",
      false
    );
    new import_obsidian.Setting(balanceThresholdsSection.content).setName("Balance color thresholds").setDesc("Configure the hour thresholds for balance indicator colors. These control the color-coding of your flextime balance badge: Red = significant under/overtime, Yellow = approaching limits, Green = healthy balance.");
    new import_obsidian.Setting(balanceThresholdsSection.content).setName("Critical low threshold (red)").setDesc("Below this many hours = red badge (significant undertime)").addText((text) => text.setPlaceholder("-15").setValue(this.plugin.settings.balanceThresholds.criticalLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num < this.plugin.settings.balanceThresholds.warningLow) {
        this.plugin.settings.balanceThresholds.criticalLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(balanceThresholdsSection.content).setName("Warning low threshold (yellow)").setDesc("Below this = yellow badge (approaching undertime)").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.balanceThresholds.warningLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.criticalLow && num < this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.warningLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(balanceThresholdsSection.content).setName("Warning high threshold (yellow)").setDesc("Above this = yellow badge (approaching overtime limit)").addText((text) => text.setPlaceholder("80").setValue(this.plugin.settings.balanceThresholds.warningHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningLow && num < this.plugin.settings.balanceThresholds.criticalHigh) {
        this.plugin.settings.balanceThresholds.warningHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian.Setting(balanceThresholdsSection.content).setName("Critical high threshold (red)").setDesc("Above this = red badge (significant overtime accumulation)").addText((text) => text.setPlaceholder("95").setValue(this.plugin.settings.balanceThresholds.criticalHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.criticalHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    const dataValidationSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Data Validation Thresholds",
      false
    );
    new import_obsidian.Setting(dataValidationSection.content).setName("Data validation thresholds").setDesc("Automatic data quality checks. Adjust these if you frequently work long hours or want stricter validation.");
    new import_obsidian.Setting(dataValidationSection.content).setName("Long-running timer warning (hours)").setDesc("Warn if a timer runs more than X hours without being stopped (default: 12)").addText((text) => text.setPlaceholder("12").setValue(this.plugin.settings.validationThresholds.longRunningTimerHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.longRunningTimerHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(dataValidationSection.content).setName("Very long session warning (hours)").setDesc("Warn if a work session exceeds X hours (default: 16)").addText((text) => text.setPlaceholder("16").setValue(this.plugin.settings.validationThresholds.veryLongSessionHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.veryLongSessionHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(dataValidationSection.content).setName("Maximum session duration (hours)").setDesc("Prevent entries longer than X hours - likely a data error (default: 24)").addText((text) => text.setPlaceholder("24").setValue(this.plugin.settings.validationThresholds.maxDurationHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.maxDurationHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(dataValidationSection.content).setName("High weekly total info (hours)").setDesc("Show info notice if weekly total exceeds X hours (default: 60)").addText((text) => text.setPlaceholder("60").setValue(this.plugin.settings.validationThresholds.highWeeklyTotalHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.highWeeklyTotalHours = num;
        await this.plugin.saveSettings();
      }
    }));
    const customColorsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Custom Colors",
      false
    );
    const balanceOkSetting = new import_obsidian.Setting(customColorsSection.content).setName("Balance OK color").setDesc("Color when flextime balance is in acceptable range").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceOk) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceOkSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = DEFAULT_SETTINGS.customColors.balanceOk;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceWarningSetting = new import_obsidian.Setting(customColorsSection.content).setName("Balance warning color").setDesc("Color when flextime balance is approaching limits").addText((text) => {
      var _a;
      return text.setPlaceholder("#ff9800").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceWarning) || "#ff9800").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceWarningSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = DEFAULT_SETTINGS.customColors.balanceWarning;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceCriticalSetting = new import_obsidian.Setting(customColorsSection.content).setName("Balance critical color").setDesc("Color when flextime balance is critically out of range").addText((text) => {
      var _a;
      return text.setPlaceholder("#f44336").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceCritical) || "#f44336").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceCriticalSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = DEFAULT_SETTINGS.customColors.balanceCritical;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const progressBarSetting = new import_obsidian.Setting(customColorsSection.content).setName("Progress bar color").setDesc("Color for progress bars showing daily/weekly completion").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    progressBarSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = DEFAULT_SETTINGS.customColors.progressBar;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
  }
  exportToCSV() {
    const entries = this.plugin.timerManager.convertToTimeEntries();
    const rows = [["Name", "Start Time", "End Time", "Duration (hours)"]];
    entries.forEach((entry) => {
      if (entry.startTime && entry.endTime) {
        const start = new Date(entry.startTime);
        const end = new Date(entry.endTime);
        const durationHours = ((end.getTime() - start.getTime()) / (1e3 * 60 * 60)).toFixed(2);
        rows.push([
          entry.name,
          start.toISOString(),
          end.toISOString(),
          durationHours
        ]);
      }
    });
    const csv = rows.map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian.Notice("\u2705 Exported to CSV");
  }
  showImportModal() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Import Timekeep Data");
    const { contentEl } = modal;
    contentEl.createEl("p", {
      text: "Paste your Timekeep JSON data below. This can be from a timekeep codeblock or exported data.",
      cls: "setting-item-description"
    });
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "15",
        placeholder: '{"entries":[...]}'
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} How to get your data:" });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: "Open your file with Timekeep codeblocks" });
    list.createEl("li", { text: "Copy the entire JSON from inside the timekeep block" });
    list.createEl("li", { text: "Paste it in the text area above" });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const importBtn = buttonDiv.createEl("button", { text: "Import", cls: "mod-cta" });
    importBtn.onclick = async () => {
      const jsonText = textArea.value.trim();
      if (!jsonText) {
        new import_obsidian.Notice("\u26A0\uFE0F Please paste your Timekeep data");
        return;
      }
      try {
        const data = JSON.parse(jsonText);
        if (!data.entries || !Array.isArray(data.entries)) {
          new import_obsidian.Notice('\u26A0\uFE0F Invalid format: missing "entries" array');
          return;
        }
        if (data.entries.length > 0) {
          const firstEntry = data.entries[0];
          if (!firstEntry.hasOwnProperty("name") || !firstEntry.hasOwnProperty("startTime")) {
            new import_obsidian.Notice("\u26A0\uFE0F Invalid entry format: missing required fields (name, startTime)");
            return;
          }
        }
        const success = await this.plugin.timerManager.importTimekeepData(jsonText);
        if (success) {
          modal.close();
          await this.refreshView();
        }
      } catch (error) {
        if (error instanceof SyntaxError) {
          new import_obsidian.Notice("\u26A0\uFE0F Invalid JSON format. Please check your data.");
        } else {
          new import_obsidian.Notice(`\u274C Error: ${error.message}`);
        }
        console.error("Import error:", error);
      }
    };
    const hint = contentEl.createEl("div");
    hint.style.marginTop = "10px";
    hint.style.fontSize = "12px";
    hint.style.color = "var(--text-muted)";
    hint.textContent = '\u{1F4A1} Tip: You can also create "TimeFlow Data.md" manually in your vault root';
    modal.open();
  }
  showNoteTypeModal(noteType, index) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText(noteType ? "Edit Note Type" : "Add Note Type");
    const { contentEl } = modal;
    const formData = {
      id: (noteType == null ? void 0 : noteType.id) || "",
      label: (noteType == null ? void 0 : noteType.label) || "",
      icon: (noteType == null ? void 0 : noteType.icon) || "\u{1F4C4}",
      folder: (noteType == null ? void 0 : noteType.folder) || "",
      template: (noteType == null ? void 0 : noteType.template) || "",
      tags: (noteType == null ? void 0 : noteType.tags.join(", ")) || "",
      filenamePattern: (noteType == null ? void 0 : noteType.filenamePattern) || "{YYYY}-{MM}-{DD}"
    };
    new import_obsidian.Setting(contentEl).setName("ID").setDesc("Unique identifier for this note type (lowercase, no spaces)").addText((text) => {
      text.setPlaceholder("meeting").setValue(formData.id).onChange((value) => {
        formData.id = value.toLowerCase().replace(/\s+/g, "-");
      });
      if (noteType) {
        text.inputEl.disabled = true;
      }
    });
    new import_obsidian.Setting(contentEl).setName("Label").setDesc("Display name shown in the context menu").addText((text) => text.setPlaceholder("M\xF8tenotat").setValue(formData.label).onChange((value) => {
      formData.label = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Icon").setDesc("Emoji or icon to display (single character)").addText((text) => text.setPlaceholder("\u{1F465}").setValue(formData.icon).onChange((value) => {
      formData.icon = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Folder").setDesc("Folder where notes will be created").addText((text) => text.setPlaceholder("M\xF8ter").setValue(formData.folder).onChange((value) => {
      formData.folder = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Template Path").setDesc("Path to the template file (relative to vault root)").addText((text) => text.setPlaceholder("timeflow/templates/meeting-note.md").setValue(formData.template).onChange((value) => {
      formData.template = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Tags").setDesc("Comma-separated tags to add to notes (e.g., #m\xF8te, #timeflow)").addText((text) => text.setPlaceholder("#m\xF8te, #timeflow").setValue(formData.tags).onChange((value) => {
      formData.tags = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Filename Pattern").setDesc("Pattern for note filenames. Available: {YYYY}, {MM}, {DD}, {WEEK}").addText((text) => text.setPlaceholder("{YYYY}-{MM}-{DD} M\xF8te").setValue(formData.filenamePattern).onChange((value) => {
      formData.filenamePattern = value;
    }));
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginTop = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.style.fontSize = "0.9em";
    infoDiv.innerHTML = `
			<strong>\u{1F4CB} Pattern Variables:</strong>
			<ul style="margin: 8px 0 0 20px;">
				<li><code>{YYYY}</code> - Four-digit year (e.g., 2025)</li>
				<li><code>{MM}</code> - Two-digit month (e.g., 01)</li>
				<li><code>{DD}</code> - Two-digit day (e.g., 15)</li>
				<li><code>{WEEK}</code> - ISO week number (e.g., 07)</li>
			</ul>
		`;
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!formData.id || !formData.label || !formData.folder) {
        new import_obsidian.Notice("\u26A0\uFE0F Please fill in all required fields (ID, Label, Folder)");
        return;
      }
      const tagsArray = formData.tags.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      const newNoteType = {
        id: formData.id,
        label: formData.label,
        icon: formData.icon || "\u{1F4C4}",
        folder: formData.folder,
        template: formData.template,
        tags: tagsArray,
        filenamePattern: formData.filenamePattern || "{YYYY}-{MM}-{DD}"
      };
      if (index >= 0) {
        this.plugin.settings.noteTypes[index] = newNoteType;
      } else {
        const existingIndex = this.plugin.settings.noteTypes.findIndex((nt) => nt.id === newNoteType.id);
        if (existingIndex >= 0) {
          new import_obsidian.Notice("\u26A0\uFE0F A note type with this ID already exists");
          return;
        }
        this.plugin.settings.noteTypes.push(newNoteType);
      }
      await this.plugin.saveSettings();
      await this.refreshView();
      modal.close();
      this.display();
      new import_obsidian.Notice(`\u2705 Note type ${noteType ? "updated" : "added"} successfully`);
    };
    modal.open();
  }
};

// src/view.ts
var import_obsidian4 = require("obsidian");

// src/dataManager.ts
var import_obsidian2 = require("obsidian");
var DataManager = class {
  constructor(entries, settings, app) {
    this.daily = {};
    this.months = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.holidays = {};
    // Cache for expensive calculations
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries = entries;
    this.settings = settings;
    this.app = app;
    this.workdayHours = settings.baseWorkday * settings.workPercent;
    this.workweekHours = settings.baseWorkweek * settings.workPercent;
  }
  async loadHolidays() {
    const status = { success: false, message: "", count: 0, warning: null };
    try {
      const holidayFile = this.app.vault.getAbstractFileByPath(this.settings.holidaysFilePath);
      if (holidayFile && holidayFile instanceof import_obsidian2.TFile) {
        const content = await this.app.vault.read(holidayFile);
        const lines = content.split("\n");
        lines.forEach((line) => {
          const match = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*(\w+)(?::half)?:\s*(.+)$/);
          if (match) {
            const [, date, type, description] = match;
            const isHalfDay = line.includes(":half:");
            this.holidays[date] = {
              type: type.trim().toLowerCase(),
              description: description.trim(),
              halfDay: isHalfDay
            };
          }
        });
        status.success = true;
        status.count = Object.keys(this.holidays).length;
        status.message = `Loaded ${status.count} planned days`;
        console.log(`Loaded ${status.count} future days`);
      } else {
        status.warning = `Holiday file not found: ${this.settings.holidaysFilePath}`;
        console.warn(status.warning);
      }
    } catch (error) {
      status.warning = `Error loading holidays: ${error.message}`;
      console.warn("Could not load future days file:", error);
    }
    return status;
  }
  isHoliday(dateStr) {
    return this.holidays.hasOwnProperty(dateStr);
  }
  getHolidayInfo(dateStr) {
    return this.holidays[dateStr] || null;
  }
  getSpecialDayBehavior(id) {
    return this.settings.specialDayBehaviors.find((b) => b.id === id);
  }
  getDailyGoal(dateStr) {
    if (!this.settings.enableGoalTracking) {
      return 0;
    }
    const date = new Date(dateStr);
    const isWeekend = Utils.isWeekend(date, this.settings);
    if (isWeekend)
      return 0;
    const holidayInfo = this.getHolidayInfo(dateStr);
    if (holidayInfo) {
      const behavior = this.getSpecialDayBehavior(holidayInfo.type);
      if (behavior && behavior.noHoursRequired) {
        return 0;
      }
      if (holidayInfo.halfDay) {
        const halfDayHours = this.settings.halfDayMode === "percentage" ? this.settings.baseWorkday / 2 : this.settings.halfDayHours;
        return halfDayHours;
      }
    }
    return this.workdayHours;
  }
  processEntries() {
    this.daily = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.months = {};
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries.forEach((e) => {
      if (!e.startTime)
        return;
      if (!e.endTime) {
        this.activeEntries.push(e);
        const start2 = Utils.parseDate(e.startTime);
        if (start2) {
          const dayKey2 = Utils.toLocalDateStr(start2);
          if (!this.activeEntriesByDate[dayKey2])
            this.activeEntriesByDate[dayKey2] = [];
          this.activeEntriesByDate[dayKey2].push(e);
        }
        return;
      }
      const start = Utils.parseDate(e.startTime);
      const end = Utils.parseDate(e.endTime);
      if (!start || !end)
        return;
      let duration = Utils.hoursDiff(start, end);
      if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
        const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
        duration = Math.max(0, duration - lunchBreakHours);
      }
      const dayKey = Utils.toLocalDateStr(start);
      if (!this.daily[dayKey])
        this.daily[dayKey] = [];
      this.daily[dayKey].push({ ...e, duration, date: start });
    });
    this.calculateFlextime();
    this.groupByMonths();
  }
  calculateFlextime() {
    for (let day in this.daily) {
      const dayGoal = this.getDailyGoal(day);
      const holidayInfo = this.getHolidayInfo(day);
      this.daily[day].forEach((e) => {
        let flextime = 0;
        const name = e.name.toLowerCase();
        if (holidayInfo) {
          const behavior = this.getSpecialDayBehavior(holidayInfo.type);
          if (behavior) {
            if (behavior.flextimeEffect === "withdraw") {
              flextime -= e.duration || 0;
            } else if (behavior.flextimeEffect === "accumulate") {
              if (dayGoal > 0 && (e.duration || 0) > dayGoal) {
                flextime += (e.duration || 0) - dayGoal;
              }
            }
          }
        } else if (dayGoal === 0) {
          flextime += e.duration || 0;
        } else {
          if ((e.duration || 0) > dayGoal) {
            flextime += (e.duration || 0) - dayGoal;
          }
        }
        e.flextime = flextime;
      });
    }
  }
  groupByMonths() {
    for (let day of Object.keys(this.daily)) {
      const date = new Date(day);
      const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
      if (!this.months[monthKey])
        this.months[monthKey] = {};
      const weekNum = Math.ceil((date.getDate() - date.getDay() + 1) / 7);
      if (!this.months[monthKey][weekNum])
        this.months[monthKey][weekNum] = [];
      this.months[monthKey][weekNum].push(...this.daily[day]);
    }
  }
  getOngoing() {
    const now = /* @__PURE__ */ new Date();
    return this.activeEntries.reduce((sum, e) => {
      const start = Utils.parseDate(e.startTime);
      return start ? sum + Utils.hoursDiff(start, now) : sum;
    }, 0);
  }
  getBalanceUpToDate(endDate) {
    let balance = 0;
    const startDate = this.settings.balanceStartDate;
    const sortedDays = Object.keys(this.daily).filter((day) => day >= startDate && day <= endDate).sort();
    for (const day of sortedDays) {
      const dayGoal = this.getDailyGoal(day);
      const dayEntries = this.daily[day] || [];
      let dayWorked = 0;
      let avspaseringHours = 0;
      dayEntries.forEach((e) => {
        if (e.name.toLowerCase() === "avspasering") {
          avspaseringHours += e.duration || 0;
        } else {
          dayWorked += e.duration || 0;
        }
      });
      if (dayGoal === 0) {
        balance += dayWorked;
      } else {
        balance += dayWorked - dayGoal;
      }
      balance -= avspaseringHours;
    }
    return balance;
  }
  getCurrentBalance() {
    const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    return this.getBalanceUpToDate(today);
  }
  getTotalFlextime() {
    return this.getCurrentBalance();
  }
  getCurrentWeekHours(today) {
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    const lastDayOfWeek = new Date(firstDayOfWeek);
    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
    let total = 0;
    for (let d = new Date(firstDayOfWeek); d <= lastDayOfWeek; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "egenmelding" && name !== "velferdspermisjon" && name !== "ferie") {
          total += entry.duration || 0;
        }
      });
    }
    return total + this.getOngoing();
  }
  getTodayHours(today) {
    const todayKey = Utils.toLocalDateStr(today);
    const todayEntries = this.daily[todayKey] || [];
    return todayEntries.reduce((sum, e) => sum + (e.duration || 0), 0) + this.getOngoing();
  }
  getAverages() {
    if (this._cachedAverages) {
      return this._cachedAverages;
    }
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const pastKeys = Object.keys(this.daily).filter((d) => d < todayKey);
    const weekdayKeys = pastKeys.filter((dk) => {
      const date = Utils.parseDate(dk);
      return date && !Utils.isWeekend(date, this.settings);
    });
    const totalHoursWorked = weekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const avgDaily = weekdayKeys.length > 0 ? totalHoursWorked / weekdayKeys.length : 0;
    const avgWeekly = totalHoursWorked / (weekdayKeys.length / this.settings.workdaysPerWeek || 1);
    this._cachedAverages = {
      avgDaily,
      avgWeekly,
      totalDaysWorked: weekdayKeys.length,
      totalHoursWorked
    };
    return this._cachedAverages;
  }
  getStatistics(timeframe = "total", year, month) {
    var _a, _b;
    const today = /* @__PURE__ */ new Date();
    let filterFn;
    if (timeframe === "year") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      filterFn = (dateStr) => new Date(dateStr).getFullYear() === targetYear;
    } else if (timeframe === "month") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      const targetMonth = month !== void 0 ? month : today.getMonth();
      filterFn = (dateStr) => {
        const d = new Date(dateStr);
        return d.getFullYear() === targetYear && d.getMonth() === targetMonth;
      };
    } else {
      filterFn = () => true;
    }
    const filteredDays = Object.keys(this.daily).filter(filterFn);
    const allEntries = filteredDays.flatMap((day) => this.daily[day]);
    const stats = {
      totalHours: allEntries.reduce((sum, e) => sum + (e.duration || 0), 0),
      totalFlextime: allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0),
      jobb: { count: 0, hours: 0 },
      avspasering: { count: 0, hours: 0, planned: 0 },
      ferie: { count: 0, hours: 0, max: ((_a = this.getSpecialDayBehavior("ferie")) == null ? void 0 : _a.maxDaysPerYear) || this.settings.maxFerieDays, planned: 0 },
      velferdspermisjon: { count: 0, hours: 0, planned: 0 },
      egenmelding: { count: 0, hours: 0, max: ((_b = this.getSpecialDayBehavior("egenmelding")) == null ? void 0 : _b.maxDaysPerYear) || this.settings.maxEgenmeldingDays },
      sykemelding: { count: 0, hours: 0 },
      studie: { count: 0, hours: 0, planned: 0 },
      kurs: { count: 0, hours: 0, planned: 0 },
      workDays: 0,
      weekendDays: 0,
      weekendHours: 0,
      avgDailyHours: 0,
      workloadPercent: 0
    };
    const daysByType = {
      jobb: /* @__PURE__ */ new Set(),
      avspasering: /* @__PURE__ */ new Set(),
      ferie: /* @__PURE__ */ new Set(),
      velferdspermisjon: /* @__PURE__ */ new Set(),
      egenmelding: /* @__PURE__ */ new Set(),
      sykemelding: /* @__PURE__ */ new Set(),
      studie: /* @__PURE__ */ new Set(),
      kurs: /* @__PURE__ */ new Set()
    };
    const uniqueDays = /* @__PURE__ */ new Set();
    const weekendDaysSet = /* @__PURE__ */ new Set();
    const workDaysSet = /* @__PURE__ */ new Set();
    filteredDays.forEach((dayKey) => {
      const dayDate = new Date(dayKey);
      const dayEntries = this.daily[dayKey];
      uniqueDays.add(dayKey);
      dayEntries.forEach((e) => {
        const name = e.name.toLowerCase();
        if (e.date && Utils.isWeekend(e.date, this.settings)) {
          weekendDaysSet.add(dayKey);
          stats.weekendHours += e.duration || 0;
        } else {
          workDaysSet.add(dayKey);
        }
        if (name === "jobb" || !["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType.jobb.add(dayKey);
          stats.jobb.hours += e.duration || 0;
        } else if (["avspasering", "ferie", "velferdspermisjon", "egenmelding", "studie", "kurs"].includes(name)) {
          daysByType[name].add(dayKey);
          stats[name].hours += e.duration || 0;
        }
      });
    });
    stats.weekendDays = weekendDaysSet.size;
    stats.workDays = workDaysSet.size;
    stats.jobb.count = daysByType.jobb.size;
    stats.avspasering.count = daysByType.avspasering.size;
    stats.ferie.count = daysByType.ferie.size;
    stats.velferdspermisjon.count = daysByType.velferdspermisjon.size;
    stats.egenmelding.count = daysByType.egenmelding.size;
    stats.studie.count = daysByType.studie.size;
    stats.kurs.count = daysByType.kurs.size;
    Object.keys(this.holidays).forEach((dateStr) => {
      const plannedInfo = this.holidays[dateStr];
      const plannedDate = new Date(dateStr);
      if (filterFn(dateStr) && plannedDate > today) {
        const type = plannedInfo.type;
        if (type === "ferie" && stats.ferie) {
          stats.ferie.planned++;
        } else if (type === "avspasering" && stats.avspasering) {
          stats.avspasering.planned++;
        } else if (type === "velferdspermisjon" && stats.velferdspermisjon) {
          stats.velferdspermisjon.planned++;
        } else if (type === "studie" && stats.studie) {
          stats.studie.planned++;
        } else if (type === "kurs" && stats.kurs) {
          stats.kurs.planned++;
        }
      }
    });
    stats.avgDailyHours = uniqueDays.size > 0 ? stats.totalHours / uniqueDays.size : 0;
    if (timeframe === "year" || timeframe === "month") {
      const expectedWorkdays = timeframe === "year" ? this.settings.workdaysPerYear : this.settings.workdaysPerMonth;
      const expectedHours = expectedWorkdays * this.workdayHours;
      stats.workloadPercent = expectedHours > 0 ? stats.totalHours / expectedHours * 100 : 0;
    }
    return stats;
  }
  getAvailableYears() {
    const years = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const year = new Date(dateStr).getFullYear();
      years.add(year);
    });
    return Array.from(years).sort((a, b) => b - a);
  }
  getAvailableMonthsForYear(year) {
    const months = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const date = new Date(dateStr);
      if (date.getFullYear() === year) {
        months.add(date.getMonth());
      }
    });
    return Array.from(months).sort((a, b) => a - b);
  }
  getContextualData(today) {
    const todayKey = Utils.toLocalDateStr(today);
    if (this._cachedContextData[todayKey]) {
      return this._cachedContextData[todayKey];
    }
    const weekday = today.getDay();
    let consecutiveFlextimeDays = 0;
    const sortedDays = Object.keys(this.daily).sort().reverse();
    for (let day of sortedDays) {
      if (day >= todayKey)
        continue;
      const dayFlextime = this.daily[day].reduce(
        (sum, e) => sum + (e.flextime || 0),
        0
      );
      if (dayFlextime > 0) {
        consecutiveFlextimeDays++;
      } else {
        break;
      }
    }
    const sameWeekdayKeys = Object.keys(this.daily).filter((d) => {
      const date = new Date(d);
      return date.getDay() === weekday && d < todayKey;
    });
    const sameDayTotal = sameWeekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const sameDayAvg = sameWeekdayKeys.length > 0 ? sameDayTotal / sameWeekdayKeys.length : 0;
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const thisWeekMonday = new Date(today);
    thisWeekMonday.setDate(today.getDate() - daysFromMonday);
    const lastWeekStart = new Date(thisWeekMonday);
    lastWeekStart.setDate(thisWeekMonday.getDate() - 7);
    const lastWeekEnd = new Date(lastWeekStart);
    lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
    let lastWeekHours = 0;
    for (let d = new Date(lastWeekStart); d <= lastWeekEnd; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      lastWeekHours += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
    }
    const result = { consecutiveFlextimeDays, sameDayAvg, lastWeekHours };
    this._cachedContextData[todayKey] = result;
    return result;
  }
  getWeekTotals(numWeeks = 8) {
    const today = /* @__PURE__ */ new Date();
    const weekTotals = [];
    for (let i = numWeeks - 1; i >= 0; i--) {
      const d = new Date(today);
      d.setDate(today.getDate() - i * 7);
      const dayOfWeek = d.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const weekStart = new Date(d);
      weekStart.setDate(d.getDate() - daysFromMonday);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      let weekSum = 0;
      for (let wd = new Date(weekStart); wd <= weekEnd; wd = new Date(wd.getFullYear(), wd.getMonth(), wd.getDate() + 1)) {
        const dayKey = Utils.toLocalDateStr(wd);
        const dayEntries = this.daily[dayKey] || [];
        weekSum += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
      }
      weekTotals.push(weekSum);
    }
    return weekTotals;
  }
  validateData() {
    const issues = {
      errors: [],
      warnings: [],
      info: [],
      stats: {
        totalEntries: 0,
        entriesChecked: 0,
        entriesWithIssues: 0
      }
    };
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const createIssue = (severity, type, description, entry, dayKey) => {
      issues.stats.entriesWithIssues++;
      return {
        severity,
        type,
        description,
        date: dayKey,
        entry: {
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          duration: entry.duration
        }
      };
    };
    for (const dayKey in this.daily) {
      const dayEntries = this.daily[dayKey];
      issues.stats.totalEntries += dayEntries.length;
      dayEntries.forEach((entry) => {
        var _a, _b, _c;
        issues.stats.entriesChecked++;
        if (!entry.name || entry.name.trim() === "") {
          issues.errors.push(createIssue(
            "error",
            "Missing Entry Name",
            "Entry has no name/type",
            entry,
            dayKey
          ));
        }
        if (!entry.startTime) {
          issues.errors.push(createIssue(
            "error",
            "Missing Start Time",
            "Entry has no start time",
            entry,
            dayKey
          ));
          return;
        }
        if ((entry.duration || 0) < 0) {
          issues.errors.push(createIssue(
            "error",
            "Negative Duration",
            `End time is before start time (${(_a = entry.duration) == null ? void 0 : _a.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.maxDurationHours) {
          issues.errors.push(createIssue(
            "error",
            "Excessive Duration",
            `Entry spans more than ${this.settings.validationThresholds.maxDurationHours} hours (${(_b = entry.duration) == null ? void 0 : _b.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.veryLongSessionHours && (entry.duration || 0) <= this.settings.validationThresholds.maxDurationHours) {
          issues.warnings.push(createIssue(
            "warning",
            "Very Long Session",
            `Entry duration exceeds ${this.settings.validationThresholds.veryLongSessionHours} hours (${(_c = entry.duration) == null ? void 0 : _c.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) === 0) {
          issues.info.push(createIssue(
            "info",
            "Zero Duration",
            "Entry has zero duration",
            entry,
            dayKey
          ));
        }
        if (dayKey > todayStr) {
          issues.info.push(createIssue(
            "info",
            "Future Date",
            "Entry is dated in the future",
            entry,
            dayKey
          ));
        }
      });
      if (dayEntries.length > 1) {
        const sortedEntries = [...dayEntries].filter((e) => e.startTime && e.endTime).sort((a, b) => {
          const aStart = new Date(a.startTime);
          const bStart = new Date(b.startTime);
          return aStart.getTime() - bStart.getTime();
        });
        for (let i = 0; i < sortedEntries.length - 1; i++) {
          const current = sortedEntries[i];
          const next = sortedEntries[i + 1];
          if (current.startTime && current.endTime && next.startTime && next.endTime) {
            const currentEnd = new Date(current.endTime);
            const nextStart = new Date(next.startTime);
            if (currentEnd > nextStart) {
              const overlapMinutes = Math.round((currentEnd.getTime() - nextStart.getTime()) / 6e4);
              issues.errors.push({
                severity: "error",
                type: "Overlapping Entries",
                description: `Entries overlap by ${overlapMinutes} minutes`,
                date: dayKey,
                entry: {
                  name: `${current.name} \u2192 ${next.name}`,
                  startTime: current.startTime,
                  endTime: next.endTime
                }
              });
              issues.stats.entriesWithIssues++;
            }
          }
        }
      }
    }
    const allDates = Object.keys(this.daily).sort();
    if (allDates.length > 0) {
      const firstDate = new Date(allDates[0]);
      const lastDate = today;
      for (let d = new Date(firstDate); d <= lastDate; d.setDate(d.getDate() + 1)) {
        const dateStr = Utils.toLocalDateStr(d);
        const isWeekend = Utils.isWeekend(d, this.settings);
        const holidayInfo = this.getHolidayInfo(dateStr);
        const hasEntries = this.daily[dateStr] && this.daily[dateStr].length > 0;
        if (isWeekend)
          continue;
        if (holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type)) {
          continue;
        }
        if (dateStr >= todayStr)
          continue;
        if (!hasEntries) {
          issues.warnings.push({
            severity: "warning",
            type: "Missing Entry",
            description: "No work entries registered for this workday",
            date: dateStr
          });
        }
      }
    }
    issues.stats.totalEntries += this.activeEntries.length;
    this.activeEntries.forEach((entry) => {
      issues.stats.entriesChecked++;
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        const now = /* @__PURE__ */ new Date();
        const hoursRunning = Utils.hoursDiff(startTime, now);
        if (hoursRunning > this.settings.validationThresholds.longRunningTimerHours) {
          issues.warnings.push({
            severity: "warning",
            type: "Long-Running Timer",
            description: `Active timer has been running for ${hoursRunning.toFixed(1)} hours (threshold: ${this.settings.validationThresholds.longRunningTimerHours}h)`,
            date: Utils.toLocalDateStr(startTime),
            entry: {
              name: entry.name,
              startTime: entry.startTime,
              duration: hoursRunning
            }
          });
          issues.stats.entriesWithIssues++;
        }
      }
    });
    const currentWeekHours = this.getCurrentWeekHours(today);
    if (currentWeekHours > this.settings.validationThresholds.highWeeklyTotalHours) {
      issues.info.push({
        severity: "info",
        type: "High Weekly Total",
        description: `Current week total exceeds ${this.settings.validationThresholds.highWeeklyTotalHours} hours (${currentWeekHours.toFixed(1)}h)`,
        date: todayStr
      });
    }
    return {
      hasErrors: issues.errors.length > 0,
      hasWarnings: issues.warnings.length > 0,
      hasInfo: issues.info.length > 0,
      issues,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Check if there's a rest period violation for a given date
   * A violation occurs when the gap between the last work session ending on the previous day
   * and the first work session starting on the given day is less than the minimum rest hours
   */
  checkRestPeriodViolation(dateStr) {
    var _a, _b;
    const minimumRestHours = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11;
    const currentDate = new Date(dateStr);
    const previousDate = new Date(currentDate);
    previousDate.setDate(previousDate.getDate() - 1);
    const previousDayKey = Utils.toLocalDateStr(previousDate);
    const previousDayEntries = this.daily[previousDayKey] || [];
    const currentDayEntries = this.daily[dateStr] || [];
    if (previousDayEntries.length === 0 || currentDayEntries.length === 0) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    let lastEndTimeMs = 0;
    let lastEndTimeStr = "";
    previousDayEntries.forEach((entry) => {
      if (entry.endTime) {
        const endTime = new Date(entry.endTime);
        if (endTime.getTime() > lastEndTimeMs) {
          lastEndTimeMs = endTime.getTime();
          lastEndTimeStr = endTime.toISOString();
        }
      }
    });
    let firstStartTimeMs = Infinity;
    let firstStartTimeStr = "";
    currentDayEntries.forEach((entry) => {
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        if (startTime.getTime() < firstStartTimeMs) {
          firstStartTimeMs = startTime.getTime();
          firstStartTimeStr = startTime.toISOString();
        }
      }
    });
    if (lastEndTimeMs === 0 || firstStartTimeMs === Infinity) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    const restHours = (firstStartTimeMs - lastEndTimeMs) / (1e3 * 60 * 60);
    const violated = restHours < minimumRestHours;
    return {
      violated,
      restHours,
      previousDayEnd: lastEndTimeStr,
      currentDayStart: firstStartTimeStr
    };
  }
  /**
   * Get statistics for a special day type, respecting the counting period setting
   * For historical years, always use calendar year counting
   * For current year, respect the countingPeriod setting
   */
  getSpecialDayStats(typeId, year) {
    const behavior = this.getSpecialDayBehavior(typeId);
    const today = /* @__PURE__ */ new Date();
    const currentYear = today.getFullYear();
    const targetYear = year != null ? year : currentYear;
    const isCurrentYear = targetYear === currentYear;
    const countingPeriod = (behavior == null ? void 0 : behavior.countingPeriod) || "calendar";
    const useRolling = isCurrentYear && countingPeriod === "rolling365";
    let count = 0;
    const daysSeen = /* @__PURE__ */ new Set();
    if (useRolling) {
      const cutoffDate = new Date(today);
      cutoffDate.setDate(cutoffDate.getDate() - 365);
      const cutoffStr = Utils.toLocalDateStr(cutoffDate);
      Object.keys(this.daily).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    } else {
      Object.keys(this.daily).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    }
    return {
      count,
      max: behavior == null ? void 0 : behavior.maxDaysPerYear,
      isRolling: useRolling,
      periodLabel: useRolling ? "365d" : targetYear.toString()
    };
  }
};

// src/uiBuilder.ts
var import_obsidian3 = require("obsidian");

// src/messageGenerator.ts
var MessageGenerator = class {
  static getDailyMessage(hours, goal, specials, isWeekendDay, avgDaily, context, consecutiveFlextimeWarningDays) {
    if (isWeekendDay) {
      const weekday = (/* @__PURE__ */ new Date()).getDay();
      if (weekday === 6) {
        if (hours === 0)
          return Utils.randMsg([
            "L\xF8rdag \u2013 ingen logg enn\xE5, perfekt for fri \u{1F6CC}",
            "Fri-modus: nyt l\xF8rdagen! \u{1F324}\uFE0F"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "Litt helgeinnsats \u2013 godt gjort!",
            "Rolig l\xF8rdag med litt arbeid \u2013 fin balanse \u2696\uFE0F"
          ]);
        return Utils.randMsg([
          "\u{1F525} Jobbing p\xE5 l\xF8rdagen \u2013 imponerende dedikasjon!",
          "L\xF8rdag med driv \u2013 pass p\xE5 \xE5 hvile litt ogs\xE5 \u{1F486}"
        ]);
      }
      if (weekday === 0) {
        if (hours === 0)
          return Utils.randMsg([
            "S\xF8ndag \u2013 helt fri, slik det skal v\xE6re \u2615",
            "S\xF8ndag \u2013 lade opp til en ny uke \u{1F33F}"
          ]);
        return Utils.randMsg([
          "Litt s\xF8ndagsjobbing \u2013 godt for samvittigheten \u{1F4AA}",
          "Rolig s\xF8ndag med litt innsats \u2013 flott balansert \u{1F31E}"
        ]);
      }
    }
    if (specials.length > 0) {
      const s = specials.join(", ").toLowerCase();
      const now2 = /* @__PURE__ */ new Date();
      const currentHour2 = now2.getHours();
      if (s.includes("ferie")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u2600\uFE0F Feriemorgen \u2013 sov lenge og slapp av!",
            "\u{1F3D6}\uFE0F Ferie \u2013 ingen tidlig start i dag!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u2600\uFE0F Nyt ferien \u2013 du har fortjent det!",
            "\u{1F334} Feriedag \u2013 gj\xF8r noe hyggelig!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Feriekveld \u2013 kos deg!",
          "\u2728 Ferieflyt \u2013 nyt kvelden!"
        ]);
      }
      if (s.includes("velferdspermisjon")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 ta vare p\xE5 deg selv",
            "\u{1F49A} Viktig dag for velv\xE6re \u2013 bruk tiden godt"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F3E5} Velferdspermisjon \u2013 h\xE5per alt g\xE5r bra",
            "\u{1F49A} Ta den tiden du trenger i dag"
          ]);
        return Utils.randMsg([
          "\u{1F319} Velferdspermisjon \u2013 hvil og ta vare p\xE5 deg",
          "\u2728 Viktig \xE5 prioritere eget velv\xE6re"
        ]);
      }
      if (s.includes("avspasering")) {
        if (currentHour2 < 12)
          return Utils.randMsg([
            "\u{1F6CC} Avspasering \u2013 perfekt dag for litt ekstra s\xF8vn!",
            "\u{1F634} Fri dag \u2013 du har fortjent denne hvilen!"
          ]);
        if (currentHour2 < 18)
          return Utils.randMsg([
            "\u{1F6CC} Godt med litt fri \u2013 du har fortjent det!",
            "\u{1F486} Avspasering \u2013 bruk dagen p\xE5 noe du liker!"
          ]);
        return Utils.randMsg([
          "\u{1F319} Avspasering \u2013 slapp av resten av kvelden!",
          "\u2728 Fin fridag \u2013 h\xE5per du har hatt en god dag!"
        ]);
      }
      if (s.includes("egenmelding")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F912} Egenmelding \u2013 hvil og bli frisk!",
            "\u{1F48A} Ta det rolig \u2013 kroppen trenger hvile!"
          ]);
        if (hours < 2)
          return Utils.randMsg([
            "\u{1F912} Egenmelding, men du har v\xE6rt litt aktiv \u2013 ikke overdriv!",
            "\u{1F48A} H\xE5per du f\xF8ler deg bedre \u2013 husk \xE5 hvile!"
          ]);
        return Utils.randMsg([
          "\u{1F912} Egenmelding med mye aktivitet \u2013 pass p\xE5 \xE5 ikke presse deg!",
          "\u{1F48A} Ta vare p\xE5 deg selv \u2013 hvil er viktig!"
        ]);
      }
      if (s.includes("studie") || s.includes("kurs")) {
        if (hours === 0)
          return Utils.randMsg([
            "\u{1F4D6} Studiedag \u2013 tid for \xE5 l\xE6re noe nytt!",
            "\u{1F4DA} Studietid \u2013 lykke til med l\xE6ringen!"
          ]);
        if (hours < 3)
          return Utils.randMsg([
            "\u{1F4D6} God start p\xE5 studiedagen \u2013 fortsett s\xE5nn!",
            "\u{1F4DA} Fin studieflyt s\xE5 langt!"
          ]);
        if (hours < 5)
          return Utils.randMsg([
            "\u{1F4D6} Solid studieinnsats \u2013 godt jobbet!",
            "\u{1F4DA} Du l\xE6rer mye i dag \u2013 flott fremgang!"
          ]);
        return Utils.randMsg([
          "\u{1F4D6} Imponerende studieinnsats i dag \u2013 husk pauser!",
          "\u{1F4DA} Dedikert studiedag \u2013 fantastisk innsats!"
        ]);
      }
    }
    const diff = hours - goal;
    const now = /* @__PURE__ */ new Date();
    const currentHour = now.getHours();
    if (context.consecutiveFlextimeDays >= consecutiveFlextimeWarningDays) {
      return `\u26A0\uFE0F ${context.consecutiveFlextimeDays} dager p\xE5 rad med fleksitid \u2013 husk \xE5 ta vare p\xE5 deg selv!`;
    }
    if (context.sameDayAvg > 0) {
      const weekdayName = [
        "s\xF8ndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "l\xF8rdag"
      ][now.getDay()];
      if (hours > context.sameDayAvg + 1) {
        return `Mer aktiv enn vanlig for en ${weekdayName} \u{1F4AA} (snitt: ${context.sameDayAvg.toFixed(1)}t)`;
      }
      if (hours < context.sameDayAvg - 1 && hours > 2) {
        return `Roligere ${weekdayName} enn vanlig (snitt: ${context.sameDayAvg.toFixed(1)}t) \u{1F33F}`;
      }
    }
    if (currentHour < 12 && hours === 0) {
      return "God morgen! Dagen starter rolig \u2615";
    }
    if (currentHour >= 15 && diff < -2) {
      const hoursNeeded = (goal - hours).toFixed(1);
      return `${hoursNeeded}t igjen for \xE5 n\xE5 dagsm\xE5l \u2013 fortsatt mulig! \u{1F3AF}`;
    }
    if (currentHour >= 16 && hours >= goal) {
      return "Dagsm\xE5l n\xE5dd! \u{1F389} Ta en pause eller jobb videre mot fleksitid.";
    }
    if (avgDaily > 0) {
      if (hours > avgDaily + 1)
        return "Du ligger over snittet for de siste dagene \u{1F44D}";
      if (hours < avgDaily - 1)
        return "Litt roligere enn vanlig \u2013 fullt fortjent \u{1F486}";
    }
    if (hours === 0)
      return "Rolig start \u2013 kanskje planlegg dagen?";
    if (diff < -1)
      return "Dagen har s\xE5 vidt begynt \u2013 god tid til \xE5 n\xE5 m\xE5let.";
    if (diff >= -1 && diff <= 1)
      return "Du ligger helt perfekt an i dag \u{1F44C}";
    if (diff > 1 && diff <= 2)
      return "Sterk innsats \u2013 n\xE6rmer deg fleksitid \u{1F4AA}";
    if (diff > 2)
      return "\u{1F680} Ekstra innsats i dag! Husk \xE5 ta deg tid til en pause.";
    return "";
  }
  static getWeeklyMessage(hours, goal, specials, today, context, weekendWorkHours = 0) {
    const ferie = specials.some((s) => s.toLowerCase().includes("ferie"));
    const velferdspermisjon = specials.some((s) => s.toLowerCase().includes("velferdspermisjon"));
    const avsp = specials.some((s) => s.toLowerCase().includes("avspasering"));
    const studie = specials.some((s) => s.toLowerCase().includes("studie") || s.toLowerCase().includes("kurs"));
    if (ferie)
      return "\u{1F3D6}\uFE0F Ukas rytme er preget av ferie \u2013 nyt det! ";
    if (velferdspermisjon)
      return "\u{1F3E5} Velferdspermisjon denne uka \u2013 ta vare p\xE5 deg selv! ";
    if (avsp)
      return "\u{1F60C} Litt fri denne uka \u2013 god balanse. ";
    if (studie)
      return "\u{1F4DA} Denne uka har du prioritert studier \u2013 flott! ";
    const weekday = today.getDay();
    const isWeekendDay = weekday === 6 || weekday === 0;
    const workdaysPassed = Math.min(Math.max(weekday - 1, 0), 5);
    const totalWorkdays = 5;
    const expectedProgress = workdaysPassed / totalWorkdays * goal;
    const diffFromExpected = hours - expectedProgress;
    if (context.lastWeekHours > 0) {
      const diff2 = hours - context.lastWeekHours;
      if (Math.abs(diff2) > 5 && workdaysPassed >= 3) {
        if (diff2 > 0) {
          return `Mer travelt enn forrige uke (+${diff2.toFixed(1)}t) \u{1F4C8} `;
        } else {
          return `Roligere enn forrige uke (${diff2.toFixed(1)}t) \u{1F4C9} `;
        }
      }
    }
    if (isWeekendDay) {
      if (weekendWorkHours === 0)
        return "\u{1F319} Helg! Godt jobbet denne uka \u2013 nyt fritiden. ";
      if (weekendWorkHours < 2)
        return "\u{1F4C5} Litt helgeinnsats \u2013 ikke glem pauser og p\xE5fyll! ";
      if (hours >= goal)
        return "\u{1F525} Jobbing i helga \u2013 imponerende dedikasjon, men pass p\xE5 \xE5 hvile! ";
      return "\u{1F31E} En rolig helg etter en balansert uke. ";
    }
    if (workdaysPassed <= 1) {
      if (hours < expectedProgress)
        return "Uka er i gang \u2013 ta det i eget tempo \u{1F4AA} ";
      if (diffFromExpected >= 1)
        return "Sterk start p\xE5 uka! \u{1F31F} ";
      return "Fin rytme s\xE5 langt \u2013 fortsett s\xE5nn. ";
    }
    if (workdaysPassed >= 2 && workdaysPassed <= 3) {
      if (diffFromExpected < -2)
        return "Du ligger litt bak skjema \u2013 men fortsatt god tid til \xE5 hente inn \u{1F33F} ";
      if (diffFromExpected >= -2 && diffFromExpected <= 2)
        return "Jevn og fin flyt gjennom uka \u{1F44C} ";
      if (diffFromExpected > 2)
        return "Travle dager \u2013 men du h\xE5ndterer det godt \u{1F4AA} ";
    }
    if (weekday === 5) {
      if (hours < goal * 0.8)
        return "Fredag \u2013 snart helg! Du er nesten i m\xE5l \u{1F3AF} ";
      if (hours >= goal && hours <= goal + 3)
        return "\u{1F44D} Uka i boks \u2013 god innsats! ";
      if (hours > goal + 3)
        return "\u{1F525} Ekstra innsats denne uka \u2013 husk \xE5 logge fleksitid! ";
      return "Fredagsflyt \u{1F324}\uFE0F ";
    }
    const diff = hours - goal;
    if (diff < -3)
      return "Du ligger litt bak skjema \u2013 ingen fare, uka er ung! ";
    if (diff >= -3 && diff <= 2)
      return "Fin flyt denne uka \u{1F33F} ";
    if (diff > 2 && diff <= 5)
      return "Travelt, men godt jobbet! ";
    if (diff > 5)
      return "\u{1F525} Ekstra innsats denne uka \u2013 pass p\xE5 hvilen! ";
    return "";
  }
};

// src/uiBuilder.ts
var UIBuilder = class {
  constructor(dataManager, systemStatus, settings, app, timerManager) {
    this.intervals = [];
    this.statsTimeframe = "total";
    this.historyView = "list";
    this.currentMonthOffset = 0;
    this.data = dataManager;
    this.systemStatus = systemStatus;
    this.settings = settings;
    this.app = app;
    this.timerManager = timerManager;
    this.container = this.createContainer();
    this.today = /* @__PURE__ */ new Date();
    this.selectedYear = this.today.getFullYear();
    this.selectedMonth = this.today.getMonth();
    this.elements = {
      badge: null,
      complianceBadge: null,
      timerBadge: null,
      clock: null,
      dayCard: null,
      weekCard: null,
      statsCard: null,
      monthCard: null
    };
  }
  getBalanceColor(balance) {
    const t = this.settings.balanceThresholds;
    const colors = this.settings.customColors;
    if (balance < t.criticalLow || balance > t.criticalHigh)
      return (colors == null ? void 0 : colors.balanceCritical) || "#f44336";
    if (balance < t.warningLow || balance > t.warningHigh)
      return (colors == null ? void 0 : colors.balanceWarning) || "#ff9800";
    return (colors == null ? void 0 : colors.balanceOk) || "#4caf50";
  }
  darkenColor(color, percent) {
    const hex = color.replace("#", "");
    const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - percent);
    const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - percent);
    const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - percent);
    return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
  }
  createContainer() {
    const container = document.createElement("div");
    container.style.fontFamily = "sans-serif";
    container.style.maxWidth = "1200px";
    container.style.margin = "0 auto";
    container.style.padding = "20px";
    container.style.boxSizing = "border-box";
    container.className = `timeflow-theme-${this.settings.theme}`;
    return container;
  }
  injectStyles() {
    const styleId = "timeflow-styles";
    if (document.getElementById(styleId))
      return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
			/* TimeFlow Dashboard Styles */
			.timeflow-dashboard {
				font-family: var(--font-text);
				padding: 20px;
				width: 100%;
			}

			.timeflow-error, .timeflow-warning {
				padding: 15px;
				border-radius: 5px;
				margin: 10px 0;
			}

			.timeflow-error {
				background: var(--background-modifier-error);
				color: var(--text-error);
			}

			.timeflow-warning {
				background: var(--background-modifier-warning);
				color: var(--text-warning);
			}

			/* Pulse animation for active entry indicator */
			@keyframes pulse {
				0%, 100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.6;
					transform: scale(1.1);
				}
			}

			.tf-badge-section {
				display: flex;
				align-items: center;
				gap: 12px;
				margin: 16px 0;
				flex-wrap: wrap;
			}

			.tf-compliance-badge {
				margin-left: auto;
			}

			.tf-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			/* Light theme - Clock badge uses the same gradient as other light elements */
			.tf-clock {
				padding: 10px 18px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				white-space: normal;
				text-align: center;
				max-width: 100%;
				min-height: 44px;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				color: #1a1a1a;
				font-weight: bold;
				font-variant-numeric: tabular-nums;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			}

			/* Dark theme - Clock badge uses consistent dark gradient */
			.timeflow-theme-dark .tf-clock {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				color: #e0e0e0;
			}

			/* System theme - Clock badge adapts to Obsidian theme */
			.timeflow-theme-system .tf-clock {
				background: var(--background-primary-alt);
				color: var(--text-normal);
				border: 1px solid var(--background-modifier-border);
			}

			.tf-timer-badge {
				padding: 10px 18px;
				border-radius: 12px;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
				white-space: normal;
				text-align: center;
				min-height: 44px;
				min-width: 0;
				cursor: pointer;
				transition: all 0.2s;
				border: none;
				font-family: inherit;
				font-size: inherit;
				font-weight: bold;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				/* Background colors are set dynamically based on timer state */
			}

			.tf-timer-badge:hover {
				transform: translateY(-1px);
				box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			}

			.tf-timer-badge:active {
				transform: translateY(0);
			}

			.tf-compliance-badge {
				padding: 10px 14px;
				border-radius: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				min-height: 44px;
				font-weight: bold;
				font-size: inherit;
				box-shadow: 0 2px 8px rgba(0,0,0,0.1);
				cursor: pointer;
			}

			/* Enable container queries on the dashboard container */
			.timeflow-dashboard {
				container-type: inline-size;
				container-name: dashboard;
			}

			/* Main cards container - wraps summary cards AND stats card for responsive layout */
			.tf-main-cards-wrapper {
				display: grid;
				gap: 15px;
				margin-bottom: 20px;
				width: 100%;
				box-sizing: border-box;
			}

			/* Mobile default: everything stacked */
			.tf-main-cards-wrapper {
				grid-template-columns: 1fr;
			}
			.tf-card-day { grid-column: 1; grid-row: 1; }
			.tf-card-week { grid-column: 1; grid-row: 2; }
			.tf-card-month { grid-column: 1; grid-row: 3; }
			.tf-card-stats { grid-column: 1; grid-row: 4; }

			/* Reduce gap and padding on very narrow containers */
			@container dashboard (max-width: 500px) {
				.tf-main-cards-wrapper { gap: 12px; }
				.tf-card { padding: 16px; }
			}

			/* Medium width: Day/Week side by side, Month and Stats stacked full width */
			@container dashboard (min-width: 501px) {
				.tf-main-cards-wrapper {
					grid-template-columns: repeat(2, minmax(0, 1fr));
				}
				.tf-card-day { grid-column: 1; grid-row: 1; }
				.tf-card-week { grid-column: 2; grid-row: 1; }
				.tf-card-month { grid-column: 1 / -1; grid-row: 2; }
				.tf-card-stats { grid-column: 1 / -1; grid-row: 3; }
			}

			/* Wide layout: 2x2 grid - Day/Week top, Month/Stats side by side bottom */
			@container dashboard (min-width: 750px) {
				.tf-card-month { grid-column: 1; grid-row: 2; }
				.tf-card-stats { grid-column: 2; grid-row: 2; }
			}

			/* Default card styling - used for month card */
			.tf-card {
				padding: 20px;
				border-radius: 12px;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				color: #1a1a1a;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				box-sizing: border-box;
				min-width: 0;
				overflow: hidden;
			}

			.tf-card-spaced {
				margin-top: 24px;
			}

			.tf-card h3 {
				margin-top: 0;
				margin-bottom: 15px;
				font-size: 18px;
				color: #1a1a1a;
			}

			/* Daily and Weekly cards use dynamic backgrounds set in updateDayCard/updateWeekCard */
			.tf-card-day,
			.tf-card-week {
				/* Background and color set dynamically based on progress */
			}

			/* System theme - match Obsidian's theme */
			.timeflow-theme-system .tf-card {
				background: var(--background-primary-alt);
				color: var(--text-normal);
				border: 1px solid var(--background-modifier-border);
			}

			.timeflow-theme-system .tf-card h3 {
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-card-stats {
				background: var(--background-primary-alt) !important;
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-stats h3 {
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-history {
				background: var(--background-primary-alt) !important;
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-card-history h3 {
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-stat-item {
				background: var(--background-secondary);
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-stat-label {
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-stat-value {
				color: var(--text-normal);
			}

			/* System theme - ensure all text inside stat items is readable */
			.timeflow-theme-system .tf-stat-item div {
				color: var(--text-normal);
			}

			.timeflow-theme-system .tf-stat-item .tf-stat-label {
				color: var(--text-normal);
			}

			/* System theme - stat labels in card stats should be readable */
			.timeflow-theme-system .tf-card-stats .tf-stat-label {
				color: var(--text-normal);
			}

			/* Colored stat items should always have white text */
			.tf-stat-colored,
			.tf-stat-colored div,
			.tf-stat-colored .tf-stat-label,
			.tf-stat-colored .tf-stat-value {
				color: white !important;
			}

			/* Dark theme - internally consistent with dark greens and blues */
			.timeflow-theme-dark .tf-card {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				color: #e0e0e0;
			}

			.timeflow-theme-dark .tf-card h3 {
				color: #e0e0e0;
			}

			.timeflow-theme-dark .tf-badge {
				/* Badge colors are set dynamically in updateBadge() */
			}

			/* Light theme - Progress bar */
			.tf-progress-bar {
				width: 100%;
				height: 12px;
				background: #ddd;
				border-radius: 6px;
				overflow: hidden;
				margin: 10px 0;
			}

			.timeflow-theme-dark .tf-progress-bar {
				background: rgba(255, 255, 255, 0.1);
			}

			/* Light theme - Progress fill uses green gradient from timeflow.js */
			.tf-progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #4caf50, #2e7d32);
				transition: width 0.3s ease;
			}

			.timeflow-theme-dark .tf-progress-fill {
				background: linear-gradient(90deg, #4caf50, #2e7d32);
			}

			.tf-month-grid {
				display: grid;
				grid-template-columns: repeat(7, 1fr);
				gap: 12px;
				margin-top: 15px;
				width: 100%;
				box-sizing: border-box;
			}

			/* Reduce gap on mobile to fit better */
			@media (max-width: 500px) {
				.tf-month-grid {
					gap: 6px;
				}
			}

			/* Day cells - consistent text colors across all themes since backgrounds are always the same */
			.tf-day-cell {
				aspect-ratio: 1;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 6px;
				font-size: clamp(12px, 2.5vw, 16px);
				font-weight: bold;
				cursor: pointer;
				transition: all 0.2s;
				position: relative;
				border: 2px solid transparent;
				text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
			}

			/* Days with entries - black text in all themes */
			.tf-day-cell.has-entry {
				color: #000000;
			}

			/* Days without entries - dark grey text in all themes */
			.tf-day-cell.no-entry {
				color: #4a4a4a;
			}

			.tf-day-cell:hover {
				transform: scale(1.05);
				box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			}

			.tf-day-cell.today {
				border-color: #4caf50;
				font-weight: bold;
			}

			.timeflow-theme-system .tf-day-cell.today {
				border-color: var(--interactive-accent);
			}

			/* Light theme - Stats card uses green gradient from timeflow.js */
			.tf-card-stats {
				background: linear-gradient(135deg, #e8f5e9, #c8e6c9) !important;
				color: #1a1a1a !important;
			}

			.tf-card-stats h3 {
				color: #1a1a1a !important;
			}

			/* Dark theme - Stats card uses darker consistent greens */
			.timeflow-theme-dark .tf-card-stats {
				background: linear-gradient(135deg, #253d25, #2d4d3d) !important;
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-card-stats h3 {
				color: #e0e0e0 !important;
			}

			/* Light theme - History card uses darker green from timeflow.js */
			.tf-card-history {
				background: linear-gradient(135deg, #a8d5ab, #8dc491) !important;
				color: #1a1a1a !important;
			}

			.tf-card-history h3 {
				color: #1a1a1a !important;
			}

			/* Dark theme - History card uses consistent dark greens */
			.timeflow-theme-dark .tf-card-history {
				background: linear-gradient(135deg, #2d4528, #2d5035) !important;
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-card-history h3 {
				color: #e0e0e0 !important;
			}

			.tf-stats-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
				gap: 15px;
				margin-top: 15px;
			}

			/* When stats card is in wide layout (beside calendar), force 2 columns */
			@container dashboard (min-width: 750px) {
				.tf-card-stats .tf-stats-grid {
					grid-template-columns: repeat(2, 1fr);
				}
			}

			/* Future planned days list - only shown in wide layout */
			.tf-future-days-list {
				display: none;
			}

			@container dashboard (min-width: 750px) {
				.tf-future-days-list {
					display: block;
					margin-top: 20px;
					padding-top: 15px;
					border-top: 1px solid rgba(0, 0, 0, 0.1);
				}

				.timeflow-theme-dark .tf-future-days-list {
					border-top-color: rgba(255, 255, 255, 0.1);
				}

				.tf-future-days-list h4 {
					margin: 0 0 10px 0;
					font-size: 14px;
					font-weight: 600;
					opacity: 0.8;
				}

				.tf-future-day-item {
					display: flex;
					justify-content: space-between;
					align-items: center;
					padding: 6px 0;
					font-size: 13px;
					border-bottom: 1px solid rgba(0, 0, 0, 0.05);
				}

				.timeflow-theme-dark .tf-future-day-item {
					border-bottom-color: rgba(255, 255, 255, 0.05);
				}

				.tf-future-day-item:last-child {
					border-bottom: none;
				}

				.tf-future-day-date {
					font-weight: 500;
				}

				.tf-future-day-type {
					padding: 2px 8px;
					border-radius: 4px;
					font-size: 12px;
					color: white;
				}
			}

			/* Light theme - Stat items match timeflow.js */
			.tf-stat-item {
				padding: 15px;
				background: rgba(155, 155, 155, 0.4);
				border-radius: 8px;
				color: #1a1a1a;
			}

			/* Dark theme - Stat items use semi-transparent white for consistency */
			.timeflow-theme-dark .tf-stat-item {
				background: rgba(255, 255, 255, 0.1);
				color: #e0e0e0;
			}

			.tf-stat-label {
				font-size: 12px;
				margin-bottom: 5px;
			}

			/* Light theme - stat labels should be dark but slightly muted */
			.tf-card-stats .tf-stat-label {
				color: rgba(26, 26, 26, 0.7);
			}

			/* Dark theme - stat labels should be light but slightly muted */
			.timeflow-theme-dark .tf-card-stats .tf-stat-label {
				color: rgba(224, 224, 224, 0.7);
			}

			.tf-stat-value {
				font-size: 20px;
				font-weight: bold;
			}

			/* Light theme - stat values should be dark */
			.tf-card-stats .tf-stat-value {
				color: #1a1a1a;
			}

			/* Dark theme - stat values should be light */
			.timeflow-theme-dark .tf-card-stats .tf-stat-value {
				color: #e0e0e0;
			}

			/* Timeframe label styling */
			.tf-timeframe-label {
				color: #1a1a1a;
			}

			.timeflow-theme-dark .tf-timeframe-label {
				color: #e0e0e0;
			}

			.timeflow-theme-system .tf-timeframe-label {
				color: var(--text-normal);
			}

			.tf-tabs {
				display: flex;
				gap: 8px;
				margin-bottom: 15px;
				border-bottom: 2px solid var(--background-modifier-border);
			}

			.tf-tab {
				padding: 6px 12px;
				cursor: pointer;
				border: none;
				background: rgba(0, 0, 0, 0.1);
				color: #1a1a1a !important;
				font-size: 0.9em;
				border-radius: 6px;
				transition: all 0.2s;
				font-weight: 500;
			}

			.tf-tab.active {
				background: rgba(0, 0, 0, 0.2);
				color: #1a1a1a !important;
				font-weight: bold;
			}

			.tf-tab:hover {
				background: rgba(0, 0, 0, 0.15);
				color: #1a1a1a !important;
			}

			.timeflow-theme-dark .tf-tab {
				background: rgba(255, 255, 255, 0.1);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-tab.active {
				background: rgba(255, 255, 255, 0.2);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-dark .tf-tab:hover {
				background: rgba(255, 255, 255, 0.15);
				color: #e0e0e0 !important;
			}

			.timeflow-theme-system .tf-tab {
				background: var(--background-modifier-border);
				color: var(--text-normal) !important;
			}

			.timeflow-theme-system .tf-tab.active {
				background: var(--interactive-accent);
				color: var(--text-on-accent) !important;
			}

			.timeflow-theme-system .tf-tab:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal) !important;
			}

			.tf-button {
				padding: clamp(3px, 1.5cqw, 8px) clamp(6px, 3cqw, 16px);
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--interactive-normal);
				color: var(--text-normal);
				cursor: pointer;
				font-size: clamp(10px, 3cqw, 14px);
				transition: all 0.2s;
				white-space: nowrap;
				min-width: 0;
				flex-shrink: 1;
			}

			.tf-button:hover {
				background: var(--interactive-hover);
			}

			/* Make buttons smaller on mobile */
			@media (max-width: 500px) {
				.tf-button {
					padding: 4px 8px;
					font-size: 11px;
					min-width: unset;
				}
			}

			.tf-heatmap {
				display: grid;
				gap: 2px;
				margin-top: 15px;
			}

			.tf-heatmap-cell {
				width: 100%;
				aspect-ratio: 1;
				border-radius: 4px;
				cursor: pointer;
				transition: transform 0.2s;
			}

			.tf-heatmap-cell:hover {
				transform: scale(1.2);
			}

			/* Make heatmap cells larger on mobile */
			@media (max-width: 600px) {
				.tf-heatmap {
					grid-template-columns: repeat(20, 1fr) !important;
				}
			}

			/* Context menu - uses same styling as submenu for consistency */
			/* Context menu - uses Obsidian native styling for all themes */
			.tf-context-menu {
				position: fixed;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				z-index: 1000;
				min-width: 200px;
				max-width: calc(100vw - 20px);
				display: flex;
				gap: 0;
				box-sizing: border-box;
			}

			.tf-context-menu-main {
				flex: 0 0 auto;
				min-width: 200px;
				box-sizing: border-box;
			}

			.tf-context-menu-info {
				flex: 0 0 auto;
				width: 250px;
				padding: 12px;
				border-left: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				font-size: 0.85em;
				line-height: 1.4;
				box-sizing: border-box;
			}

			/* On mobile, stack menu vertically and make it full width */
			@media (max-width: 500px) {
				.tf-context-menu {
					flex-direction: column;
					width: calc(100vw - 20px);
					max-height: calc(100vh - 40px);
					overflow-y: auto;
				}

				.tf-context-menu-main {
					width: 100%;
				}

				.tf-context-menu-info {
					width: 100%;
					border-left: none;
					border-top: 1px solid var(--background-modifier-border);
				}
			}

			.timeflow-theme-dark .tf-context-menu-info {
				background: rgba(0, 0, 0, 0.2);
			}

			.tf-context-menu-info h4 {
				margin: 0 0 8px 0;
				font-size: 0.95em;
				color: var(--text-normal);
			}

			.tf-context-menu-info p {
				margin: 4px 0;
				color: var(--text-muted);
			}

			.tf-context-menu-info strong {
				color: var(--text-normal);
			}

			/* Compliance info panel */
			.tf-compliance-info-panel {
				position: fixed;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 12px 16px;
				z-index: 1000;
				min-width: 220px;
				max-width: 300px;
			}

			.tf-compliance-info-panel h4 {
				margin: 0 0 10px 0;
				font-size: 0.95em;
				color: var(--text-normal);
			}

			.tf-compliance-info-panel p {
				margin: 6px 0;
				color: var(--text-muted);
				font-size: 0.9em;
			}

			.tf-compliance-info-panel strong {
				color: var(--text-normal);
			}

			.timeflow-theme-dark .tf-compliance-info-panel {
				background: var(--background-secondary);
			}

			.tf-menu-item {
				padding: 8px 16px;
				cursor: pointer;
				transition: background 0.2s;
				display: flex;
				align-items: center;
				gap: 10px;
				color: #1a1a1a;
			}

			.timeflow-theme-dark .tf-menu-item {
				color: #e0e0e0;
			}

			.timeflow-theme-system .tf-menu-item {
				color: var(--text-normal);
			}

			.tf-menu-item:hover {
				background: rgba(76, 175, 80, 0.2);
			}

			.timeflow-theme-system .tf-menu-item:hover {
				background: var(--background-modifier-hover);
			}

			.tf-menu-separator {
				height: 1px;
				background: rgba(0, 0, 0, 0.2);
				margin: 4px 0;
			}

			.timeflow-theme-dark .tf-menu-separator {
				background: rgba(255, 255, 255, 0.2);
			}

			.timeflow-theme-system .tf-menu-separator {
				background: var(--background-modifier-border);
			}

			/* Submenu styles */
			.tf-menu-item-with-submenu {
				position: relative;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.tf-submenu {
				display: none;
				position: absolute;
				left: 100%;
				top: 0;
				background: linear-gradient(135deg, #f0f4c3, #e1f5fe);
				border: 2px solid #4caf50;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0,0,0,0.3);
				padding: 4px;
				min-width: 180px;
				z-index: 1001;
			}

			.timeflow-theme-dark .tf-submenu {
				background: linear-gradient(135deg, #2d3a2d, #2d3d45);
				border: 2px solid #4caf50;
			}

			.timeflow-theme-system .tf-submenu {
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
			}

			.tf-menu-item-with-submenu:hover .tf-submenu {
				display: block;
			}

			.tf-submenu-arrow {
				font-size: 0.8em;
				opacity: 0.7;
			}

			.tf-status-bar {
				margin-top: 20px;
				padding: 15px;
				background: var(--background-secondary-alt);
				border-radius: 6px;
				border-left: 4px solid var(--interactive-accent);
			}

			.tf-collapsible {
				cursor: pointer;
				user-select: none;
			}

			.tf-collapsible-content {
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.3s ease;
			}

			.tf-collapsible-content.open {
				max-height: none;
				overflow: visible;
			}

			@media (max-width: 768px) {
				.tf-stats-grid {
					grid-template-columns: 1fr;
				}

				.tf-month-grid {
					gap: 4px;
				}
			}
		`;
    document.head.appendChild(style);
  }
  buildBadgeSection() {
    const section = document.createElement("div");
    section.className = "tf-badge-section";
    if (!this.settings.enableGoalTracking) {
      section.style.display = "none";
      return section;
    }
    const badge = document.createElement("div");
    badge.className = "tf-badge";
    this.elements.badge = badge;
    const clock = document.createElement("div");
    clock.className = "tf-clock";
    this.elements.clock = clock;
    const complianceBadge = document.createElement("div");
    complianceBadge.className = "tf-compliance-badge";
    this.elements.complianceBadge = complianceBadge;
    const timerBadge = document.createElement("button");
    timerBadge.className = "tf-timer-badge";
    this.elements.timerBadge = timerBadge;
    section.appendChild(badge);
    section.appendChild(clock);
    section.appendChild(complianceBadge);
    section.appendChild(timerBadge);
    this.updateBadge();
    this.updateComplianceBadge();
    this.updateTimerBadge();
    this.updateClock();
    return section;
  }
  updateTimerBadge() {
    if (!this.elements.timerBadge)
      return;
    const activeTimers = this.timerManager.getActiveTimers();
    if (activeTimers.length === 0) {
      this.elements.timerBadge.innerHTML = "";
      this.elements.timerBadge.style.background = "transparent";
      this.elements.timerBadge.style.display = "inline-flex";
      this.elements.timerBadge.style.alignItems = "stretch";
      this.elements.timerBadge.style.gap = "0";
      this.elements.timerBadge.style.padding = "0";
      this.elements.timerBadge.style.position = "relative";
      this.elements.timerBadge.onclick = null;
      const startBtn = document.createElement("div");
      startBtn.textContent = "Start";
      startBtn.style.background = "#4caf50";
      startBtn.style.color = "white";
      startBtn.style.padding = "8px 12px";
      startBtn.style.cursor = "pointer";
      startBtn.style.borderRadius = "12px 0 0 12px";
      startBtn.style.display = "flex";
      startBtn.style.alignItems = "center";
      startBtn.style.justifyContent = "center";
      startBtn.style.transition = "filter 0.2s";
      startBtn.onmouseover = () => {
        startBtn.style.filter = "brightness(1.1)";
      };
      startBtn.onmouseout = () => {
        startBtn.style.filter = "";
      };
      startBtn.onclick = async (e) => {
        e.stopPropagation();
        await this.timerManager.startTimer("jobb");
        this.updateTimerBadge();
      };
      const arrowBtn = document.createElement("div");
      arrowBtn.textContent = "\u25BC";
      arrowBtn.style.background = "#388e3c";
      arrowBtn.style.color = "white";
      arrowBtn.style.padding = "8px 8px";
      arrowBtn.style.cursor = "pointer";
      arrowBtn.style.borderRadius = "0 12px 12px 0";
      arrowBtn.style.fontSize = "0.8em";
      arrowBtn.style.display = "flex";
      arrowBtn.style.alignItems = "center";
      arrowBtn.style.borderLeft = "1px solid rgba(255,255,255,0.3)";
      arrowBtn.style.transition = "filter 0.2s";
      arrowBtn.onmouseover = () => {
        arrowBtn.style.filter = "brightness(1.1)";
      };
      arrowBtn.onmouseout = () => {
        arrowBtn.style.filter = "";
      };
      arrowBtn.onclick = (e) => {
        e.stopPropagation();
        this.showTimerTypeMenu(arrowBtn);
      };
      this.elements.timerBadge.appendChild(startBtn);
      this.elements.timerBadge.appendChild(arrowBtn);
    } else {
      this.elements.timerBadge.innerHTML = "";
      this.elements.timerBadge.textContent = "Stopp";
      this.elements.timerBadge.style.background = "#f44336";
      this.elements.timerBadge.style.color = "white";
      this.elements.timerBadge.style.display = "inline-flex";
      this.elements.timerBadge.style.alignItems = "center";
      this.elements.timerBadge.style.justifyContent = "center";
      this.elements.timerBadge.style.padding = "";
      this.elements.timerBadge.onclick = async () => {
        for (const timer of activeTimers) {
          await this.timerManager.stopTimer(timer);
        }
        this.updateTimerBadge();
      };
    }
  }
  showTimerTypeMenu(button) {
    var _a, _b;
    const existingMenu = document.querySelector(".tf-timer-type-menu");
    if (existingMenu) {
      existingMenu.remove();
      return;
    }
    const menu = document.createElement("div");
    menu.className = "tf-timer-type-menu";
    menu.style.position = "fixed";
    menu.style.background = "var(--background-primary)";
    menu.style.border = "1px solid var(--background-modifier-border)";
    menu.style.borderRadius = "8px";
    menu.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
    menu.style.zIndex = "1000";
    menu.style.minWidth = "150px";
    menu.style.overflow = "hidden";
    const timerTypes = [
      { name: "jobb", icon: "\u{1F4BC}", label: "Jobb" },
      { name: "kurs", icon: "\u{1F4DA}", label: ((_a = this.settings.specialDayBehaviors.find((b) => b.id === "kurs")) == null ? void 0 : _a.label) || "Kurs" },
      { name: "studie", icon: "\u{1F393}", label: ((_b = this.settings.specialDayBehaviors.find((b) => b.id === "studie")) == null ? void 0 : _b.label) || "Studie" }
    ];
    timerTypes.forEach((type) => {
      const item = document.createElement("div");
      item.style.padding = "10px 15px";
      item.style.cursor = "pointer";
      item.style.display = "flex";
      item.style.alignItems = "center";
      item.style.gap = "8px";
      item.style.transition = "background 0.2s";
      item.innerHTML = `<span>${type.icon}</span><span>${type.label}</span>`;
      item.onmouseover = () => {
        item.style.background = "var(--background-modifier-hover)";
      };
      item.onmouseout = () => {
        item.style.background = "";
      };
      item.onclick = async () => {
        await this.timerManager.startTimer(type.name);
        this.updateTimerBadge();
        menu.remove();
      };
      menu.appendChild(item);
    });
    document.body.appendChild(menu);
    const rect = button.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const margin = 10;
    let top = rect.bottom + 5;
    let left = rect.left;
    if (top + menuRect.height + margin > viewportHeight) {
      top = rect.top - menuRect.height - 5;
    }
    if (left + menuRect.width + margin > viewportWidth) {
      left = viewportWidth - menuRect.width - margin;
    }
    if (left < margin) {
      left = margin;
    }
    if (top < margin) {
      top = margin;
    }
    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 0);
  }
  buildSummaryCards() {
    const container = document.createElement("div");
    container.className = "tf-summary-cards";
    container.appendChild(this.createDayCard());
    container.appendChild(this.createWeekCard());
    container.appendChild(this.createMonthCard());
    return container;
  }
  createDayCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-day";
    this.elements.dayCard = card;
    this.updateDayCard();
    return card;
  }
  createWeekCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-week";
    this.elements.weekCard = card;
    this.updateWeekCard();
    return card;
  }
  createMonthCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-month";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "15px";
    header.style.flexWrap = "wrap";
    header.style.gap = "8px";
    const title = document.createElement("h3");
    title.textContent = "Kalender";
    title.style.margin = "0";
    title.style.flexShrink = "1";
    title.style.minWidth = "0";
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.flexShrink = "0";
    const prevBtn = document.createElement("button");
    prevBtn.textContent = "\u25C4";
    prevBtn.className = "tf-button";
    prevBtn.onclick = () => {
      this.currentMonthOffset--;
      this.updateMonthCard();
    };
    const todayBtn = document.createElement("button");
    todayBtn.textContent = "I dag";
    todayBtn.className = "tf-button";
    todayBtn.onclick = () => {
      this.currentMonthOffset = 0;
      this.updateMonthCard();
    };
    const nextBtn = document.createElement("button");
    nextBtn.textContent = "\u25BA";
    nextBtn.className = "tf-button";
    nextBtn.onclick = () => {
      this.currentMonthOffset++;
      this.updateMonthCard();
    };
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const gridContainer = document.createElement("div");
    this.elements.monthCard = gridContainer;
    card.appendChild(gridContainer);
    const futureDaysContainer = document.createElement("div");
    futureDaysContainer.className = "tf-future-days-list";
    card.appendChild(futureDaysContainer);
    this.updateMonthCard();
    return card;
  }
  createStatsCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-stats";
    const contentWrapper = document.createElement("div");
    contentWrapper.className = "tf-collapsible-content open";
    const headerRow = document.createElement("div");
    headerRow.className = "tf-collapsible";
    headerRow.style.display = "flex";
    headerRow.style.justifyContent = "space-between";
    headerRow.style.alignItems = "center";
    headerRow.style.flexWrap = "wrap";
    headerRow.style.gap = "10px";
    const header = document.createElement("h3");
    header.textContent = "Statistikk";
    header.style.margin = "0";
    headerRow.appendChild(header);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const timeframes = ["total", "year", "month"];
    const labels = { total: "Totalt", year: "\xC5r", month: "M\xE5ned" };
    timeframes.forEach((tf) => {
      const tab = document.createElement("button");
      tab.className = `tf-tab ${tf === this.statsTimeframe ? "active" : ""}`;
      tab.textContent = labels[tf];
      tab.onclick = () => {
        this.statsTimeframe = tf;
        tabs.querySelectorAll(".tf-tab").forEach((t) => t.classList.remove("active"));
        tab.classList.add("active");
        if (!contentWrapper.classList.contains("open")) {
          contentWrapper.classList.add("open");
        }
        this.updateStatsCard();
      };
      tabs.appendChild(tab);
    });
    headerRow.appendChild(tabs);
    card.appendChild(headerRow);
    const timeframeSelectorContainer = document.createElement("div");
    timeframeSelectorContainer.className = "tf-timeframe-selector";
    timeframeSelectorContainer.style.marginBottom = "15px";
    timeframeSelectorContainer.style.display = "flex";
    timeframeSelectorContainer.style.gap = "10px";
    timeframeSelectorContainer.style.alignItems = "center";
    timeframeSelectorContainer.style.flexWrap = "wrap";
    contentWrapper.appendChild(timeframeSelectorContainer);
    const statsContainer = document.createElement("div");
    statsContainer.className = "tf-stats-grid";
    this.elements.statsCard = statsContainer;
    contentWrapper.appendChild(statsContainer);
    card.appendChild(contentWrapper);
    header.onclick = () => {
      contentWrapper.classList.toggle("open");
    };
    header.style.cursor = "pointer";
    this.updateStatsCard();
    return card;
  }
  buildInfoCard() {
    var _a, _b, _c;
    const card = document.createElement("div");
    card.className = "tf-card tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    header.innerHTML = "<h3 style='margin:0'>Informasjon</h3>";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const halfDayHours = this.settings.halfDayMode === "percentage" ? this.settings.baseWorkday / 2 : this.settings.halfDayHours;
    const halfDayReduction = this.settings.baseWorkday - halfDayHours;
    const specialDayInfo = [
      { key: "avspasering", emoji: "\u{1F6CC}", desc: "Trekkes fra fleksitid" },
      { key: "egenmelding", emoji: "\u{1F912}", desc: "P\xE5virker ikke fleksitid" },
      { key: "ferie", emoji: "\u{1F3D6}\uFE0F", desc: "P\xE5virker ikke fleksitid" },
      { key: "velferdspermisjon", emoji: "\u{1F3E5}", desc: "P\xE5virker ikke fleksitid" },
      { key: "studie", emoji: "\u{1F4D6}", desc: `Teller som fleksitid ved mer enn ${this.settings.baseWorkday}t` },
      { key: "kurs", emoji: "\u{1F4DA}", desc: `Teller som fleksitid ved mer enn ${this.settings.baseWorkday}t` },
      { key: "helligdag", emoji: "\u{1F389}", desc: "Offentlig fridag - p\xE5virker ikke fleksitid" },
      { key: "halfday", emoji: "\u23F0", desc: `Halv arbeidsdag (${halfDayHours}t) - reduserer ukem\xE5let med ${halfDayReduction}t` },
      { key: "Ingen registrering", emoji: "\u26AA", desc: "Ingen data for den dagen" }
    ];
    content.innerHTML = `
			<div style="margin-top: 15px;">
				<h4>Spesielle dagtyper</h4>
				<ul style="list-style: none; padding-left: 0; margin-bottom: 20px;">
					${specialDayInfo.map((item) => {
      var _a2, _b2;
      const color = getSpecialDayColors(this.settings)[item.key] || "transparent";
      const label = ((_a2 = this.settings.specialDayBehaviors.find((b) => b.id === item.key)) == null ? void 0 : _a2.label) || ((_b2 = this.settings.specialDayLabels) == null ? void 0 : _b2[item.key]) || item.key;
      return `<li style="display: flex; align-items: center; margin-bottom: 8px; font-size: 0.95em;">
							<div style="width: 16px; height: 16px; background: ${color}; border-radius: 3px; border: 1px solid var(--background-modifier-border); margin-right: 8px; flex-shrink: 0;"></div>
							<span>${item.emoji} <strong>${label}</strong>: ${item.desc}</span>
						</li>`;
    }).join("")}
				</ul>

				<div style="margin-top: 20px; padding: 12px; background: var(--background-primary); border-radius: 8px;">
					<h4 style="margin-top: 0;">Kalenderkontekstmeny</h4>
					<p style="margin: 8px 0; font-size: 0.9em;">
						Trykk p\xE5 en dag i kalenderen for \xE5 f\xE5 opp en meny med flere alternativer:
					</p>
					<ul style="margin: 8px 0 0 20px; font-size: 0.9em;">
						<li>Opprett daglig notat for valgt dag</li>
						<li>Opprett m\xF8tenotat, prosjektnotat eller refleksjonsnotat</li>
						<li>Rediger fleksitid for dagen manuelt</li>
						<li>Registrer spesielle dagtyper (ferie, kurs, avspasering, etc.)</li>
					</ul>
				</div>

				<div style="margin-top: 20px; padding: 12px; background: var(--background-primary); border-radius: 8px;">
					<h4 style="margin-top: 0;">Fleksitidsaldo - advarselsoner</h4>
					<div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.9em;">
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: ${((_a = this.settings.customColors) == null ? void 0 : _a.balanceOk) || "#4caf50"}; flex-shrink: 0;"></span>
							<span><strong>Gr\xF8nn sone:</strong> ${this.settings.balanceThresholds.warningLow}t til +${this.settings.balanceThresholds.warningHigh}t (trygg)</span>
						</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: ${((_b = this.settings.customColors) == null ? void 0 : _b.balanceWarning) || "#ff9800"}; flex-shrink: 0;"></span>
							<span><strong>Gul sone:</strong> ${this.settings.balanceThresholds.criticalLow}t til ${this.settings.balanceThresholds.warningLow - 1}t ELLER +${this.settings.balanceThresholds.warningHigh}t til +${this.settings.balanceThresholds.criticalHigh}t (forsiktig)</span>
						</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<span style="display: inline-block; width: 20px; height: 20px; border-radius: 4px; background: ${((_c = this.settings.customColors) == null ? void 0 : _c.balanceCritical) || "#f44336"}; flex-shrink: 0;"></span>
							<span><strong>R\xF8d sone:</strong> Under ${this.settings.balanceThresholds.criticalLow}t ELLER over +${this.settings.balanceThresholds.criticalHigh}t (kritisk)</span>
						</div>
					</div>
					<div style="margin-top: 10px; font-size: 0.85em; opacity: 0.8;">
						<em>Grenser: ${this.settings.balanceThresholds.criticalLow - 5}t til +${this.settings.balanceThresholds.criticalHigh + 5}t</em>
					</div>
				</div>

				<div style="margin-top: 20px;">
					<h4>Arbeidsdager - fargegradient</h4>
					<p style="margin: 8px 0; font-size: 0.9em;">
						Arbeidsdager vises med farge basert p\xE5 hvor mye du jobbet i forhold til dagens m\xE5l (${this.settings.baseWorkday}t):
					</p>
					<div style="margin-top: 10px;">
						<div style="height: 16px; border-radius: 8px; background: linear-gradient(to right, rgb(144,238,144), rgb(89,188,89), rgb(34,139,34)); margin: 4px 0; border: 1px solid var(--background-modifier-border);"></div>
						<div style="display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-muted); margin-bottom: 12px;">
							<span>0t over m\xE5l</span><span>+1,5t</span><span>+3t eller mer</span>
						</div>
						<div style="height: 16px; border-radius: 8px; background: linear-gradient(to right, rgb(100,150,255), rgb(150,200,255), rgb(200,220,255)); margin: 4px 0; border: 1px solid var(--background-modifier-border);"></div>
						<div style="display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-muted);">
							<span>-3t eller mindre</span><span>-1,5t</span><span>0t fra m\xE5l</span>
						</div>
					</div>
				</div>
			</div>
		`;
    header.onclick = () => {
      content.classList.toggle("open");
    };
    card.appendChild(header);
    card.appendChild(content);
    return card;
  }
  buildHistoryCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-history tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.flexWrap = "wrap";
    header.style.gap = "10px";
    const title = document.createElement("h3");
    title.textContent = "Historikk";
    title.style.margin = "0";
    header.appendChild(title);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs";
    tabs.style.marginBottom = "0";
    tabs.style.borderBottom = "none";
    const views = [
      { id: "list", label: "Liste" },
      { id: "heatmap", label: "Heatmap" }
    ];
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const detailsElement = document.createElement("div");
    detailsElement.style.maxHeight = "500px";
    detailsElement.style.overflow = "auto";
    views.forEach((view) => {
      const tab = document.createElement("button");
      tab.textContent = view.label;
      tab.className = `tf-tab ${this.historyView === view.id ? "active" : ""}`;
      tab.onclick = () => {
        this.historyView = view.id;
        tabs.querySelectorAll(".tf-tab").forEach((t) => t.classList.remove("active"));
        tab.classList.add("active");
        if (!content.classList.contains("open")) {
          content.classList.add("open");
        }
        this.refreshHistoryView(detailsElement);
      };
      tabs.appendChild(tab);
    });
    header.appendChild(tabs);
    content.appendChild(detailsElement);
    title.onclick = () => {
      content.classList.toggle("open");
    };
    title.style.cursor = "pointer";
    card.appendChild(header);
    card.appendChild(content);
    this.refreshHistoryView(detailsElement);
    return card;
  }
  buildStatusBar() {
    var _a, _b, _c, _d, _e, _f, _g;
    const bar = document.createElement("div");
    bar.className = "tf-status-bar";
    const status = this.systemStatus;
    const hasErrors = (_a = status.validation) == null ? void 0 : _a.hasErrors;
    const hasWarnings = (_b = status.validation) == null ? void 0 : _b.hasWarnings;
    const statusIcon = hasErrors ? "\u274C" : hasWarnings ? "\u26A0\uFE0F" : "\u2705";
    const hasIssues = hasErrors || hasWarnings;
    let issuesHTML = "";
    if (hasIssues && ((_c = status.validation) == null ? void 0 : _c.issues)) {
      const errors = status.validation.issues.errors || [];
      const warnings = status.validation.issues.warnings || [];
      if (errors.length > 0) {
        issuesHTML += `<div style="margin-top: 8px;"><strong style="color: #f44336;">Feil (${errors.length}):</strong></div>`;
        errors.slice(0, 5).forEach((err) => {
          issuesHTML += `<div style="font-size: 12px; margin-left: 12px; color: #f44336;">
						\u2022 ${err.type}: ${err.description}${err.date ? ` (${err.date})` : ""}
					</div>`;
        });
        if (errors.length > 5) {
          issuesHTML += `<div style="font-size: 11px; margin-left: 12px; color: var(--text-muted);">...og ${errors.length - 5} flere feil</div>`;
        }
      }
      if (warnings.length > 0) {
        issuesHTML += `<div style="margin-top: 8px;"><strong style="color: #ff9800;">Advarsler (${warnings.length}):</strong></div>`;
        warnings.slice(0, 5).forEach((warn) => {
          issuesHTML += `<div style="font-size: 12px; margin-left: 12px; color: #ff9800;">
						\u2022 ${warn.type}: ${warn.description}${warn.date ? ` (${warn.date})` : ""}
					</div>`;
        });
        if (warnings.length > 5) {
          issuesHTML += `<div style="font-size: 11px; margin-left: 12px; color: var(--text-muted);">...og ${warnings.length - 5} flere advarsler</div>`;
        }
      }
    }
    const header = document.createElement("div");
    header.style.cssText = "display: flex; align-items: center; gap: 10px; cursor: pointer;";
    header.innerHTML = `
			<span>${statusIcon}</span>
			<div style="flex: 1;">
				<div><strong>System Status</strong> ${hasIssues ? '<span style="font-size: 11px; opacity: 0.7;">(klikk for detaljer)</span>' : ""}</div>
				<div style="font-size: 12px; color: var(--text-muted);">
					${((_d = status.holiday) == null ? void 0 : _d.message) || "Holiday data not loaded"} \u2022
					${status.activeTimers || 0} active timer(s) \u2022
					${((_g = (_f = (_e = status.validation) == null ? void 0 : _e.issues) == null ? void 0 : _f.stats) == null ? void 0 : _g.totalEntries) || 0} entries checked
				</div>
			</div>
			${hasIssues ? '<span class="tf-status-toggle" style="font-size: 10px; transition: transform 0.2s;">\u25B6</span>' : ""}
		`;
    bar.appendChild(header);
    if (hasIssues) {
      const details = document.createElement("div");
      details.className = "tf-status-details";
      details.style.cssText = "max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; opacity: 0;";
      details.innerHTML = `<div style="padding-top: 10px; border-top: 1px solid var(--background-modifier-border); margin-top: 10px;">${issuesHTML}</div>`;
      bar.appendChild(details);
      let isOpen = false;
      header.onclick = () => {
        isOpen = !isOpen;
        const toggle = header.querySelector(".tf-status-toggle");
        if (toggle) {
          toggle.style.transform = isOpen ? "rotate(90deg)" : "rotate(0deg)";
        }
        if (isOpen) {
          details.style.maxHeight = details.scrollHeight + "px";
          details.style.opacity = "1";
        } else {
          details.style.maxHeight = "0";
          details.style.opacity = "0";
        }
      };
    }
    return bar;
  }
  updateClock() {
    if (!this.elements.clock)
      return;
    const now = /* @__PURE__ */ new Date();
    this.elements.clock.textContent = now.toLocaleTimeString("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  updateBadge() {
    if (!this.elements.badge)
      return;
    const balance = this.data.getCurrentBalance();
    const formatted = Utils.formatHoursToHM(Math.abs(balance), this.settings.hourUnit);
    const sign = balance >= 0 ? "+" : "-";
    const color = this.getBalanceColor(balance);
    this.elements.badge.style.background = color;
    this.elements.badge.style.color = "white";
    this.elements.badge.textContent = `Fleksitidsaldo: ${sign}${formatted}`;
  }
  /**
   * Get compliance status: 'ok' | 'approaching' | 'exceeded'
   * Based on daily and weekly hours compared to limits
   */
  getComplianceStatus() {
    var _a, _b, _c, _d, _e;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      return { status: "ok", dailyStatus: "ok", weeklyStatus: "ok", tooltip: "" };
    }
    const today = /* @__PURE__ */ new Date();
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const weeklyLimit = (_e = (_d = this.settings.complianceSettings) == null ? void 0 : _d.weeklyHoursLimit) != null ? _e : 40;
    const dailyApproaching = this.settings.baseWorkday * this.settings.workPercent;
    const weeklyApproaching = this.settings.baseWorkweek * this.settings.workPercent;
    let dailyStatus = "ok";
    let weeklyStatus = "ok";
    if (todayHours >= dailyLimit) {
      dailyStatus = "exceeded";
    } else if (todayHours >= dailyApproaching) {
      dailyStatus = "approaching";
    }
    if (weekHours >= weeklyLimit) {
      weeklyStatus = "exceeded";
    } else if (weekHours >= weeklyApproaching) {
      weeklyStatus = "approaching";
    }
    let status = "ok";
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded") {
      status = "exceeded";
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      status = "approaching";
    }
    const tooltipParts = [];
    if (dailyStatus === "exceeded") {
      tooltipParts.push(`Dag: ${todayHours.toFixed(1)}t (maks ${dailyLimit}t)`);
    } else if (dailyStatus === "approaching") {
      tooltipParts.push(`Dag: ${todayHours.toFixed(1)}t (n\xE6rmer seg ${dailyLimit}t)`);
    }
    if (weeklyStatus === "exceeded") {
      tooltipParts.push(`Uke: ${weekHours.toFixed(1)}t (maks ${weeklyLimit}t)`);
    } else if (weeklyStatus === "approaching") {
      tooltipParts.push(`Uke: ${weekHours.toFixed(1)}t (n\xE6rmer seg ${weeklyLimit}t)`);
    }
    if (tooltipParts.length === 0 && status === "ok") {
      tooltipParts.push(`Dag: ${todayHours.toFixed(1)}t, Uke: ${weekHours.toFixed(1)}t - Innenfor grensene`);
    }
    return { status, dailyStatus, weeklyStatus, tooltip: tooltipParts.join("\n") };
  }
  /**
   * Update compliance status badge
   */
  updateComplianceBadge() {
    var _a;
    if (!this.elements.complianceBadge)
      return;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      this.elements.complianceBadge.style.display = "none";
      return;
    }
    const { status } = this.getComplianceStatus();
    this.elements.complianceBadge.style.display = "";
    this.elements.complianceBadge.style.cursor = "pointer";
    if (status === "ok") {
      this.elements.complianceBadge.style.background = "rgba(76, 175, 80, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(76, 175, 80, 0.4)";
      this.elements.complianceBadge.textContent = "\u{1F7E9} OK";
    } else if (status === "approaching") {
      this.elements.complianceBadge.style.background = "rgba(255, 152, 0, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(255, 152, 0, 0.4)";
      this.elements.complianceBadge.textContent = "\u{1F7E8} N\xE6r";
    } else {
      this.elements.complianceBadge.style.background = "rgba(244, 67, 54, 0.2)";
      this.elements.complianceBadge.style.border = "1px solid rgba(244, 67, 54, 0.4)";
      this.elements.complianceBadge.textContent = "\u{1F7E5} Over";
    }
    this.elements.complianceBadge.onclick = (e) => {
      e.stopPropagation();
      this.showComplianceInfoPanel();
    };
  }
  /**
   * Show compliance info panel with detailed information
   */
  showComplianceInfoPanel() {
    var _a, _b, _c, _d, _e, _f;
    const existingPanel = document.querySelector(".tf-compliance-info-panel");
    if (existingPanel) {
      existingPanel.remove();
      return;
    }
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9;
    const weeklyLimit = (_d = (_c = this.settings.complianceSettings) == null ? void 0 : _c.weeklyHoursLimit) != null ? _d : 40;
    const minimumRest = (_f = (_e = this.settings.complianceSettings) == null ? void 0 : _e.minimumRestHours) != null ? _f : 11;
    const { dailyStatus, weeklyStatus } = this.getComplianceStatus();
    const restCheck = this.data.checkRestPeriodViolation(todayStr);
    const panel = document.createElement("div");
    panel.className = "tf-compliance-info-panel";
    const themeClass = `timeflow-theme-${this.settings.theme}`;
    panel.classList.add(themeClass);
    let html = "<h4>\u2696\uFE0F Arbeidstidsgrenser</h4>";
    const dailyIcon = dailyStatus === "ok" ? "\u{1F7E9}" : dailyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    html += `<p><strong>I dag:</strong> ${dailyIcon} ${todayHours.toFixed(1)}t / ${dailyLimit}t</p>`;
    const weeklyIcon = weeklyStatus === "ok" ? "\u{1F7E9}" : weeklyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    html += `<p><strong>Denne uken:</strong> ${weeklyIcon} ${weekHours.toFixed(1)}t / ${weeklyLimit}t</p>`;
    if (restCheck.violated && restCheck.restHours !== null) {
      html += `<p class="tf-rest-warning"><strong>Hviletid:</strong> \u{1F7E5} ${restCheck.restHours.toFixed(1)}t (minimum ${minimumRest}t)</p>`;
    } else if (restCheck.restHours !== null) {
      html += `<p><strong>Hviletid:</strong> \u{1F7E9} ${restCheck.restHours.toFixed(1)}t (minimum ${minimumRest}t)</p>`;
    }
    html += '<hr style="margin: 10px 0; border: none; border-top: 1px solid var(--background-modifier-border);">';
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded" || restCheck.violated) {
      html += '<p style="font-size: 12px; color: var(--text-muted);">En eller flere grenser er overskredet.</p>';
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      html += '<p style="font-size: 12px; color: var(--text-muted);">N\xE6rmer seg en eller flere grenser.</p>';
    } else {
      html += '<p style="font-size: 12px; color: var(--text-muted);">Alle grenser er OK.</p>';
    }
    panel.innerHTML = html;
    const badgeRect = this.elements.complianceBadge.getBoundingClientRect();
    panel.style.position = "fixed";
    panel.style.top = `${badgeRect.bottom + 8}px`;
    panel.style.right = `${window.innerWidth - badgeRect.right}px`;
    document.body.appendChild(panel);
    const closeHandler = (e) => {
      if (!panel.contains(e.target) && e.target !== this.elements.complianceBadge) {
        panel.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  /**
   * Generate compliance warning HTML for daily hours
   */
  getDailyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings))
      return "";
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const approachingThreshold = this.settings.baseWorkday * this.settings.workPercent;
    if (hours >= dailyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger daglig grense p\xE5 ${dailyLimit} timer">\u26A0\uFE0F >${dailyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg daglig grense p\xE5 ${dailyLimit} timer">\u23F0 ${dailyLimit}t grense</span>`;
    }
    return "";
  }
  /**
   * Generate compliance warning HTML for weekly hours
   */
  getWeeklyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings))
      return "";
    const weeklyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.weeklyHoursLimit) != null ? _c : 40;
    const approachingThreshold = this.settings.baseWorkweek * this.settings.workPercent;
    if (hours >= weeklyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger ukentlig grense p\xE5 ${weeklyLimit} timer">\u26A0\uFE0F >${weeklyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg ukentlig grense p\xE5 ${weeklyLimit} timer">\u23F0 ${weeklyLimit}t grense</span>`;
    }
    return "";
  }
  updateDayCard() {
    var _a, _b;
    if (!this.elements.dayCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    this.updateComplianceBadge();
    if (!this.settings.enableGoalTracking) {
      this.elements.dayCard.style.background = "linear-gradient(135deg, #607d8b, #78909c)";
      this.elements.dayCard.style.color = "white";
      this.elements.dayCard.innerHTML = `
				<h3 style="color: white;">I dag</h3>
				<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
					${Utils.formatHoursToHM(todayHours, this.settings.hourUnit)}
				</div>
				<div style="font-size: 14px; opacity: 0.9; margin-top: 10px;">
					Timer arbeidet
				</div>
			`;
      return;
    }
    const goal = this.data.getDailyGoal(todayKey);
    const isWeekendDay = Utils.isWeekend(today, this.settings);
    const context = this.data.getContextualData(today);
    const { avgDaily } = this.data.getAverages();
    const specials = [];
    const holidayInfo = this.data.getHolidayInfo(todayKey);
    if (holidayInfo) {
      specials.push(holidayInfo.type);
    }
    const message = MessageGenerator.getDailyMessage(
      todayHours,
      goal,
      specials,
      isWeekendDay,
      avgDaily,
      context,
      this.settings.consecutiveFlextimeWarningDays
    );
    const progress = goal > 0 ? Math.min(todayHours / goal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (todayHours <= goal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (todayHours <= goal + 1.75) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.dayCard.style.background = bgColor;
    this.elements.dayCard.style.color = textColor;
    const messageSection = this.settings.enableMotivationalMessages ? `
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		` : "";
    this.elements.dayCard.innerHTML = `
			<h3 style="color: ${textColor};">I dag</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(todayHours, this.settings.hourUnit)}
			</div>
			<div style="font-size: 14px; opacity: 0.9; margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(goal, this.settings.hourUnit)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})"></div>
			</div>
			${messageSection}
		`;
  }
  updateWeekCard() {
    var _a, _b;
    if (!this.elements.weekCard)
      return;
    const today = /* @__PURE__ */ new Date();
    const weekHours = this.data.getCurrentWeekHours(today);
    if (!this.settings.enableGoalTracking) {
      this.elements.weekCard.style.background = "linear-gradient(135deg, #607d8b, #78909c)";
      this.elements.weekCard.style.color = "white";
      this.elements.weekCard.innerHTML = `
				<h3 style="color: white;">Denne uken</h3>
				<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
					${Utils.formatHoursToHM(weekHours, this.settings.hourUnit)}
				</div>
				<div style="font-size: 14px; opacity: 0.9; margin-top: 10px;">
					Timer arbeidet
				</div>
			`;
      return;
    }
    const baseGoal = this.settings.baseWorkweek * this.settings.workPercent;
    const context = this.data.getContextualData(today);
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    let adjustedGoal = 0;
    let specials = [];
    let weekendWorkHours = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(firstDayOfWeek);
      d.setDate(firstDayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayGoal = this.data.getDailyGoal(dayKey);
      adjustedGoal += dayGoal;
      const holidayInfo = this.data.getHolidayInfo(dayKey);
      if (holidayInfo) {
        specials.push(holidayInfo.type);
      }
      if (Utils.isWeekend(d, this.settings)) {
        const dayEntries = this.data.daily[dayKey] || [];
        weekendWorkHours += dayEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
      }
    }
    const message = this.settings.enableWeeklyGoals ? MessageGenerator.getWeeklyMessage(
      weekHours,
      adjustedGoal,
      specials,
      today,
      context,
      weekendWorkHours
    ) : MessageGenerator.getWeeklyMessage(
      weekHours,
      0,
      // Pass 0 as goal to get non-goal-based messages
      specials,
      today,
      context,
      weekendWorkHours
    );
    const progress = adjustedGoal > 0 ? Math.min(weekHours / adjustedGoal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (!this.settings.enableWeeklyGoals) {
      bgColor = "linear-gradient(135deg, #607d8b, #78909c)";
      textColor = "white";
    } else if (weekHours <= adjustedGoal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (weekHours <= adjustedGoal + 3.5) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.weekCard.style.background = bgColor;
    this.elements.weekCard.style.color = textColor;
    const goalSection = this.settings.enableWeeklyGoals ? `
			<div style="font-size: 14px; opacity: 0.9; margin-bottom: 10px;">
				M\xE5l: ${Utils.formatHoursToHM(adjustedGoal, this.settings.hourUnit)}
			</div>
			<div class="tf-progress-bar">
				<div class="tf-progress-fill" style="width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})"></div>
			</div>
		` : "";
    const weekMessageSection = this.settings.enableMotivationalMessages ? `
			<div style="margin-top: 10px; font-size: 14px;">
				${message}
			</div>
		` : "";
    this.elements.weekCard.innerHTML = `
			<h3 style="color: ${textColor};">Denne uken</h3>
			<div style="font-size: 32px; font-weight: bold; margin: 10px 0;">
				${Utils.formatHoursToHM(weekHours, this.settings.hourUnit)}
			</div>
			${goalSection}
			${weekMessageSection}
		`;
  }
  updateStatsCard() {
    var _a, _b;
    if (!this.elements.statsCard)
      return;
    const stats = this.data.getStatistics(this.statsTimeframe, this.selectedYear, this.selectedMonth);
    const balance = this.data.getCurrentBalance();
    const { avgDaily, avgWeekly } = this.data.getAverages();
    const workloadPct = (avgWeekly / this.settings.baseWorkweek * 100).toFixed(0);
    const selectorContainer = (_a = this.elements.statsCard.parentElement) == null ? void 0 : _a.querySelector(".tf-timeframe-selector");
    if (selectorContainer) {
      selectorContainer.innerHTML = "";
      if (this.statsTimeframe === "year") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.style.padding = "4px 8px";
          yearSelect.style.fontSize = "1em";
          yearSelect.style.fontWeight = "bold";
          yearSelect.style.border = "1px solid var(--background-modifier-border)";
          yearSelect.style.borderRadius = "4px";
          yearSelect.style.background = "var(--background-primary)";
          yearSelect.style.color = "var(--text-normal)";
          yearSelect.style.cursor = "pointer";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
        }
      } else if (this.statsTimeframe === "month") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.style.padding = "4px 8px";
          yearSelect.style.fontSize = "1em";
          yearSelect.style.fontWeight = "bold";
          yearSelect.style.border = "1px solid var(--background-modifier-border)";
          yearSelect.style.borderRadius = "4px";
          yearSelect.style.background = "var(--background-primary)";
          yearSelect.style.color = "var(--text-normal)";
          yearSelect.style.cursor = "pointer";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            const months = this.data.getAvailableMonthsForYear(this.selectedYear);
            if (months.length > 0) {
              this.selectedMonth = months[months.length - 1];
            }
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
          const availableMonths = this.data.getAvailableMonthsForYear(this.selectedYear);
          if (availableMonths.length > 0) {
            const monthSelect = document.createElement("select");
            monthSelect.style.padding = "4px 8px";
            monthSelect.style.fontSize = "1em";
            monthSelect.style.fontWeight = "bold";
            monthSelect.style.border = "1px solid var(--background-modifier-border)";
            monthSelect.style.borderRadius = "4px";
            monthSelect.style.background = "var(--background-primary)";
            monthSelect.style.color = "var(--text-normal)";
            monthSelect.style.cursor = "pointer";
            const monthNames = [
              "Januar",
              "Februar",
              "Mars",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Desember"
            ];
            availableMonths.forEach((month) => {
              const option = document.createElement("option");
              option.value = month.toString();
              option.textContent = monthNames[month];
              option.selected = month === this.selectedMonth;
              monthSelect.appendChild(option);
            });
            monthSelect.onchange = () => {
              this.selectedMonth = parseInt(monthSelect.value);
              this.updateStatsCard();
            };
            selectorContainer.appendChild(monthSelect);
          }
        }
      } else {
        const label = document.createElement("div");
        label.style.fontSize = "1.1em";
        label.style.fontWeight = "bold";
        label.textContent = "Totalt";
        selectorContainer.appendChild(label);
      }
    }
    const context = this.data.getContextualData(this.today);
    let weekComparisonText = "";
    if (context.lastWeekHours > 0) {
      const currWeekHours = this.data.getCurrentWeekHours(this.today);
      const diff = currWeekHours - context.lastWeekHours;
      if (Math.abs(diff) > 2) {
        const arrow = diff > 0 ? "\u{1F4C8}" : "\u{1F4C9}";
        const sign2 = diff > 0 ? "+" : "";
        weekComparisonText = `<div style="font-size: 0.75em; margin-top: 4px;">vs forrige uke: ${sign2}${diff.toFixed(1)}t ${arrow}</div>`;
      }
    }
    const sign = balance >= 0 ? "+" : "";
    const timesaldoColor = this.getBalanceColor(balance);
    let ferieDisplay = `${stats.ferie.count} dager`;
    if (this.statsTimeframe === "year" && stats.ferie.max > 0) {
      const feriePercent = (stats.ferie.count / stats.ferie.max * 100).toFixed(0);
      ferieDisplay = `${stats.ferie.count}/${stats.ferie.max} dager (${feriePercent}%)`;
    }
    const egenmeldingStats = this.data.getSpecialDayStats("egenmelding", this.selectedYear);
    let egenmeldingDisplay = `${egenmeldingStats.count} dager`;
    let egenmeldingPeriodLabel = "";
    if (this.statsTimeframe === "year") {
      if (egenmeldingStats.max && egenmeldingStats.max > 0) {
        const egenmeldingPercent = (egenmeldingStats.count / egenmeldingStats.max * 100).toFixed(0);
        egenmeldingDisplay = `${egenmeldingStats.count}/${egenmeldingStats.max} dager (${egenmeldingPercent}%)`;
      }
      egenmeldingPeriodLabel = `(${egenmeldingStats.periodLabel})`;
    }
    this.elements.statsCard.innerHTML = `
			${this.settings.enableGoalTracking ? `<div class="tf-stat-item tf-stat-colored" style="background: ${timesaldoColor};">
				<div class="tf-stat-label">Fleksitidsaldo</div>
				<div class="tf-stat-value">${sign}${balance.toFixed(1)}t</div>
				<div style="font-size: 0.75em; margin-top: 4px;">Total saldo</div>
			</div>` : ""}
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u23F1\uFE0F Timer</div>
				<div class="tf-stat-value">${stats.totalHours.toFixed(1)}t</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4CA} Snitt/dag</div>
				<div class="tf-stat-value">${avgDaily.toFixed(1)}t</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4C5} Snitt/uke</div>
				<div class="tf-stat-value">${avgWeekly.toFixed(1)}t</div>
				${weekComparisonText}
			</div>
			${this.settings.enableGoalTracking && this.settings.enableWeeklyGoals ? `<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4AA} Arbeidsbruk</div>
				<div class="tf-stat-value">${workloadPct}%</div>
				<div style="font-size: 0.75em; margin-top: 4px;">av normaluke</div>
			</div>` : ""}
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4BC} Jobb</div>
				<div class="tf-stat-value">${stats.jobb.count} ${stats.jobb.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.jobb.hours.toFixed(1)}t</div>
			</div>
			${stats.weekendDays > 0 ? `<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F319} Helgedager jobbet</div>
				<div class="tf-stat-value">${stats.weekendDays} ${stats.weekendDays === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.weekendHours.toFixed(1)}t</div>
			</div>` : ""}
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F6CC} Avspasering</div>
				<div class="tf-stat-value">${stats.avspasering.count} ${stats.avspasering.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.avspasering.hours.toFixed(1)}t${stats.avspasering.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.avspasering.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3D6}\uFE0F Ferie</div>
				<div class="tf-stat-value" style="font-size: ${this.statsTimeframe === "year" ? "0.9em" : "1.3em"};">${ferieDisplay}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.ferie.planned > 0 ? `\u{1F4C5} Planlagt: ${stats.ferie.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3E5} Velferdspermisjon</div>
				<div class="tf-stat-value">${stats.velferdspermisjon.count} ${stats.velferdspermisjon.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.velferdspermisjon.planned > 0 ? `\u{1F4C5} Planlagt: ${stats.velferdspermisjon.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F912} Egenmelding</div>
				<div class="tf-stat-value" style="font-size: ${this.statsTimeframe === "year" ? "0.9em" : "1.3em"};">${egenmeldingDisplay}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${egenmeldingPeriodLabel}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F3E5} Sykemelding</div>
				<div class="tf-stat-value">${stats.sykemelding.count} ${stats.sykemelding.count === 1 ? "dag" : "dager"}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4DA} Studie</div>
				<div class="tf-stat-value">${stats.studie.count} ${stats.studie.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.studie.hours.toFixed(1)}t${stats.studie.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.studie.planned}` : ""}</div>
			</div>
			<div class="tf-stat-item">
				<div class="tf-stat-label">\u{1F4DA} Kurs</div>
				<div class="tf-stat-value">${stats.kurs.count} ${stats.kurs.count === 1 ? "dag" : "dager"}</div>
				<div style="font-size: 0.75em; margin-top: 4px;">${stats.kurs.hours.toFixed(1)}t${stats.kurs.planned > 0 ? `<br>\u{1F4C5} Planlagt: ${stats.kurs.planned}` : ""}</div>
			</div>
		`;
    const tabs = (_b = this.elements.statsCard.parentElement) == null ? void 0 : _b.querySelectorAll(".tf-tab");
    tabs == null ? void 0 : tabs.forEach((tab) => {
      var _a2;
      const timeframe = (_a2 = tab.textContent) == null ? void 0 : _a2.toLowerCase();
      if (timeframe === "totalt" && this.statsTimeframe === "total" || timeframe === "\xE5r" && this.statsTimeframe === "year" || timeframe === "m\xE5ned" && this.statsTimeframe === "month") {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
  }
  updateMonthCard() {
    if (!this.elements.monthCard)
      return;
    const displayDate = new Date(this.today);
    displayDate.setMonth(this.today.getMonth() + this.currentMonthOffset);
    const grid = this.createMonthGrid(displayDate);
    this.elements.monthCard.innerHTML = "";
    this.elements.monthCard.appendChild(grid);
    const card = this.elements.monthCard.parentElement;
    if (card) {
      const futureList = card.querySelector(".tf-future-days-list");
      if (futureList) {
        this.updateFutureDaysList(futureList);
      }
    }
  }
  updateFutureDaysList(container) {
    const today = /* @__PURE__ */ new Date();
    const futureDays = [];
    Object.keys(this.data.holidays).forEach((dateStr) => {
      const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
      if (date >= today) {
        const holiday = this.data.holidays[dateStr];
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === holiday.type);
        if (behavior) {
          futureDays.push({
            date: dateStr,
            type: behavior.label,
            label: holiday.description || behavior.label,
            color: behavior.color
          });
        }
      }
    });
    futureDays.sort((a, b) => a.date.localeCompare(b.date));
    const limit = this.settings.enableGoalTracking ? 10 : 7;
    const limitedDays = futureDays.slice(0, limit);
    if (limitedDays.length === 0) {
      container.innerHTML = "";
      return;
    }
    let html = "<h4>Kommende planlagte dager</h4>";
    limitedDays.forEach((day) => {
      const date = /* @__PURE__ */ new Date(day.date + "T00:00:00");
      const dateStr = date.toLocaleDateString("nb-NO", { day: "numeric", month: "short", year: "numeric" });
      html += `
				<div class="tf-future-day-item">
					<span class="tf-future-day-date">${dateStr}</span>
					<span class="tf-future-day-type" style="background-color: ${day.color}">${day.label}</span>
				</div>
			`;
    });
    container.innerHTML = html;
  }
  createMonthGrid(displayDate) {
    const year = displayDate.getFullYear();
    const month = displayDate.getMonth();
    const monthName = displayDate.toLocaleDateString("nb-NO", { month: "long", year: "numeric" });
    const container = document.createElement("div");
    const monthTitle = document.createElement("div");
    monthTitle.textContent = monthName;
    monthTitle.style.textAlign = "left";
    monthTitle.style.fontWeight = "bold";
    monthTitle.style.marginBottom = "10px";
    container.appendChild(monthTitle);
    const grid = document.createElement("div");
    grid.className = "tf-month-grid";
    const dayNames = ["Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r", "S\xF8n"];
    dayNames.forEach((name) => {
      const header = document.createElement("div");
      header.textContent = name;
      header.style.textAlign = "center";
      header.style.fontWeight = "bold";
      header.style.fontSize = "12px";
      header.style.color = "var(--text-muted)";
      grid.appendChild(header);
    });
    const firstDay = new Date(year, month, 1);
    let firstDayOfWeek = firstDay.getDay() - 1;
    if (firstDayOfWeek === -1)
      firstDayOfWeek = 6;
    for (let i = 0; i < firstDayOfWeek; i++) {
      const emptyCell = document.createElement("div");
      grid.appendChild(emptyCell);
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const todayKey = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-day-cell";
      cell.textContent = day.toString();
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      const dayEntries = this.data.daily[dateKey];
      const specialDayColors = getSpecialDayColors(this.settings);
      const specialEntry = dayEntries == null ? void 0 : dayEntries.find(
        (e) => specialDayColors[e.name.toLowerCase()]
      );
      const hasEntry = !!(holidayInfo || specialEntry || dayEntries);
      if (holidayInfo) {
        const colorKey = holidayInfo.halfDay ? "halfday" : holidayInfo.type;
        cell.style.background = specialDayColors[colorKey] || specialDayColors[holidayInfo.type] || "#eee";
      } else if (specialEntry) {
        cell.style.background = specialDayColors[specialEntry.name.toLowerCase()];
      } else if (dayEntries) {
        if (!this.settings.enableGoalTracking) {
          cell.style.background = "#78909c";
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.style.background = this.flextimeColor(dayFlextime);
        }
      } else if (Utils.isWeekend(date, this.settings)) {
        cell.style.background = "#b0b0b0";
      } else {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (cellDate < today) {
          cell.style.background = "#e0e0e0";
        } else {
          cell.style.background = "transparent";
        }
      }
      if (hasEntry) {
        cell.classList.add("has-entry");
      } else {
        cell.classList.add("no-entry");
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (!Utils.isWeekend(date, this.settings) && cellDate >= today) {
          cell.style.color = "#ffffff";
        }
      }
      if (dateKey === todayKey) {
        cell.classList.add("today");
      }
      const hasActiveEntry = dayEntries == null ? void 0 : dayEntries.some((e) => !e.endTime);
      if (hasActiveEntry) {
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.top = "4px";
        indicator.style.right = "4px";
        indicator.style.width = "8px";
        indicator.style.height = "8px";
        indicator.style.borderRadius = "50%";
        indicator.style.background = "#4caf50";
        indicator.style.animation = "pulse 2s infinite";
        indicator.style.boxShadow = "0 0 4px rgba(76, 175, 80, 0.8)";
        cell.appendChild(indicator);
      }
      cell.onclick = (e) => {
        e.stopPropagation();
        const cellRect = cell.getBoundingClientRect();
        this.showNoteTypeMenu(cellRect, date);
      };
      grid.appendChild(cell);
    }
    container.appendChild(grid);
    return container;
  }
  flextimeColor(val) {
    if (val < 0) {
      const t = Math.min(Math.abs(val) / 3, 1);
      const r = Math.floor(100 + 50 * t);
      const g = Math.floor(150 + 50 * t);
      const b = Math.floor(200 + 55 * t);
      return `rgb(${r},${g},${b})`;
    } else {
      const t = Math.min(val / 3, 1);
      const r = Math.floor(144 - 110 * t);
      const g = Math.floor(238 - 99 * t);
      const b = Math.floor(144 - 110 * t);
      return `rgb(${r},${g},${b})`;
    }
  }
  showNoteTypeMenu(cellRect, dateObj) {
    var _a, _b, _c;
    const existingMenu = document.querySelector(".tf-context-menu");
    if (existingMenu)
      existingMenu.remove();
    const menu = document.createElement("div");
    menu.className = "tf-context-menu";
    const themeClass = `timeflow-theme-${this.settings.theme}`;
    menu.classList.add(themeClass);
    const menuMain = document.createElement("div");
    menuMain.className = "tf-context-menu-main";
    let menuLeft = cellRect.right;
    let menuTop = cellRect.top;
    document.body.appendChild(menu);
    const isMobile = window.innerWidth <= 500;
    if (isMobile) {
      menuLeft = 10;
      menu.style.left = `${menuLeft}px`;
      menu.style.right = "10px";
      menu.style.width = "calc(100vw - 20px)";
    } else {
      const menuWidth = 450;
      if (menuLeft + menuWidth > window.innerWidth) {
        menuLeft = cellRect.left - menuWidth;
        if (menuLeft < 10) {
          menuLeft = 10;
        }
      }
      menu.style.left = `${menuLeft}px`;
    }
    setTimeout(() => {
      const menuHeight = menu.offsetHeight;
      if (menuTop + menuHeight > window.innerHeight) {
        menuTop = Math.max(10, window.innerHeight - menuHeight - 10);
      }
      if (menuTop < 10) {
        menuTop = 10;
      }
      menu.style.top = `${menuTop}px`;
    }, 0);
    menu.style.top = `${menuTop}px`;
    const dateStr = Utils.toLocalDateStr(dateObj);
    const dateEntries = this.data.daily[dateStr];
    const hasWorkEntriesInDaily = dateEntries && dateEntries.some((e) => e.name.toLowerCase() === "jobb");
    const hasRunningTimerForDate = this.timerManager.data.entries.some((entry) => {
      if (!entry.startTime || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    const hasWorkEntries = hasWorkEntriesInDaily || hasRunningTimerForDate;
    const workTimeItem = document.createElement("div");
    workTimeItem.className = "tf-menu-item";
    workTimeItem.innerHTML = `<span>\u23F1\uFE0F</span><span>Logg arbeidstimer</span>`;
    workTimeItem.onclick = () => {
      menu.remove();
      this.showWorkTimeModal(dateObj);
    };
    menuMain.appendChild(workTimeItem);
    if (hasWorkEntries) {
      const editItem = document.createElement("div");
      editItem.className = "tf-menu-item";
      editItem.innerHTML = `<span>\u270F\uFE0F</span><span>Rediger arbeidstid</span>`;
      editItem.onclick = () => {
        menu.remove();
        this.showEditEntriesModal(dateObj);
      };
      menuMain.appendChild(editItem);
    }
    const specialDayItem = document.createElement("div");
    specialDayItem.className = "tf-menu-item";
    specialDayItem.innerHTML = `<span>\u{1F4C5}</span><span>Registrer spesialdag</span>`;
    specialDayItem.onclick = () => {
      menu.remove();
      this.showSpecialDayModal(dateObj);
    };
    menuMain.appendChild(specialDayItem);
    const separator1 = document.createElement("div");
    separator1.className = "tf-menu-separator";
    menuMain.appendChild(separator1);
    this.settings.noteTypes.forEach((noteType) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.innerHTML = `<span>${noteType.icon}</span><span>${noteType.label}</span>`;
      item.onclick = async () => {
        await this.createNoteFromType(dateObj, noteType);
        menu.remove();
      };
      menuMain.appendChild(item);
    });
    menu.appendChild(menuMain);
    const menuInfo = document.createElement("div");
    menuInfo.className = "tf-context-menu-info";
    const allEntries = dateEntries || [];
    const plannedInfo = this.data.getHolidayInfo(dateStr);
    const isPlannedDay = plannedInfo !== null;
    const isPastDay = dateObj < /* @__PURE__ */ new Date();
    const isFutureDay = dateObj > /* @__PURE__ */ new Date();
    const runningTimersForDate = this.timerManager.data.entries.filter((entry) => {
      if (!entry.startTime || !entry.endTime === false || entry.name.toLowerCase() !== "jobb")
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr && !entry.endTime;
    });
    let infoHTML = `<h4>\u{1F4C5} ${dateStr}</h4>`;
    if (isPlannedDay && plannedInfo) {
      const emoji = Utils.getEmoji({ name: plannedInfo.type, date: dateObj });
      const halfDayText = plannedInfo.halfDay ? " (halv dag)" : "";
      infoHTML += `<p><strong>${emoji} ${plannedInfo.description}${halfDayText}</strong></p>`;
    }
    if (runningTimersForDate.length > 0) {
      infoHTML += "<p><strong>P\xE5g\xE5ende timer:</strong></p>";
      runningTimersForDate.forEach((timer) => {
        const startTime = new Date(timer.startTime);
        const startTimeStr = `${startTime.getHours().toString().padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;
        const now = /* @__PURE__ */ new Date();
        const elapsed = ((now.getTime() - startTime.getTime()) / (1e3 * 60 * 60)).toFixed(1);
        infoHTML += `<p style="margin-left: 8px;">\u23F1\uFE0F ${timer.name}: ${startTimeStr} - P\xE5g\xE5r (${elapsed}t)</p>`;
      });
    }
    const completedEntries = allEntries.filter((e) => e.duration && e.duration > 0);
    if (completedEntries.length > 0) {
      infoHTML += "<p><strong>Registreringer:</strong></p>";
      completedEntries.forEach((e) => {
        const emoji = Utils.getEmoji(e);
        const duration = `${e.duration.toFixed(1)}t`;
        infoHTML += `<p style="margin-left: 8px;">${emoji} ${e.name}: ${duration}</p>`;
      });
      if (!isFutureDay) {
        const totalHours = allEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
        const dayGoal = this.data.getDailyGoal(dateStr);
        const dailyDelta = dayGoal === 0 ? totalHours : totalHours - dayGoal;
        const runningBalance = this.data.getBalanceUpToDate(dateStr);
        infoHTML += `<p style="margin-top: 8px;"><strong>M\xE5l:</strong> ${dayGoal.toFixed(1)}t</p>`;
        infoHTML += `<p><strong>Dagssaldo:</strong> ${dailyDelta >= 0 ? "+" : ""}${dailyDelta.toFixed(1)}t</p>`;
        infoHTML += `<p><strong>L\xF8pende saldo:</strong> ${runningBalance >= 0 ? "+" : ""}${Utils.formatHoursToHM(runningBalance, this.settings.hourUnit)}</p>`;
      }
    } else if (isPastDay && !isPlannedDay && runningTimersForDate.length === 0) {
      infoHTML += '<p style="color: var(--text-muted);">Ingen registrering</p>';
    }
    if (((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) && !isFutureDay && completedEntries.length > 0) {
      const restCheck = this.data.checkRestPeriodViolation(dateStr);
      if (restCheck.violated && restCheck.restHours !== null) {
        const minimumRest = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.minimumRestHours) != null ? _c : 11;
        infoHTML += `<div class="tf-rest-period-warning">
					<span class="warning-icon">\u26A0\uFE0F</span>
					<span>Hviletid: Kun ${restCheck.restHours.toFixed(1)} timer mellom arbeids\xF8kter (minimum ${minimumRest} timer)</span>
				</div>`;
      }
    }
    infoHTML += '<p style="margin-top: 12px; font-size: 0.8em; color: var(--text-muted); border-top: 1px solid var(--background-modifier-border); padding-top: 8px;">\u{1F4A1} Velg et alternativ fra menyen til venstre</p>';
    menuInfo.innerHTML = infoHTML;
    menu.appendChild(menuInfo);
    setTimeout(() => {
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  showWorkTimeModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `Logg arbeidstimer for ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const startLabel = document.createElement("div");
    startLabel.textContent = "Starttid (HH:MM):";
    startLabel.style.marginBottom = "5px";
    startLabel.style.fontWeight = "bold";
    content.appendChild(startLabel);
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.value = "08:00";
    startInput.placeholder = "HH:MM";
    startInput.style.width = "100%";
    startInput.style.marginBottom = "15px";
    startInput.style.padding = "8px";
    startInput.style.fontSize = "14px";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = "Sluttid (HH:MM):";
    endLabel.style.marginBottom = "5px";
    endLabel.style.fontWeight = "bold";
    content.appendChild(endLabel);
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.value = "15:30";
    endInput.placeholder = "HH:MM";
    endInput.style.width = "100%";
    endInput.style.marginBottom = "20px";
    endInput.style.padding = "8px";
    endInput.style.fontSize = "14px";
    content.appendChild(endInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Avbryt";
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = "Legg til";
    addBtn.className = "mod-cta";
    addBtn.onclick = () => {
      const startTime = startInput.value.trim();
      const endTime = endInput.value.trim();
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
        new import_obsidian3.Notice("\u274C Ugyldig tidsformat. Bruk HH:MM format.");
        return;
      }
      const [startHour, startMin] = startTime.split(":").map(Number);
      const [endHour, endMin] = endTime.split(":").map(Number);
      const startDate = new Date(dateObj);
      startDate.setHours(startHour, startMin, 0, 0);
      const endDate = new Date(dateObj);
      endDate.setHours(endHour, endMin, 0, 0);
      if (endDate <= startDate) {
        new import_obsidian3.Notice("\u274C Sluttid m\xE5 v\xE6re etter starttid.");
        return;
      }
      try {
        this.timerManager.data.entries.push({
          name: "jobb",
          startTime: startDate.toISOString(),
          endTime: endDate.toISOString(),
          subEntries: null,
          collapsed: false
        });
        this.timerManager.save();
        const duration = (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
        new import_obsidian3.Notice(`\u2705 Lagt til ${duration.toFixed(1)} timer arbeidstid for ${dateStr}`);
        this.data.rawEntries = this.timerManager.convertToTimeEntries();
        this.data.processEntries();
        this.updateDayCard();
        this.updateWeekCard();
        this.updateStatsCard();
        this.updateMonthCard();
        modal.remove();
      } catch (error) {
        console.error("Failed to add work time:", error);
        new import_obsidian3.Notice("\u274C Kunne ikke legge til arbeidstid");
      }
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    startInput.focus();
    startInput.select();
  }
  showEditEntriesModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const allEntries = this.timerManager.data.entries;
    const workEntries = allEntries.filter((entry) => {
      if (!entry.startTime)
        return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    if (workEntries.length === 0) {
      new import_obsidian3.Notice("Ingen arbeidstidsoppf\xF8ringer funnet for denne datoen");
      return;
    }
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "500px";
    modalContent.style.maxHeight = "80vh";
    modalContent.style.overflow = "auto";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `Rediger arbeidstid for ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    workEntries.forEach((entry, index) => {
      const entryDiv = document.createElement("div");
      entryDiv.style.padding = "15px";
      entryDiv.style.marginBottom = "10px";
      entryDiv.style.background = "var(--background-secondary)";
      entryDiv.style.borderRadius = "8px";
      entryDiv.style.border = "1px solid var(--background-modifier-border)";
      const startDate = new Date(entry.startTime);
      const endDate = entry.endTime ? new Date(entry.endTime) : null;
      const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
      const endTimeStr = endDate ? `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}` : "P\xE5g\xE5ende";
      const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(1) : "N/A";
      const infoDiv = document.createElement("div");
      infoDiv.style.marginBottom = "10px";
      infoDiv.innerHTML = `
				<div style="font-weight: bold; margin-bottom: 5px;">Oppf\xF8ring ${index + 1}</div>
				<div>\u23F0 ${startTimeStr} - ${endTimeStr}</div>
				<div>\u23F1\uFE0F ${duration} timer</div>
			`;
      entryDiv.appendChild(infoDiv);
      const editDiv = document.createElement("div");
      editDiv.style.display = "none";
      editDiv.style.marginTop = "10px";
      const startLabel = document.createElement("div");
      startLabel.textContent = "Starttid:";
      startLabel.style.marginBottom = "5px";
      startLabel.style.fontWeight = "bold";
      editDiv.appendChild(startLabel);
      const startInput = document.createElement("input");
      startInput.type = "text";
      startInput.value = startTimeStr;
      startInput.style.width = "100%";
      startInput.style.marginBottom = "10px";
      startInput.style.padding = "6px";
      editDiv.appendChild(startInput);
      const endLabel = document.createElement("div");
      endLabel.textContent = "Sluttid:";
      endLabel.style.marginBottom = "5px";
      endLabel.style.fontWeight = "bold";
      editDiv.appendChild(endLabel);
      const endInput = document.createElement("input");
      endInput.type = "text";
      endInput.value = endTimeStr !== "P\xE5g\xE5ende" ? endTimeStr : "";
      endInput.style.width = "100%";
      endInput.style.marginBottom = "10px";
      endInput.style.padding = "6px";
      editDiv.appendChild(endInput);
      entryDiv.appendChild(editDiv);
      const buttonDiv = document.createElement("div");
      buttonDiv.style.display = "flex";
      buttonDiv.style.gap = "8px";
      buttonDiv.style.marginTop = "10px";
      const editBtn = document.createElement("button");
      editBtn.textContent = "\u270F\uFE0F Rediger";
      editBtn.style.flex = "1";
      editBtn.onclick = () => {
        if (editDiv.style.display === "none") {
          editDiv.style.display = "block";
          editBtn.textContent = "\u{1F4BE} Lagre";
        } else {
          const newStartTime = startInput.value.trim();
          const newEndTime = endInput.value.trim();
          const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
          if (!timeRegex.test(newStartTime) || newEndTime && !timeRegex.test(newEndTime)) {
            new import_obsidian3.Notice("\u274C Ugyldig tidsformat. Bruk HH:MM format.");
            return;
          }
          const [startHour, startMin] = newStartTime.split(":").map(Number);
          const newStartDate = new Date(dateObj);
          newStartDate.setHours(startHour, startMin, 0, 0);
          let newEndDate = null;
          if (newEndTime) {
            const [endHour, endMin] = newEndTime.split(":").map(Number);
            newEndDate = new Date(dateObj);
            newEndDate.setHours(endHour, endMin, 0, 0);
            if (newEndDate <= newStartDate) {
              new import_obsidian3.Notice("\u274C Sluttid m\xE5 v\xE6re etter starttid.");
              return;
            }
          }
          entry.startTime = newStartDate.toISOString();
          entry.endTime = newEndDate ? newEndDate.toISOString() : null;
          this.timerManager.save();
          new import_obsidian3.Notice("\u2705 Oppf\xF8ring oppdatert");
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          modal.remove();
        }
      };
      buttonDiv.appendChild(editBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "\u{1F5D1}\uFE0F Slett";
      deleteBtn.style.flex = "1";
      deleteBtn.onclick = () => {
        const entryIndex = this.timerManager.data.entries.indexOf(entry);
        if (entryIndex > -1) {
          this.timerManager.data.entries.splice(entryIndex, 1);
          this.timerManager.save();
          new import_obsidian3.Notice("\u2705 Oppf\xF8ring slettet");
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          modal.remove();
        }
      };
      buttonDiv.appendChild(deleteBtn);
      entryDiv.appendChild(buttonDiv);
      content.appendChild(entryDiv);
    });
    const closeDiv = document.createElement("div");
    closeDiv.style.marginTop = "20px";
    closeDiv.style.display = "flex";
    closeDiv.style.justifyContent = "flex-end";
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "Lukk";
    closeBtn.onclick = () => modal.remove();
    closeDiv.appendChild(closeBtn);
    content.appendChild(closeDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  showSpecialDayModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim";
    modal.style.zIndex = "1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal";
    modalContent.style.width = "400px";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = "Registrer spesialdag";
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.padding = "20px";
    const dateDisplay = document.createElement("div");
    dateDisplay.textContent = `Dato: ${dateStr}`;
    dateDisplay.style.marginBottom = "15px";
    dateDisplay.style.fontSize = "16px";
    dateDisplay.style.fontWeight = "bold";
    content.appendChild(dateDisplay);
    const typeLabel = document.createElement("div");
    typeLabel.textContent = "Type dag:";
    typeLabel.style.marginBottom = "5px";
    typeLabel.style.fontWeight = "bold";
    content.appendChild(typeLabel);
    const dayTypes = this.settings.specialDayBehaviors.map((behavior) => ({
      type: behavior.id,
      label: `${behavior.icon} ${behavior.label}`
    }));
    const typeSelect = document.createElement("select");
    typeSelect.style.width = "100%";
    typeSelect.style.marginBottom = "15px";
    typeSelect.style.padding = "8px";
    typeSelect.style.fontSize = "14px";
    dayTypes.forEach(({ type, label }) => {
      const option = document.createElement("option");
      option.value = type;
      option.textContent = label;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const noteLabel = document.createElement("div");
    noteLabel.textContent = "Kommentar (valgfritt):";
    noteLabel.style.marginBottom = "5px";
    noteLabel.style.fontWeight = "bold";
    content.appendChild(noteLabel);
    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.placeholder = 'F.eks. "Ferie i Spania"';
    noteInput.style.width = "100%";
    noteInput.style.marginBottom = "20px";
    noteInput.style.padding = "8px";
    noteInput.style.fontSize = "14px";
    content.appendChild(noteInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Avbryt";
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = "Legg til";
    addBtn.className = "mod-cta";
    addBtn.onclick = async () => {
      const dayType = typeSelect.value;
      const note = noteInput.value.trim();
      await this.addSpecialDay(dateObj, dayType, note);
      modal.remove();
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    typeSelect.focus();
  }
  async addSpecialDay(dateObj, dayType, note = "") {
    var _a, _b;
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        new import_obsidian3.Notice(`\u274C Fant ikke filen: ${filePath}`);
        return;
      }
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      const dateStr = `${year}-${month}-${day}`;
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian3.Notice('\u274C Fant ikke seksjonen "Planlagte egne fridager"');
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian3.Notice("\u274C Fant ikke kodeblokk i seksjonen");
        return;
      }
      const newEntry = `- ${dateStr}: ${dayType}: ${note}`;
      const beforeClosing = content.substring(0, codeBlockEnd);
      const afterClosing = content.substring(codeBlockEnd);
      const needsNewline = !beforeClosing.endsWith("\n");
      content = beforeClosing + (needsNewline ? "\n" : "") + newEntry + "\n" + afterClosing;
      await this.app.vault.modify(file, content);
      const label = ((_a = this.settings.specialDayBehaviors.find((b) => b.id === dayType)) == null ? void 0 : _a.label) || ((_b = this.settings.specialDayLabels) == null ? void 0 : _b[dayType]) || dayType;
      new import_obsidian3.Notice(`\u2705 Lagt til ${dateStr} (${label})`);
      await this.data.loadHolidays();
      this.updateMonthCard();
    } catch (error) {
      console.error("Failed to add special day:", error);
      new import_obsidian3.Notice("\u274C Kunne ikke legge til spesialdag");
    }
  }
  async createNoteFromType(dateObj, noteType) {
    try {
      const dateStr = Utils.toLocalDateStr(dateObj);
      const weekNum = Utils.getWeekNumber(dateObj);
      let filename = noteType.filenamePattern.replace("{YYYY}", dateObj.getFullYear().toString()).replace("{MM}", (dateObj.getMonth() + 1).toString().padStart(2, "0")).replace("{DD}", dateObj.getDate().toString().padStart(2, "0")).replace("{WEEK}", weekNum.toString());
      const filePath = `${noteType.folder}/${filename}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        await this.app.workspace.getLeaf(false).openFile(existingFile);
        new import_obsidian3.Notice(`Opened existing note: ${filename}`);
        return;
      }
      const folderPath = noteType.folder;
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      let content = "";
      const templateFile = this.app.vault.getAbstractFileByPath(noteType.template);
      if (templateFile && templateFile instanceof import_obsidian3.TFile) {
        content = await this.app.vault.read(templateFile);
      }
      content = content.replace(/{date}/g, dateStr).replace(/{time}/g, (/* @__PURE__ */ new Date()).toLocaleTimeString("nb-NO")).replace(/{week}/g, weekNum.toString());
      if (noteType.tags && noteType.tags.length > 0) {
        content += `

${noteType.tags.join(" ")}`;
      }
      const file = await this.app.vault.create(filePath, content);
      await this.app.workspace.getLeaf(false).openFile(file);
      new import_obsidian3.Notice(`Created note: ${filename}`);
    } catch (error) {
      new import_obsidian3.Notice(`Error creating note: ${error.message}`);
      console.error("Error creating note:", error);
    }
  }
  refreshHistoryView(container) {
    container.innerHTML = "";
    const years = {};
    Object.keys(this.data.daily).sort().reverse().forEach((dateKey) => {
      const year = dateKey.split("-")[0];
      if (!years[year])
        years[year] = {};
      const month = dateKey.split("-")[1];
      if (!years[year][month])
        years[year][month] = [];
      years[year][month].push(...this.data.daily[dateKey]);
    });
    if (this.historyView === "list") {
      this.renderListView(container, years);
    } else if (this.historyView === "weekly") {
      this.renderWeeklyView(container, years);
    } else if (this.historyView === "heatmap") {
      this.renderHeatmapView(container, years);
    }
  }
  renderListView(container, years) {
    Object.keys(years).forEach((year) => {
      const yearDiv = document.createElement("div");
      yearDiv.innerHTML = `<h4 style="color: var(--text-normal);">${year}</h4>`;
      Object.keys(years[year]).forEach((month) => {
        const monthEntries = years[year][month];
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginBottom = "15px";
        const thead = document.createElement("thead");
        thead.innerHTML = `
					<tr style="background: var(--background-secondary); color: var(--text-normal);">
						<th style="padding: 8px; color: var(--text-normal);">Dato</th>
						<th style="padding: 8px; color: var(--text-normal);">Type</th>
						<th style="padding: 8px; color: var(--text-normal);">Timer</th>
						<th style="padding: 8px; color: var(--text-normal);">Fleksitid</th>
						<th style="padding: 8px; color: var(--text-normal);">Handling</th>
					</tr>
				`;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        monthEntries.forEach((e) => {
          var _a, _b, _c, _d;
          const row = document.createElement("tr");
          row.style.borderBottom = "1px solid var(--background-modifier-border)";
          row.style.color = "var(--text-normal)";
          const dateCell = document.createElement("td");
          dateCell.style.padding = "8px";
          dateCell.style.color = "var(--text-normal)";
          const dateStr = Utils.toLocalDateStr(e.date);
          const holidayInfo = this.data.getHolidayInfo(dateStr);
          const hasConflict = holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type) && e.name.toLowerCase() !== "avspasering";
          if (hasConflict) {
            const flagIcon = document.createElement("span");
            flagIcon.textContent = "\u26A0\uFE0F ";
            flagIcon.title = `Arbeid registrert p\xE5 ${((_a = this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type)) == null ? void 0 : _a.label) || ((_b = this.settings.specialDayLabels) == null ? void 0 : _b[holidayInfo.type]) || holidayInfo.type}`;
            flagIcon.style.cursor = "help";
            dateCell.appendChild(flagIcon);
          }
          const dateText = document.createTextNode(dateStr);
          dateCell.appendChild(dateText);
          row.appendChild(dateCell);
          const typeCell = document.createElement("td");
          typeCell.style.padding = "8px";
          typeCell.style.color = "var(--text-normal)";
          const entryNameLower = e.name.toLowerCase();
          const customLabel = ((_c = this.settings.specialDayBehaviors.find((b) => b.id === entryNameLower)) == null ? void 0 : _c.label) || ((_d = this.settings.specialDayLabels) == null ? void 0 : _d[entryNameLower]);
          typeCell.textContent = customLabel || e.name;
          row.appendChild(typeCell);
          const hoursCell = document.createElement("td");
          hoursCell.style.padding = "8px";
          hoursCell.style.color = "var(--text-normal)";
          hoursCell.textContent = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
          row.appendChild(hoursCell);
          const flextimeCell = document.createElement("td");
          flextimeCell.style.padding = "8px";
          flextimeCell.style.color = "var(--text-normal)";
          flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
          row.appendChild(flextimeCell);
          const actionCell = document.createElement("td");
          actionCell.style.padding = "8px";
          actionCell.style.color = "var(--text-normal)";
          const editBtn = document.createElement("button");
          editBtn.textContent = "\u270F\uFE0F";
          editBtn.style.padding = "4px 8px";
          editBtn.style.cursor = "pointer";
          editBtn.title = "Rediger arbeidstid";
          editBtn.onclick = () => {
            this.showEditEntriesModal(e.date);
          };
          actionCell.appendChild(editBtn);
          row.appendChild(actionCell);
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      container.appendChild(yearDiv);
    });
  }
  renderWeeklyView(container, years) {
    container.innerHTML = '<div style="padding: 20px; text-align: center;">Weekly view - Coming soon</div>';
  }
  renderHeatmapView(container, years) {
    const heatmap = document.createElement("div");
    heatmap.className = "tf-heatmap";
    heatmap.style.gridTemplateColumns = `repeat(${this.settings.heatmapColumns}, 1fr)`;
    const today = /* @__PURE__ */ new Date();
    const daysToShow = this.settings.heatmapColumns * 8;
    for (let i = daysToShow; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-heatmap-cell";
      cell.title = dateKey;
      const dayEntries = this.data.daily[dateKey];
      if (dayEntries) {
        if (!this.settings.enableGoalTracking) {
          cell.style.background = "#78909c";
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.style.background = this.flextimeColor(dayFlextime);
        }
      } else {
        cell.style.background = "#eee";
      }
      heatmap.appendChild(cell);
    }
    container.appendChild(heatmap);
  }
  exportCurrentView() {
    const rows = [["Date", "Type", "Hours", "Flextime"]];
    Object.keys(this.data.daily).sort().forEach((dateKey) => {
      this.data.daily[dateKey].forEach((entry) => {
        rows.push([
          dateKey,
          entry.name,
          (entry.duration || 0).toFixed(2),
          (entry.flextime || 0).toFixed(2)
        ]);
      });
    });
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian3.Notice("Exported to CSV");
  }
  startUpdates() {
    const clockInterval = window.setInterval(() => {
      this.updateClock();
    }, this.settings.clockInterval);
    this.intervals.push(clockInterval);
    const dataInterval = window.setInterval(() => {
      this.updateAll();
    }, this.settings.updateInterval);
    this.intervals.push(dataInterval);
  }
  updateAll() {
    this.updateBadge();
    this.updateTimerBadge();
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  cleanup() {
    this.intervals.forEach((interval) => clearInterval(interval));
    this.intervals = [];
  }
  build() {
    this.injectStyles();
    this.container.appendChild(this.buildBadgeSection());
    const mainCardsWrapper = document.createElement("div");
    mainCardsWrapper.className = "tf-main-cards-wrapper";
    mainCardsWrapper.appendChild(this.createDayCard());
    mainCardsWrapper.appendChild(this.createWeekCard());
    mainCardsWrapper.appendChild(this.createMonthCard());
    mainCardsWrapper.appendChild(this.createStatsCard());
    this.container.appendChild(mainCardsWrapper);
    this.container.appendChild(this.buildInfoCard());
    this.container.appendChild(this.buildHistoryCard());
    this.container.appendChild(this.buildStatusBar());
    return this.container;
  }
};

// src/view.ts
var VIEW_TYPE_TIMEFLOW = "timeflow-view";
var TimeFlowView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dataManager = null;
    this.uiBuilder = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TIMEFLOW;
  }
  getDisplayText() {
    return "TimeFlow Dashboard";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeflow-dashboard");
    await this.loadDashboard(container);
  }
  async onClose() {
    if (this.uiBuilder) {
      this.uiBuilder.cleanup();
    }
  }
  async loadDashboard(container) {
    try {
      const allEntries = this.plugin.timerManager.convertToTimeEntries();
      if (allEntries.length === 0) {
        container.createDiv({
          text: "No timer data yet. Start a timer to begin tracking!",
          cls: "timeflow-warning"
        });
      }
      this.dataManager = new DataManager(allEntries, this.plugin.settings, this.app);
      const holidayStatus = await this.dataManager.loadHolidays();
      this.dataManager.processEntries();
      const validationResults = this.dataManager.validateData();
      const systemStatus = {
        holiday: holidayStatus,
        validation: validationResults,
        activeTimers: this.dataManager.activeEntries.length
      };
      this.uiBuilder = new UIBuilder(
        this.dataManager,
        systemStatus,
        this.plugin.settings,
        this.app,
        this.plugin.timerManager
      );
      this.plugin.timerManager.onTimerChange = () => {
        this.refresh();
      };
      const dashboardEl = this.uiBuilder.build();
      container.empty();
      container.appendChild(dashboardEl);
      this.uiBuilder.startUpdates();
    } catch (error) {
      console.error("Error loading TimeFlow dashboard:", error);
      container.createDiv({
        text: `Error loading dashboard: ${error.message}`,
        cls: "timeflow-error"
      });
    }
  }
  // Method to refresh the dashboard
  async refresh() {
    const container = this.containerEl.children[1];
    await this.loadDashboard(container);
  }
};

// src/timerManager.ts
var import_obsidian5 = require("obsidian");
var TimerManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.dataFile = settings.dataFilePath;
    this.data = { entries: [] };
  }
  async load() {
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dataFile);
        const parsed = this.parseTimekeepData(content);
        if (parsed) {
          this.data = parsed;
          if (parsed.settings) {
            return parsed.settings;
          }
        } else {
          console.warn("TimeFlow: Could not parse data from", this.dataFile);
          this.data = { entries: [] };
        }
      } else {
        await this.createDataFile();
      }
    } catch (error) {
      console.error("TimeFlow: Error loading timer data:", error);
      this.data = { entries: [] };
    }
    return null;
  }
  async createDataFile() {
    const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data)}
\`\`\`
`;
    const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
    const folderExists = await this.app.vault.adapter.exists(folderPath);
    if (!folderExists) {
      await this.app.vault.createFolder(folderPath);
    }
    await this.app.vault.create(this.dataFile, content);
  }
  parseTimekeepData(content) {
    try {
      const match = content.match(/```timekeep\s*\n([\s\S]*?)\n```/);
      if (match && match[1]) {
        return JSON.parse(match[1]);
      }
    } catch (error) {
      console.error("Error parsing timekeep data:", error);
    }
    return null;
  }
  async save() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.dataFile);
      const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

\`\`\`timekeep
${JSON.stringify(this.data, null, 2)}
\`\`\`
`;
      if (file && file instanceof import_obsidian5.TFile) {
        await this.app.vault.modify(file, content);
      } else {
        const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
        const folderExists = await this.app.vault.adapter.exists(folderPath);
        if (!folderExists) {
          await this.app.vault.createFolder(folderPath);
        }
        await this.app.vault.create(this.dataFile, content);
      }
    } catch (error) {
      console.error("TimeFlow: Error saving timer data:", error);
    }
  }
  // Save settings to the data file for cross-device sync
  async saveSettings(settings) {
    this.settings = settings;
    this.data.settings = settings;
    await this.save();
  }
  async startTimer(name = "Jobb") {
    const timer = {
      name,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      endTime: null,
      subEntries: null
    };
    this.data.entries.push(timer);
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    new import_obsidian5.Notice(`\u23F1\uFE0F Timer started: ${name}`);
    return timer;
  }
  async stopTimer(timer) {
    if (!timer.startTime || timer.endTime) {
      return null;
    }
    timer.endTime = (/* @__PURE__ */ new Date()).toISOString();
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    const duration = Utils.hoursDiff(
      new Date(timer.startTime),
      new Date(timer.endTime)
    );
    new import_obsidian5.Notice(`\u2705 Timer stopped: ${timer.name} (${Utils.formatHoursToHM(duration)})`);
    return timer;
  }
  async stopAllTimers() {
    const activeTimers = this.getActiveTimers();
    for (const timer of activeTimers) {
      await this.stopTimer(timer);
    }
  }
  async deleteTimer(timer) {
    const index = this.data.entries.indexOf(timer);
    if (index !== -1) {
      this.data.entries.splice(index, 1);
      await this.save();
      if (this.onTimerChange) {
        this.onTimerChange();
      }
      new import_obsidian5.Notice("Timer deleted");
      return true;
    }
    return false;
  }
  getActiveTimers() {
    return this.data.entries.filter((e) => e.startTime && !e.endTime && !e.collapsed);
  }
  getCompletedTimers() {
    return this.data.entries.filter((e) => e.startTime && e.endTime);
  }
  getAllTimers() {
    return this.data.entries;
  }
  // Flatten all entries including subEntries for DataManager
  convertToTimeEntries() {
    const flatEntries = [];
    const flattenEntry = (entry) => {
      if (entry.collapsed && entry.subEntries) {
        entry.subEntries.forEach((sub) => flattenEntry(sub));
      } else if (entry.startTime) {
        flatEntries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          subEntries: null
        });
      }
    };
    this.data.entries.forEach((entry) => flattenEntry(entry));
    return flatEntries;
  }
  // Get running time for active timer
  getRunningTime(timer) {
    if (!timer.startTime || timer.endTime)
      return 0;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(timer.startTime);
    return Utils.hoursDiff(start, now);
  }
  // Get total running time for all active timers
  getTotalRunningTime() {
    return this.getActiveTimers().reduce((total, timer) => {
      return total + this.getRunningTime(timer);
    }, 0);
  }
  // Load data from multiple sources (daily notes with timekeep codeblocks)
  async loadFromDailyNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const dailyNotesFolder = this.settings.dailyNotesFolder;
      let allEntries = [];
      for (const file of files) {
        if (file.path.startsWith(dailyNotesFolder)) {
          const content = await this.app.vault.read(file);
          const parsed = this.parseTimekeepData(content);
          if (parsed && parsed.entries) {
            allEntries = allEntries.concat(parsed.entries);
          }
        }
      }
      const currentEntries = this.data.entries;
      allEntries.forEach((entry) => {
        const isDuplicate = currentEntries.some(
          (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
        );
        if (!isDuplicate) {
          currentEntries.push(entry);
        }
      });
      this.data.entries = currentEntries;
      await this.save();
    } catch (error) {
      console.error("Error loading from daily notes:", error);
    }
  }
  // Export to Timekeep format for other tools
  exportTimekeepFormat() {
    return JSON.stringify(this.data, null, 2);
  }
  // Import from Timekeep JSON
  async importTimekeepData(jsonData) {
    try {
      const parsed = JSON.parse(jsonData);
      if (parsed && parsed.entries) {
        const currentEntries = this.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        parsed.entries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.data.entries = currentEntries;
        await this.save();
        if (this.onTimerChange) {
          this.onTimerChange();
        }
        if (skippedCount > 0) {
          new import_obsidian5.Notice(`\u2705 Imported ${addedCount} entries, skipped ${skippedCount} duplicates`);
        } else {
          new import_obsidian5.Notice(`\u2705 Imported ${addedCount} entries`);
        }
        return true;
      }
    } catch (error) {
      console.error("Error importing timekeep data:", error);
      new import_obsidian5.Notice("\u274C Error importing data");
    }
    return false;
  }
};

// src/importModal.ts
var import_obsidian6 = require("obsidian");
var ImportModal = class extends import_obsidian6.Modal {
  constructor(app, timerManager, onSuccess) {
    super(app);
    this.timerManager = timerManager;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Import Timekeep Data" });
    contentEl.createEl("p", {
      text: "Paste your Timekeep JSON data below. This can be from a timekeep codeblock or exported data.",
      cls: "setting-item-description"
    });
    const textArea = contentEl.createEl("textarea", {
      attr: {
        rows: "15",
        placeholder: '{"entries":[...]}'
      }
    });
    textArea.style.width = "100%";
    textArea.style.fontFamily = "monospace";
    textArea.style.fontSize = "12px";
    textArea.style.marginBottom = "15px";
    const infoDiv = contentEl.createDiv();
    infoDiv.style.marginBottom = "15px";
    infoDiv.style.padding = "10px";
    infoDiv.style.background = "var(--background-secondary)";
    infoDiv.style.borderRadius = "5px";
    infoDiv.createEl("strong", { text: "\u{1F4CB} How to get your data:" });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: "Open your file with Timekeep codeblocks" });
    list.createEl("li", { text: "Copy the entire JSON from inside the timekeep block" });
    list.createEl("li", { text: "Paste it in the text area above" });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.gap = "10px";
    buttonDiv.style.justifyContent = "flex-end";
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const importBtn = buttonDiv.createEl("button", { text: "Import", cls: "mod-cta" });
    importBtn.onclick = async () => {
      const jsonText = textArea.value.trim();
      if (!jsonText) {
        new import_obsidian6.Notice("\u26A0\uFE0F Please paste your Timekeep data");
        return;
      }
      try {
        const data = JSON.parse(jsonText);
        if (!data.entries || !Array.isArray(data.entries)) {
          new import_obsidian6.Notice('\u26A0\uFE0F Invalid format: missing "entries" array');
          return;
        }
        if (data.entries.length > 0) {
          const firstEntry = data.entries[0];
          if (!firstEntry.hasOwnProperty("name") || !firstEntry.hasOwnProperty("startTime")) {
            new import_obsidian6.Notice("\u26A0\uFE0F Invalid entry format: missing required fields (name, startTime)");
            return;
          }
        }
        const success = await this.timerManager.importTimekeepData(jsonText);
        if (success) {
          new import_obsidian6.Notice(`\u2705 Successfully imported ${data.entries.length} entries!`);
          this.close();
          this.onSuccess();
        } else {
          new import_obsidian6.Notice("\u274C Failed to import data");
        }
      } catch (error) {
        if (error instanceof SyntaxError) {
          new import_obsidian6.Notice("\u26A0\uFE0F Invalid JSON format. Please check your data.");
        } else {
          new import_obsidian6.Notice(`\u274C Error: ${error.message}`);
        }
        console.error("Import error:", error);
      }
    };
    const hint = contentEl.createEl("div");
    hint.style.marginTop = "10px";
    hint.style.fontSize = "12px";
    hint.style.color = "var(--text-muted)";
    hint.textContent = '\u{1F4A1} Tip: You can also create "TimeFlow Data.md" manually in your vault root';
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var TimeFlowPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    console.log("Loading TimeFlow plugin");
    await this.loadSettings();
    this.timerManager = new TimerManager(this.app, this.settings);
    const syncedSettings = await this.timerManager.load();
    if (syncedSettings) {
      console.log("TimeFlow: Merging synced settings from data file");
      this.settings = Object.assign({}, DEFAULT_SETTINGS, this.settings, syncedSettings);
      this.timerManager.settings = this.settings;
      await this.saveSettings();
    }
    this.registerView(
      VIEW_TYPE_TIMEFLOW,
      (leaf) => new TimeFlowView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open timeflow", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-timeflow",
      name: "Open timeflow Dashboard",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "start-timer",
      name: "Start Timer",
      callback: async () => {
        await this.timerManager.startTimer("jobb");
      }
    });
    this.addCommand({
      id: "stop-all-timers",
      name: "Stop All Timers",
      callback: async () => {
        await this.timerManager.stopAllTimers();
      }
    });
    this.addCommand({
      id: "import-timekeep-data",
      name: "Import Timekeep Data",
      callback: () => {
        new ImportModal(this.app, this.timerManager, () => {
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
          leaves.forEach((leaf) => {
            const view = leaf.view;
            if (view && view.refresh) {
              view.refresh();
            }
          });
        }).open();
      }
    });
    this.addSettingTab(new TimeFlowSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (file.path === this.settings.dataFilePath) {
            await this.timerManager.load();
            const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
            leaves.forEach((leaf) => {
              const view = leaf.view;
              if (view && view.refresh) {
                view.refresh();
              }
            });
          }
        })
      );
    });
  }
  onunload() {
    console.log("Unloading TimeFlow plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.migrateWorkDaysSettings();
    this.migrateSpecialDayBehaviors();
  }
  migrateSpecialDayBehaviors() {
    if (!this.settings.specialDayBehaviors || this.settings.specialDayBehaviors.length === 0) {
      console.log("TimeFlow: Migrating special day settings to new behavior system");
      this.settings.specialDayBehaviors = DEFAULT_SPECIAL_DAY_BEHAVIORS.map((defaultBehavior) => {
        var _a, _b;
        return {
          ...defaultBehavior,
          label: ((_a = this.settings.specialDayLabels) == null ? void 0 : _a[defaultBehavior.id]) || defaultBehavior.label,
          color: ((_b = this.settings.specialDayColors) == null ? void 0 : _b[defaultBehavior.id]) || defaultBehavior.color
        };
      });
    }
  }
  migrateWorkDaysSettings() {
    if (!this.settings.workDays || this.settings.workDays.length === 0) {
      const workDays = [1, 2, 3, 4, 5];
      if (this.settings.includeSaturdayInWorkWeek) {
        workDays.push(6);
      }
      if (this.settings.includeSundayInWorkWeek) {
        workDays.push(0);
      }
      this.settings.workDays = workDays.sort((a, b) => a - b);
    }
    if (!this.settings.alternatingWeekWorkDays || this.settings.alternatingWeekWorkDays.length === 0) {
      this.settings.alternatingWeekWorkDays = [...this.settings.workDays];
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.timerManager.saveSettings(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TIMEFLOW, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
