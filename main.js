/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeFlowPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var FIXED_DAY_COLORS = {
  helligdag: "#ef5350",
  halfday: "#ffd54f",
  "Ingen registrering": "#cccccc"
};
var FIXED_DAY_TEXT_COLORS = {
  helligdag: "#ffffff",
  halfday: "#000000",
  "Ingen registrering": "#000000"
};
function getSpecialDayColors(settings) {
  const colors = { ...FIXED_DAY_COLORS };
  if (settings.specialDayColors) {
    Object.assign(colors, settings.specialDayColors);
  }
  settings.specialDayBehaviors.forEach((behavior) => {
    colors[behavior.id] = behavior.color;
  });
  return colors;
}
function getSpecialDayTextColors(settings) {
  const colors = { ...FIXED_DAY_TEXT_COLORS };
  settings.specialDayBehaviors.forEach((behavior) => {
    colors[behavior.id] = behavior.textColor || "#000000";
  });
  return colors;
}
var EMOJI_MAP = {
  avspasering: "\u{1F6CC}",
  kurs: "\u{1F4DA}",
  studie: "\u{1F4DA}",
  ferie: "\u{1F3D6}\uFE0F",
  velferdspermisjon: "\u{1F3E5}",
  egenmelding: "\u{1F912}",
  sykemelding: "\u{1F3E5}",
  helligdag: "\u{1F389}",
  jobb: "\u{1F4BC}"
};
var Utils = {
  parseDate: (str) => str ? new Date(str) : null,
  hoursDiff: (start, end) => (end.getTime() - start.getTime()) / 36e5,
  isWeekend: (date, settings) => {
    if (!date) return false;
    const day = date.getDay();
    if (!settings) return day === 0 || day === 6;
    if (settings.enableAlternatingWeeks) {
      const weekNum = Utils.getWeekNumber(date);
      const isAlternatingWeek = weekNum % 2 === 0;
      const workDays = isAlternatingWeek ? settings.alternatingWeekWorkDays : settings.workDays;
      return !workDays.includes(day);
    }
    return !settings.workDays.includes(day);
  },
  formatHoursToHM: (hours, unit = "h") => {
    const isNegative = hours < 0;
    const absHours = Math.abs(hours);
    let h = Math.floor(absHours);
    let m = Math.round((absHours - h) * 60);
    if (m === 60) {
      h++;
      m = 0;
    }
    return `${isNegative ? "-" : ""}${h}${unit} ${m.toString().padStart(2, "0")}m`;
  },
  toLocalDateStr: (date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  },
  // Create ISO string without Z suffix (interpreted as local time)
  toLocalISOString: (date) => {
    const pad = (n) => n.toString().padStart(2, "0");
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  },
  getWeekNumber: (d) => {
    const date = new Date(d.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    const week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(
      ((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7
    );
  },
  getEmoji: (entry) => {
    const name = entry.name.toLowerCase();
    if (EMOJI_MAP[name]) return EMOJI_MAP[name];
    if (!entry.endTime) return "\u23F3";
    if (entry.date && Utils.isWeekend(entry.date)) return "\u{1F319}";
    return "";
  },
  randMsg: (arr) => arr[Math.floor(Math.random() * arr.length)],
  getDayOfYear: (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    return Math.floor(diff / 864e5);
  }
};

// src/importModal.ts
var import_obsidian = require("obsidian");

// src/i18n/index.ts
var currentLanguage = "nb";
function setLanguage(lang) {
  currentLanguage = lang;
}
function getLocale() {
  return currentLanguage === "nb" ? "nb-NO" : "en-GB";
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (typeof value === "object" && value !== null && k in value) {
      value = value[k];
    } else {
      value = void 0;
      break;
    }
  }
  return typeof value === "string" ? value : key;
}
function formatDate(date, format = "short") {
  if (currentLanguage === "en") {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    if (format === "long") {
      return date.toLocaleDateString("en-GB", { day: "numeric", month: "short", year: "numeric" });
    }
    return `${year}-${month}-${day}`;
  }
  if (format === "long") {
    return date.toLocaleDateString("nb-NO", { day: "numeric", month: "short", year: "numeric" });
  }
  return date.toLocaleDateString("nb-NO");
}
function formatTime(date, includeSeconds = false) {
  const options = {
    hour: "2-digit",
    minute: "2-digit"
  };
  if (includeSeconds) options.second = "2-digit";
  return date.toLocaleTimeString(getLocale(), options);
}
function getDayNamesShort() {
  return translations[currentLanguage].dates.dayNamesShort;
}
function getMonthName(date) {
  return date.toLocaleDateString(getLocale(), { month: "long", year: "numeric" });
}
var specialDayTranslationMap = {
  "jobb": "specialDays.work",
  "ferie": "specialDays.vacation",
  "avspasering": "specialDays.flexTimeOff",
  "egenmelding": "specialDays.selfReportedSick",
  "sykemelding": "specialDays.doctorSick",
  "velferdspermisjon": "specialDays.welfareLeave",
  "kurs": "specialDays.course",
  "studie": "specialDays.study",
  "helligdag": "specialDays.publicHoliday",
  "annet": "specialDays.other"
};
function translateSpecialDayName(id, fallbackLabel) {
  const translationKey = specialDayTranslationMap[id.toLowerCase()];
  if (translationKey) {
    return t(translationKey);
  }
  return fallbackLabel || id;
}
var annetTemplateTranslationMap = {
  "doctor": "annet.doctor",
  "dentist": "annet.dentist",
  "funeral": "annet.funeral"
};
function translateAnnetTemplateName(id, fallbackLabel) {
  const translationKey = annetTemplateTranslationMap[id.toLowerCase()];
  if (translationKey) {
    return t(translationKey);
  }
  return fallbackLabel || id;
}
var noteTypeTranslationMap = {
  "daily": "noteTypes.daily",
  "meeting": "noteTypes.meeting",
  "project": "noteTypes.project",
  "review": "noteTypes.review",
  "reflection": "noteTypes.reflection"
};
function translateNoteTypeName(id, fallbackLabel) {
  const translationKey = noteTypeTranslationMap[id.toLowerCase()];
  if (translationKey) {
    return t(translationKey);
  }
  return fallbackLabel || id;
}
var translations = {
  nb: {
    dates: {
      dayNamesShort: ["Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r", "S\xF8n"],
      dayNamesFull: ["S\xF8ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "L\xF8rdag"]
    },
    ui: {
      today: "I dag",
      thisWeek: "Denne uken",
      week: "Uke",
      calendar: "Kalender",
      statistics: "Statistikk",
      history: "Historikk",
      information: "Informasjon",
      flextimeBalance: "Fleksitidsaldo",
      hoursWorked: "Timer arbeidet",
      hoursLogged: "Timer logget",
      hours: "Timer",
      dayGoal: "Dagsm\xE5l",
      weekGoal: "Ukem\xE5l",
      flextime: "Fleksitid",
      activeTimers: "Aktive timer",
      activeTimer: "Aktiv timer (p\xE5g\xE5r)",
      ongoing: "P\xE5g\xE5ende",
      total: "Totalt",
      year: "\xC5r",
      month: "M\xE5ned",
      all: "Alle",
      date: "Dato",
      type: "Type",
      start: "Start",
      end: "Slutt",
      duration: "Varighet",
      fullDay: "Hel dag",
      comment: "Kommentar",
      optional: "valgfritt",
      days: "dager",
      goal: "M\xE5l",
      expected: "Forventet",
      difference: "Differanse",
      overWeekLimit: "Over ukegrense",
      vsLastWeek: "vs forrige uke",
      upcomingPlannedDays: "Kommende planlagte dager",
      dailyBalance: "Dagssaldo",
      runningBalance: "L\xF8pende saldo",
      noRegistration: "Ingen registrering",
      noDataForDay: "Ingen data for den dagen",
      addNewEntry: "+ Legg til ny oppf\xF8ring",
      restPeriodWarning: "Hviletid: Kun {hours} timer mellom arbeids\xF8kter (minimum {min} timer)",
      restPeriod: "Hviletid",
      minimum: "minimum",
      multipleDays: "Flere dager",
      startDate: "Startdato",
      endDate: "Sluttdato",
      weeklyViewComingSoon: "Ukesvisning - kommer snart"
    },
    status: {
      ok: "OK",
      near: "N\xE6r",
      over: "Over",
      onTarget: "P\xE5 m\xE5l",
      overTarget: "Over m\xE5l",
      underTarget: "Under m\xE5l",
      inProgress: "P\xE5g\xE5r",
      allLimitsOk: "Alle grenser er OK.",
      withinLimits: "Innenfor grensene",
      approachingLimits: "N\xE6rmer seg",
      systemStatus: "Systemstatus",
      clickForDetails: "klikk for detaljer",
      holidayNotLoaded: "Helligdagsdata ikke lastet",
      activeTimers: "aktive timer",
      entriesChecked: "oppf\xF8ringer sjekket",
      loadedPlannedDays: "Lastet inn {count} planlagte dager"
    },
    buttons: {
      cancel: "Avbryt",
      save: "Lagre",
      delete: "Slett",
      edit: "Rediger",
      close: "Lukk",
      add: "Legg til",
      done: "Ferdig",
      start: "Start",
      stop: "Stopp",
      export: "Eksporter",
      import: "Importer",
      preview: "Forh\xE5ndsvis",
      list: "Liste",
      heatmap: "Heatmap",
      moveToMain: "Flytt til hovedomr\xE5de",
      moveToSidebar: "Flytt til sidepanel"
    },
    menu: {
      logWork: "Logg arbeidstimer",
      editWork: "Rediger arbeidstid",
      registerSpecialDay: "Registrer frav\xE6r",
      editPlannedDay: "Rediger",
      addEntry: "Legg til oppf\xF8ring",
      deleteEntry: "Slett oppf\xF8ring",
      selectOption: "Velg et alternativ fra menyen"
    },
    timeframes: {
      total: "Totalt",
      year: "\xC5r",
      month: "M\xE5ned"
    },
    modals: {
      logWorkTitle: "Logg arbeidstimer for",
      editWorkTitle: "Rediger arbeidstid for",
      registerSpecialDayTitle: "Registrer frav\xE6r",
      addEntryTitle: "Legg til oppf\xF8ring for",
      deleteEntryTitle: "Slett oppf\xF8ring",
      startTime: "Starttid",
      endTime: "Sluttid",
      startTimeFormat: "Starttid (HH:MM):",
      endTimeFormat: "Sluttid (HH:MM):",
      dayType: "Type dag:",
      timePeriod: "Tidsperiode:",
      from: "Fra:",
      to: "Til:",
      commentOptional: "Kommentar (valgfritt):",
      commentPlaceholder: 'F.eks. "Ferie i Spania"',
      commentPlaceholders: {
        ferie: 'F.eks. "Ferie i Spania"',
        egenmelding: 'F.eks. "Hodepine"',
        sykemelding: 'F.eks. "Influensa"',
        velferdspermisjon: 'F.eks. "Legebes\xF8k"',
        avspasering: 'F.eks. "Tidlig helg"',
        helligdag: 'F.eks. "1. mai"',
        kurs: 'F.eks. "React-kurs"',
        studie: 'F.eks. "Eksamensforberedelse"',
        halfday: 'F.eks. "Halv dag f\xF8r ferie"',
        default: 'F.eks. "Kommentar"'
      },
      durationHint: "Antall timer (f.eks. 3.5 for resten av dagen etter sykdom)",
      commentRequired: "Kommentar p\xE5krevd",
      commentTitle: "Legg til kommentar",
      overtimeExplanation: "Du har jobbet {hours} over dagsm\xE5let.",
      commentPrompt: "Vennligst forklar hvorfor:",
      skip: "Hopp over"
    },
    validation: {
      endAfterStart: "Sluttid m\xE5 v\xE6re etter starttid",
      invalidTime: "Ugyldig tid (bruk format HH:MM, 00-23:00-59)",
      invalidTimePeriod: "Ugyldig tidsperiode",
      invalidDateRange: "Ugyldig datoperiode",
      overlappingEntry: "Denne oppf\xF8ringen overlapper med en eksisterende oppf\xF8ring",
      endTimeNextDay: "Sluttid satt til neste dag (f\xF8r starttid)",
      invalidDuration: "Ugyldig varighet",
      invalidTimeFormat: "Ugyldig tidsformat. Bruk HH:MM format.",
      startTimeRequired: "Starttid m\xE5 fylles ut",
      invalidStartDateTime: "Ugyldig startdato/tid",
      invalidEndDateTime: "Ugyldig sluttdato/tid"
    },
    units: {
      day: "dag",
      days: "dager",
      hours: "timer"
    },
    notifications: {
      added: "Lagt til",
      updated: "Oppdatert",
      deleted: "Slettet",
      exported: "Eksportert til CSV",
      saveError: "Feil ved lagring av data",
      addedWorkTime: "Lagt til {duration} timer arbeidstid for {date}",
      errorAddingWorkTime: "Kunne ikke legge til arbeidstid",
      noWorkEntriesFound: "Ingen arbeidstidsoppf\xF8ringer funnet for denne datoen",
      entryUpdated: "Oppf\xF8ring oppdatert",
      fileNotFound: "Fant ikke filen: {path}",
      sectionNotFound: "Fant ikke seksjonen",
      codeBlockNotFound: "Fant ikke kodeblokk i seksjonen",
      errorAddingSpecialDay: "Kunne ikke legge til spesialdag",
      openedExistingNote: "\xC5pnet eksisterende notat: {filename}",
      createdNote: "Opprettet notat: {filename}",
      errorCreatingNote: "Feil ved opprettelse av notat: {error}",
      addedHours: "Lagt til {duration} timer for {date}",
      errorLoadingDashboard: "Feil ved lasting av dashboard: {error}",
      errorImporting: "Feil ved importering av data",
      errorDeletingEntry: "Feil ved sletting av oppf\xF8ring",
      errorUpdatingEntry: "Feil ved oppdatering av oppf\xF8ring"
    },
    confirm: {
      deleteEntry: "Er du sikker p\xE5 at du vil slette denne oppf\xF8ringen?",
      deleteEntryFor: "Slette oppf\xF8ring for",
      overnightShiftTitle: "Nattskift?",
      overnightShift: "Sluttid er f\xF8r starttid. Er dette et nattskift som g\xE5r over midnatt?"
    },
    stats: {
      flextimeBalance: "Fleksitidsaldo",
      hours: "Timer",
      avgPerDay: "Snitt/dag",
      avgPerWeek: "Snitt/uke",
      workIntensity: "Intensitet",
      ofNormalWeek: "av normaluke",
      work: "Jobb",
      weekendDaysWorked: "Helgedager jobbet",
      flexTimeOff: "Avspasering",
      vacation: "Ferie",
      welfareLeave: "Velferdspermisjon",
      selfReportedSick: "Egenmelding",
      doctorSick: "Sykemelding",
      study: "Studiedag",
      course: "Kursdag",
      totalBalance: "Total saldo",
      weeklyHours: "Uketimer",
      monthlyHours: "M\xE5nedstimer",
      yearlyHours: "\xC5rstimer",
      target: "M\xE5l",
      weekPrefix: "U"
    },
    specialDays: {
      work: "Jobb",
      vacation: "Ferie",
      flexTimeOff: "Avspasering",
      selfReportedSick: "Egenmelding",
      doctorSick: "Sykemelding",
      welfareLeave: "Velferdspermisjon",
      course: "Kursdag",
      study: "Studiedag",
      publicHoliday: "Helligdag",
      other: "Annet"
    },
    annet: {
      title: "Annet",
      custom: "Egendefinert",
      fullDay: "Hel dag",
      saveAsTemplate: "Lagre som mal",
      templateName: "Mal-navn",
      templateIcon: "Ikon",
      addTemplate: "Legg til mal",
      editTemplate: "Rediger mal",
      deleteTemplate: "Slett mal",
      noTemplates: "Ingen maler definert",
      selectTemplate: "Velg mal eller egendefinert",
      description: "Beskrivelse",
      fromTime: "Fra",
      toTime: "Til",
      templateDescription: 'Maler for "Annet"-frav\xE6rstype. Atferd bestemmes automatisk av om det er hel dag eller delvis frav\xE6r.',
      idDesc: "Unik identifikator (sm\xE5 bokstaver, ingen mellomrom). Brukes i fil-formatet.",
      labelField: "Navn",
      labelDesc: "Visningsnavn i grensesnittet",
      iconField: "Ikon",
      iconDesc: "Emoji som vises sammen med malen",
      idRequired: "ID er p\xE5krevd",
      labelRequired: "Navn er p\xE5krevd",
      iconRequired: "Ikon er p\xE5krevd",
      duplicateId: "En mal med denne ID-en finnes allerede",
      templatesSection: "Annet-maler",
      templatesDesc: "Maler for fleksible frav\xE6rstyper. Atferd bestemmes av om det er hel dag eller delvis frav\xE6r.",
      labelPlaceholder: "Lege",
      // Default template names
      doctor: "Lege",
      dentist: "Tannlege",
      funeral: "Begravelse"
    },
    common: {
      cancel: "Avbryt",
      save: "Lagre",
      delete: "Slett",
      edit: "Rediger",
      add: "Legg til"
    },
    import: {
      title: "Importer data",
      description: "Importer tidsdata fra ulike formater. St\xF8tter Timekeep JSON, CSV og JSON-arrays.",
      selectFile: "Velg fil...",
      noFile: "Ingen fil valgt",
      orPasteData: "Eller lim inn data:",
      placeholder: "Lim inn Timekeep JSON, CSV eller JSON-array her...\n\nEksempel CSV (norsk format):\nDato;Start;Slutt;Aktivitet\n25.11.2024;08:00;16:00;jobb\n26.11.2024;09:00;17:00;jobb",
      format: "Format:",
      autoDetect: "Auto-detekter",
      supportedFormats: "St\xF8ttede formater:",
      noEntries: "Ingen oppf\xF8ringer \xE5 importere",
      entriesFound: "oppf\xF8ringer funnet",
      imported: "Importerte",
      entries: "oppf\xF8ringer",
      skippedDuplicates: "hoppet over",
      duplicates: "duplikater",
      andMore: "og",
      more: "flere",
      errors: {
        invalidFormat: "Ugyldig format",
        missingEntries: 'mangler "entries" array',
        missingFields: "Mangler p\xE5krevde felt",
        invalidStartTime: "Ugyldig starttid",
        invalidEndTime: "Ugyldig sluttid",
        csvNeedsHeader: "CSV m\xE5 ha minst en overskriftsrad og en datarad",
        jsonError: "JSON-feil",
        unknownFormat: "Kunne ikke gjenkjenne formatet. St\xF8ttede formater: Timekeep JSON, CSV, JSON Array",
        couldNotFindDateColumn: "Kunne ikke finne dato-kolonne. Forventet: Dato, Date, Dag",
        couldNotFindStartColumn: "Kunne ikke finne starttid-kolonne. Forventet: Start, Starttid, Fra",
        tooFewColumns: "For f\xE5 kolonner",
        missingDateOrTime: "Mangler dato eller starttid",
        invalidDateFormat: "Ugyldig datoformat. Bruk DD.MM.YYYY eller YYYY-MM-DD",
        invalidTimeFormat: "Ugyldig tid. Bruk HH:MM",
        expectedJsonArray: "Forventet en JSON-array",
        couldNotParseDateTime: "Kunne ikke tolke dato/tid",
        entry: "Oppf\xF8ring",
        row: "Rad",
        dateAutoCorrected: "Ugyldig dato {date} ble autokorrigert til {corrected}"
      },
      warnings: "Advarsler",
      errors_label: "Feil",
      tableHeaders: {
        date: "Dato",
        start: "Start",
        end: "Slutt",
        type: "Type"
      }
    },
    export: {
      csvTooltip: "Eksporter historikk til CSV-fil",
      noData: "Ingen data \xE5 eksportere",
      success: "Eksport fullf\xF8rt",
      selectMonth: "Eksporter m\xE5ned",
      month: "M\xE5ned",
      allMonths: "Alle m\xE5neder",
      date: "Dato",
      type: "Type",
      start: "Start",
      end: "Slutt",
      hours: "Timer",
      flextime: "Fleksitid",
      comment: "Kommentar",
      monthlySummary: "M\xE5nedlig oppsummering",
      totalHours: "Totalt timer",
      totalFlextime: "Total fleksitid",
      workDays: "Arbeidsdager",
      avgDaily: "Gjennomsnitt per dag",
      typeBreakdown: "Fordeling per type",
      typeHeader: "Type",
      daysHeader: "Dager",
      hoursHeader: "Timer"
    },
    settings: {
      language: "Spr\xE5k",
      languageDesc: "Velg spr\xE5k for grensesnittet",
      showWeekNumbers: "Vis ukenummer",
      showWeekNumbersDesc: "Vis ukenummer i kalender og uke-kortet (ISO 8601 ukenummer)",
      hideEmptyStats: "Skjul tomme statistikker",
      hideEmptyStatsDesc: "Skjul statistikker med 0 timer/dager",
      startingFlextimeBalance: "Startbalanse fleksitid",
      startingFlextimeBalanceDesc: "Fleksitidssaldo \xE5 starte med (bruk dette hvis du migrerer fra et annet system)",
      importData: "Importer data",
      importDataDesc: "Importer tidsdata fra ulike formater: Timekeep JSON, CSV (norsk/ISO datoformat), eller JSON-arrays",
      absenceTypesDesc: 'Opprett egendefinerte frav\xE6rskategorier med spesifikke fleksitid- og statistikkregler. St\xF8tter frav\xE6r over flere dager. For enkeltst\xE5ende frav\xE6r, bruk "Annet-maler" nedenfor.',
      addAbsenceType: "Legg til frav\xE6rstype",
      overtimeComments: "Overtidskommentarer",
      enableOvertimeComments: "Krev kommentar ved overtid",
      enableOvertimeCommentsDesc: "Krev kommentar n\xE5r du stopper en timer og har jobbet mer enn dagsm\xE5let + terskel",
      overtimeCommentThreshold: "Kommentarkrav (timer over m\xE5l)",
      overtimeCommentThresholdDesc: "Krev kommentar n\xE5r dagstotal overstiger dagsm\xE5l + dette antall timer (standard: 0.5)",
      overtimeCommentEffectiveDate: "Gjelder fra dato",
      overtimeCommentEffectiveDateDesc: "Dato fra n\xE5r kommentarkravet trer i kraft (eldre oppf\xF8ringer p\xE5virkes ikke)"
    },
    compliance: {
      title: "Arbeidstidsgrenser",
      today: "I dag",
      thisWeek: "Denne uken",
      restPeriod: "Hviletid",
      limit: "grense",
      approaching: "n\xE6rmer seg",
      exceeds: "Overstiger",
      ok: "OK",
      near: "N\xE6r",
      over: "Over"
    },
    timer: {
      runningTimers: "P\xE5g\xE5ende timer",
      noActiveTimers: "Ingen aktive timer",
      started: "Timer startet: {name}",
      stopped: "Timer stoppet: {name} ({duration})",
      deleted: "Timer slettet"
    },
    noteTypes: {
      daily: "Daglig Notat",
      meeting: "M\xF8tenotat",
      project: "Prosjektnotat",
      review: "Ukesoppsummering",
      reflection: "Refleksjonsnotat"
    },
    info: {
      specialDayTypes: "Frav\xE6rstyper",
      workDaysGradient: "Arbeidsdager - fargegradient",
      colorShowsFlextime: "Fargen viser fleksitid i forhold til dagens m\xE5l",
      calendarContextMenu: "Kalenderkontekstmeny",
      clickDayFor: "Trykk p\xE5 en dag i kalenderen for:",
      createDailyNote: "Opprett daglig notat",
      editFlextimeManually: "Rediger arbeidstid manuelt",
      registerSpecialDays: "Registrer frav\xE6r",
      flextimeBalanceZones: "Fleksitidsaldo - soner",
      green: "Gr\xF8nn",
      yellow: "Gul",
      orange: "Oransje",
      red: "R\xF8d",
      gray: "Gr\xE5",
      to: "til",
      weekNumberCompliance: "Ukenummer - statusfarger",
      reachedGoal: "N\xE5dd m\xE5l",
      overGoal: "Over m\xE5l",
      underGoal: "Under m\xE5l",
      weekInProgress: "Uke p\xE5g\xE5r",
      clickWeekForDetails: "Trykk p\xE5 ukenummer for detaljer.",
      publicHolidayDesc: "Offentlig fridag - p\xE5virker ikke fleksitid",
      halfDayDesc: "Halv arbeidsdag ({hours}t) - reduserer ukem\xE5let med {reduction}t",
      withdrawFromFlextime: "Trekkes fra fleksitid",
      countsAsFlextime: "Teller som fleksitid ved mer enn {hours}t",
      noFlextimeEffect: "P\xE5virker ikke fleksitid",
      workRegisteredOnSpecialDay: "Arbeid registrert p\xE5 {dayType}"
    }
  },
  en: {
    dates: {
      dayNamesShort: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
      dayNamesFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    ui: {
      today: "Today",
      thisWeek: "This Week",
      week: "Week",
      calendar: "Calendar",
      statistics: "Statistics",
      history: "History",
      information: "Information",
      flextimeBalance: "Flextime Balance",
      hoursWorked: "Hours worked",
      hoursLogged: "Hours logged",
      hours: "Hours",
      dayGoal: "Daily Goal",
      weekGoal: "Weekly Goal",
      flextime: "Flextime",
      activeTimers: "Active timers",
      activeTimer: "Active timer (in progress)",
      ongoing: "Ongoing",
      total: "Total",
      year: "Year",
      month: "Month",
      all: "All",
      date: "Date",
      type: "Type",
      start: "Start",
      end: "End",
      duration: "Duration",
      fullDay: "Full day",
      comment: "Comment",
      optional: "optional",
      days: "days",
      goal: "Goal",
      expected: "Expected",
      difference: "Difference",
      overWeekLimit: "Over weekly limit",
      vsLastWeek: "vs last week",
      upcomingPlannedDays: "Upcoming planned days",
      dailyBalance: "Daily balance",
      runningBalance: "Running balance",
      noRegistration: "No registration",
      noDataForDay: "No data for this day",
      addNewEntry: "+ Add new entry",
      restPeriodWarning: "Rest period: Only {hours} hours between work sessions (minimum {min} hours)",
      restPeriod: "Rest period",
      minimum: "minimum",
      multipleDays: "Multiple days",
      startDate: "Start date",
      endDate: "End date",
      weeklyViewComingSoon: "Weekly view - coming soon"
    },
    status: {
      ok: "OK",
      near: "Near",
      over: "Over",
      onTarget: "On target",
      overTarget: "Over target",
      underTarget: "Under target",
      inProgress: "In progress",
      allLimitsOk: "All limits are OK.",
      withinLimits: "Within limits",
      approachingLimits: "Approaching",
      systemStatus: "System Status",
      clickForDetails: "click for details",
      holidayNotLoaded: "Holiday data not loaded",
      activeTimers: "active timers",
      entriesChecked: "entries checked",
      loadedPlannedDays: "Loaded {count} planned days"
    },
    buttons: {
      cancel: "Cancel",
      save: "Save",
      delete: "Delete",
      edit: "Edit",
      close: "Close",
      add: "Add",
      done: "Done",
      start: "Start",
      stop: "Stop",
      export: "Export",
      import: "Import",
      preview: "Preview",
      list: "List",
      heatmap: "Heatmap",
      moveToMain: "Move to main area",
      moveToSidebar: "Move to sidebar"
    },
    menu: {
      logWork: "Log work hours",
      editWork: "Edit work time",
      registerSpecialDay: "Register absence",
      editPlannedDay: "Edit",
      addEntry: "Add entry",
      deleteEntry: "Delete entry",
      selectOption: "Select an option from the menu"
    },
    timeframes: {
      total: "Total",
      year: "Year",
      month: "Month"
    },
    modals: {
      logWorkTitle: "Log work hours for",
      editWorkTitle: "Edit work time for",
      registerSpecialDayTitle: "Register absence",
      addEntryTitle: "Add entry for",
      deleteEntryTitle: "Delete entry",
      startTime: "Start time",
      endTime: "End time",
      startTimeFormat: "Start time (HH:MM):",
      endTimeFormat: "End time (HH:MM):",
      dayType: "Day type:",
      timePeriod: "Time period:",
      from: "From:",
      to: "To:",
      commentOptional: "Comment (optional):",
      commentPlaceholder: 'E.g. "Vacation in Spain"',
      commentPlaceholders: {
        ferie: 'E.g. "Vacation in Spain"',
        egenmelding: 'E.g. "Headache"',
        sykemelding: 'E.g. "Flu"',
        velferdspermisjon: 'E.g. "Doctor appointment"',
        avspasering: 'E.g. "Early weekend"',
        helligdag: 'E.g. "May 1st"',
        kurs: 'E.g. "React course"',
        studie: 'E.g. "Exam preparation"',
        halfday: 'E.g. "Half day before vacation"',
        default: 'E.g. "Comment"'
      },
      durationHint: "Number of hours (e.g. 3.5 for rest of day after leaving sick)",
      commentRequired: "Comment required",
      commentTitle: "Add comment",
      overtimeExplanation: "You worked {hours} over the daily goal.",
      commentPrompt: "Please explain why:",
      skip: "Skip"
    },
    validation: {
      endAfterStart: "End time must be after start time",
      invalidTime: "Invalid time (use format HH:MM, 00-23:00-59)",
      invalidTimePeriod: "Invalid time period",
      invalidDateRange: "Invalid date range",
      overlappingEntry: "This entry overlaps with an existing entry",
      endTimeNextDay: "End time set to next day (before start time)",
      invalidDuration: "Invalid duration",
      invalidTimeFormat: "Invalid time format. Use HH:MM format.",
      startTimeRequired: "Start time is required",
      invalidStartDateTime: "Invalid start date/time",
      invalidEndDateTime: "Invalid end date/time"
    },
    units: {
      day: "day",
      days: "days",
      hours: "hours"
    },
    notifications: {
      added: "Added",
      updated: "Updated",
      deleted: "Deleted",
      exported: "Exported to CSV",
      saveError: "Error saving data",
      addedWorkTime: "Added {duration} hours of work time for {date}",
      errorAddingWorkTime: "Could not add work time",
      noWorkEntriesFound: "No work entries found for this date",
      entryUpdated: "Entry updated",
      fileNotFound: "File not found: {path}",
      sectionNotFound: "Section not found",
      codeBlockNotFound: "Code block not found in section",
      errorAddingSpecialDay: "Could not add special day",
      openedExistingNote: "Opened existing note: {filename}",
      createdNote: "Created note: {filename}",
      errorCreatingNote: "Error creating note: {error}",
      addedHours: "Added {duration} hours for {date}",
      errorLoadingDashboard: "Error loading dashboard: {error}",
      errorImporting: "Error importing data",
      errorDeletingEntry: "Error deleting entry",
      errorUpdatingEntry: "Error updating entry"
    },
    confirm: {
      deleteEntry: "Are you sure you want to delete this entry?",
      deleteEntryFor: "Delete entry for",
      overnightShiftTitle: "Overnight shift?",
      overnightShift: "End time is before start time. Is this an overnight shift that crosses midnight?"
    },
    stats: {
      flextimeBalance: "Flextime Balance",
      hours: "Hours",
      avgPerDay: "Avg/day",
      avgPerWeek: "Avg/week",
      workIntensity: "Workload",
      ofNormalWeek: "of normal week",
      work: "Work",
      weekendDaysWorked: "Weekend days worked",
      flexTimeOff: "Comp time",
      vacation: "Vacation",
      welfareLeave: "Welfare leave",
      selfReportedSick: "Sick day (self-reported)",
      doctorSick: "Certified sick leave",
      study: "Study",
      course: "Course",
      totalBalance: "Total balance",
      weeklyHours: "Weekly hours",
      monthlyHours: "Monthly hours",
      yearlyHours: "Yearly hours",
      target: "Target",
      weekPrefix: "W"
    },
    specialDays: {
      work: "Work",
      vacation: "Vacation",
      flexTimeOff: "Comp time",
      selfReportedSick: "Sick day (self-reported)",
      doctorSick: "Certified sick leave",
      welfareLeave: "Welfare leave",
      course: "Course",
      study: "Study",
      publicHoliday: "Public holiday",
      other: "Other"
    },
    annet: {
      title: "Other",
      custom: "Custom",
      fullDay: "Full day",
      saveAsTemplate: "Save as template",
      templateName: "Template name",
      templateIcon: "Icon",
      addTemplate: "Add template",
      editTemplate: "Edit template",
      deleteTemplate: "Delete template",
      noTemplates: "No templates defined",
      selectTemplate: "Select template or custom",
      description: "Description",
      fromTime: "From",
      toTime: "To",
      templateDescription: 'Templates for "Other" absence type. Behavior is automatically determined by full day or partial absence.',
      idDesc: "Unique identifier (lowercase, no spaces). Used in file format.",
      labelField: "Name",
      labelDesc: "Display name in the interface",
      iconField: "Icon",
      iconDesc: "Emoji displayed with the template",
      idRequired: "ID is required",
      labelRequired: "Name is required",
      iconRequired: "Icon is required",
      duplicateId: "A template with this ID already exists",
      templatesSection: "Other templates",
      templatesDesc: "Templates for flexible absence types. Behavior is determined by full day or partial absence.",
      labelPlaceholder: "Doctor",
      // Default template names
      doctor: "Doctor",
      dentist: "Dentist",
      funeral: "Funeral"
    },
    common: {
      cancel: "Cancel",
      save: "Save",
      delete: "Delete",
      edit: "Edit",
      add: "Add"
    },
    import: {
      title: "Import data",
      description: "Import time data from various formats. Supports Timekeep JSON, CSV and JSON arrays.",
      selectFile: "Select file...",
      noFile: "No file selected",
      orPasteData: "Or paste data:",
      placeholder: "Paste Timekeep JSON, CSV or JSON array here...\n\nExample CSV:\nDate;Start;End;Activity\n2024-11-25;08:00;16:00;work\n2024-11-26;09:00;17:00;work",
      format: "Format:",
      autoDetect: "Auto-detect",
      supportedFormats: "Supported formats:",
      noEntries: "No entries to import",
      entriesFound: "entries found",
      imported: "Imported",
      entries: "entries",
      skippedDuplicates: "skipped",
      duplicates: "duplicates",
      andMore: "and",
      more: "more",
      errors: {
        invalidFormat: "Invalid format",
        missingEntries: 'missing "entries" array',
        missingFields: "Missing required fields",
        invalidStartTime: "Invalid start time",
        invalidEndTime: "Invalid end time",
        csvNeedsHeader: "CSV must have at least a header row and a data row",
        jsonError: "JSON error",
        unknownFormat: "Could not recognize format. Supported formats: Timekeep JSON, CSV, JSON Array",
        couldNotFindDateColumn: "Could not find date column. Expected: Date, Dato, Day",
        couldNotFindStartColumn: "Could not find start time column. Expected: Start, From",
        tooFewColumns: "Too few columns",
        missingDateOrTime: "Missing date or start time",
        invalidDateFormat: "Invalid date format. Use DD.MM.YYYY or YYYY-MM-DD",
        invalidTimeFormat: "Invalid time. Use HH:MM",
        expectedJsonArray: "Expected a JSON array",
        couldNotParseDateTime: "Could not parse date/time",
        entry: "Entry",
        row: "Row",
        dateAutoCorrected: "Invalid date {date} was auto-corrected to {corrected}"
      },
      warnings: "Warnings",
      errors_label: "Errors",
      tableHeaders: {
        date: "Date",
        start: "Start",
        end: "End",
        type: "Type"
      }
    },
    export: {
      csvTooltip: "Export history to CSV file",
      noData: "No data to export",
      success: "Export completed",
      selectMonth: "Export month",
      month: "Month",
      allMonths: "All months",
      date: "Date",
      type: "Type",
      start: "Start",
      end: "End",
      hours: "Hours",
      flextime: "Flextime",
      comment: "Comment",
      monthlySummary: "Monthly summary",
      totalHours: "Total hours",
      totalFlextime: "Total flextime",
      workDays: "Work days",
      avgDaily: "Average per day",
      typeBreakdown: "Breakdown by type",
      typeHeader: "Type",
      daysHeader: "Days",
      hoursHeader: "Hours"
    },
    settings: {
      language: "Language",
      languageDesc: "Choose interface language",
      showWeekNumbers: "Show week numbers",
      showWeekNumbersDesc: "Show week numbers in calendar and week card (ISO 8601 week numbers)",
      hideEmptyStats: "Hide empty statistics",
      hideEmptyStatsDesc: "Hide statistics with 0 hours/days",
      startingFlextimeBalance: "Starting flextime balance",
      startingFlextimeBalanceDesc: "Initial flextime balance to start with (use this if migrating from another system)",
      importData: "Import data",
      importDataDesc: "Import time data from various formats: Timekeep JSON, CSV (Norwegian/ISO date format), or JSON arrays",
      absenceTypesDesc: 'Create custom absence categories with specific flextime and statistics rules. Supports multi-day absences. For occasional one-off absences, use "Other templates" below.',
      addAbsenceType: "Add absence type",
      overtimeComments: "Overtime comments",
      enableOvertimeComments: "Require comment on overtime",
      enableOvertimeCommentsDesc: "Require comment when stopping a timer and daily work exceeds goal + threshold",
      overtimeCommentThreshold: "Comment required (hours over goal)",
      overtimeCommentThresholdDesc: "Require comment when daily total exceeds daily goal + this many hours (default: 0.5)",
      overtimeCommentEffectiveDate: "Effective from date",
      overtimeCommentEffectiveDateDesc: "Date from when comment requirement takes effect (older entries are not affected)"
    },
    compliance: {
      title: "Work time limits",
      today: "Today",
      thisWeek: "This week",
      restPeriod: "Rest period",
      limit: "limit",
      approaching: "approaching",
      exceeds: "Exceeds",
      ok: "OK",
      near: "Near",
      over: "Over"
    },
    timer: {
      runningTimers: "Running timers",
      noActiveTimers: "No active timers",
      started: "Timer started: {name}",
      stopped: "Timer stopped: {name} ({duration})",
      deleted: "Timer deleted"
    },
    noteTypes: {
      daily: "Daily Note",
      meeting: "Meeting Note",
      project: "Project Note",
      review: "Weekly Review",
      reflection: "Reflection Note"
    },
    info: {
      specialDayTypes: "Absence types",
      workDaysGradient: "Work days - color gradient",
      colorShowsFlextime: "Color shows flextime relative to daily goal",
      calendarContextMenu: "Calendar context menu",
      clickDayFor: "Click on a day in the calendar for:",
      createDailyNote: "Create daily note",
      editFlextimeManually: "Edit flextime manually",
      registerSpecialDays: "Register absences",
      flextimeBalanceZones: "Flextime balance - zones",
      green: "Green",
      yellow: "Yellow",
      orange: "Orange",
      red: "Red",
      gray: "Gray",
      to: "to",
      weekNumberCompliance: "Week number - status colors",
      reachedGoal: "Reached goal",
      overGoal: "Over goal",
      underGoal: "Under goal",
      weekInProgress: "Week in progress",
      clickWeekForDetails: "Click on a week number for details.",
      publicHolidayDesc: "Public holiday - does not affect flextime",
      halfDayDesc: "Half work day ({hours}h) - reduces weekly goal by {reduction}h",
      withdrawFromFlextime: "Deducted from flextime balance",
      countsAsFlextime: "Counts as flextime above {hours}h",
      noFlextimeEffect: "Does not affect flextime",
      workRegisteredOnSpecialDay: "Work registered on {dayType}"
    }
  }
};

// src/importParsers.ts
var TimekeepParser = class {
  constructor() {
    this.name = "Timekeep JSON";
  }
  canParse(content) {
    try {
      const trimmed = content.trim();
      if (!trimmed.startsWith("{")) return false;
      const data = JSON.parse(trimmed);
      return data.entries && Array.isArray(data.entries);
    } catch (e) {
      return false;
    }
  }
  parse(content) {
    var _a;
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const data = JSON.parse(content.trim());
      if (!data.entries || !Array.isArray(data.entries)) {
        result.errors.push(`${t("import.errors.invalidFormat")}: ${t("import.errors.missingEntries")}`);
        return result;
      }
      for (let i = 0; i < data.entries.length; i++) {
        const entry = data.entries[i];
        if (!entry.name || !entry.startTime) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.missingFields")} (name, startTime)`);
          continue;
        }
        const startDate = new Date(entry.startTime);
        if (isNaN(startDate.getTime())) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.invalidStartTime")}`);
          continue;
        }
        if (entry.endTime) {
          const endDate = new Date(entry.endTime);
          if (isNaN(endDate.getTime())) {
            result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.invalidEndTime")}`);
            continue;
          }
        }
        result.entries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime || null,
          collapsed: (_a = entry.collapsed) != null ? _a : false,
          subEntries: entry.subEntries || null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`${t("import.errors.jsonError")}: ${error instanceof Error ? error.message : String(error)}`);
    }
    return result;
  }
};
var CSVParser = class {
  constructor() {
    this.name = "CSV";
  }
  canParse(content) {
    const lines = content.trim().split("\n");
    if (lines.length < 2) return false;
    const firstLine = lines[0].toLowerCase();
    const hasDateColumn = firstLine.includes("dato") || firstLine.includes("date");
    const hasTimeColumn = firstLine.includes("start") || firstLine.includes("time") || firstLine.includes("tid");
    return hasDateColumn || hasTimeColumn;
  }
  parse(content) {
    var _a, _b, _c, _d;
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const lines = content.trim().split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
      if (lines.length < 2) {
        result.errors.push(t("import.errors.csvNeedsHeader"));
        return result;
      }
      const delimiter = this.detectDelimiter(lines[0]);
      const headers = this.parseCSVLine(lines[0], delimiter).map((h) => h.toLowerCase().trim());
      const dateCol = this.findColumn(headers, ["dato", "date", "dag", "day"]);
      const startCol = this.findColumn(headers, ["start", "starttid", "start time", "fra", "from"]);
      const endCol = this.findColumn(headers, ["slutt", "end", "sluttid", "end time", "til", "to"]);
      const activityCol = this.findColumn(headers, ["aktivitet", "activity", "type", "navn", "name", "beskrivelse", "description"]);
      if (dateCol === -1) {
        result.errors.push(t("import.errors.couldNotFindDateColumn"));
        return result;
      }
      if (startCol === -1) {
        result.errors.push(t("import.errors.couldNotFindStartColumn"));
        return result;
      }
      for (let i = 1; i < lines.length; i++) {
        const values = this.parseCSVLine(lines[i], delimiter);
        if (values.length <= Math.max(dateCol, startCol)) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.tooFewColumns")}`);
          continue;
        }
        const dateStr = (_a = values[dateCol]) == null ? void 0 : _a.trim();
        const startStr = (_b = values[startCol]) == null ? void 0 : _b.trim();
        const endStr = endCol !== -1 ? (_c = values[endCol]) == null ? void 0 : _c.trim() : "";
        const activity = activityCol !== -1 ? (_d = values[activityCol]) == null ? void 0 : _d.trim() : "jobb";
        if (!dateStr || !startStr) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.missingDateOrTime")}`);
          continue;
        }
        const parsedDate = this.parseDate(dateStr, result.warnings);
        if (!parsedDate) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidDateFormat")} "${dateStr}"`);
          continue;
        }
        const startTime = this.parseTime(startStr);
        if (!startTime) {
          result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidTimeFormat")} "${startStr}"`);
          continue;
        }
        const startDateTime = new Date(parsedDate);
        startDateTime.setHours(startTime.hours, startTime.minutes, 0, 0);
        let endDateTime = null;
        if (endStr) {
          const endTime = this.parseTime(endStr);
          if (endTime) {
            endDateTime = new Date(parsedDate);
            endDateTime.setHours(endTime.hours, endTime.minutes, 0, 0);
            if (endDateTime <= startDateTime) {
              endDateTime.setDate(endDateTime.getDate() + 1);
            }
          } else {
            result.warnings.push(`${t("import.errors.row")} ${i + 1}: ${t("import.errors.invalidTimeFormat")} "${endStr}"`);
          }
        }
        result.entries.push({
          name: activity.toLowerCase() || "jobb",
          startTime: startDateTime.toISOString(),
          endTime: endDateTime ? endDateTime.toISOString() : null,
          collapsed: false,
          subEntries: null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`CSV ${t("import.errors_label")}: ${error instanceof Error ? error.message : String(error)}`);
    }
    return result;
  }
  detectDelimiter(line) {
    const semicolonCount = (line.match(/;/g) || []).length;
    const commaCount = (line.match(/,/g) || []).length;
    const tabCount = (line.match(/\t/g) || []).length;
    if (semicolonCount >= commaCount && semicolonCount >= tabCount) return ";";
    if (tabCount >= commaCount) return "	";
    return ",";
  }
  parseCSVLine(line, delimiter) {
    const result = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === delimiter && !inQuotes) {
        result.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  }
  findColumn(headers, possibleNames) {
    for (const name of possibleNames) {
      const index = headers.findIndex((h) => h.includes(name));
      if (index !== -1) return index;
    }
    return -1;
  }
  parseDate(dateStr, warnings) {
    let yearNum, monthNum, dayNum;
    const norwegianMatch = dateStr.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
    if (norwegianMatch) {
      const [, day, month, year] = norwegianMatch;
      dayNum = parseInt(day);
      monthNum = parseInt(month);
      yearNum = parseInt(year);
    } else {
      const isoMatch = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        dayNum = parseInt(day);
        monthNum = parseInt(month);
        yearNum = parseInt(year);
      } else {
        const slashMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (slashMatch) {
          const [, day, month, year] = slashMatch;
          dayNum = parseInt(day);
          monthNum = parseInt(month);
          yearNum = parseInt(year);
        } else {
          return null;
        }
      }
    }
    const date = new Date(yearNum, monthNum - 1, dayNum);
    if (isNaN(date.getTime())) return null;
    if (date.getFullYear() !== yearNum || date.getMonth() !== monthNum - 1 || date.getDate() !== dayNum) {
      const correctedStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
      if (warnings) {
        warnings.push(t("import.errors.dateAutoCorrected").replace("{date}", dateStr).replace("{corrected}", correctedStr));
      }
    }
    return date;
  }
  parseTime(timeStr) {
    const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
    if (match) {
      const hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
        return { hours, minutes };
      }
    }
    const dotMatch = timeStr.match(/^(\d{1,2})\.(\d{2})$/);
    if (dotMatch) {
      const hours = parseInt(dotMatch[1]);
      const minutes = parseInt(dotMatch[2]);
      if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
        return { hours, minutes };
      }
    }
    return null;
  }
};
var GenericJSONParser = class {
  constructor() {
    this.name = "JSON Array";
  }
  canParse(content) {
    try {
      const trimmed = content.trim();
      if (!trimmed.startsWith("[")) return false;
      const data = JSON.parse(trimmed);
      return Array.isArray(data) && data.length > 0;
    } catch (e) {
      return false;
    }
  }
  parse(content) {
    const result = {
      success: false,
      entries: [],
      errors: [],
      warnings: []
    };
    try {
      const data = JSON.parse(content.trim());
      if (!Array.isArray(data)) {
        result.errors.push(t("import.errors.expectedJsonArray"));
        return result;
      }
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const dateField = item.date || item.dato || item.day || item.dag;
        const startField = item.start || item.startTime || item.starttid || item.fra || item.from;
        const endField = item.end || item.endTime || item.slutt || item.sluttid || item.til || item.to;
        const nameField = item.name || item.navn || item.activity || item.aktivitet || item.type || "jobb";
        if (!dateField && !startField) {
          if (item.startTime && item.startTime.includes("T")) {
            const startDate = new Date(item.startTime);
            if (!isNaN(startDate.getTime())) {
              result.entries.push({
                name: (nameField || "jobb").toLowerCase(),
                startTime: item.startTime,
                endTime: item.endTime || null,
                collapsed: false,
                subEntries: null
              });
              continue;
            }
          }
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.missingDateOrTime")}`);
          continue;
        }
        let startDateTime = null;
        let endDateTime = null;
        if (dateField && startField) {
          startDateTime = this.combineDateAndTime(dateField, startField);
          if (endField) {
            endDateTime = this.combineDateAndTime(dateField, endField);
            if (endDateTime && startDateTime && endDateTime <= startDateTime) {
              endDateTime.setDate(endDateTime.getDate() + 1);
            }
          }
        }
        if (!startDateTime) {
          result.warnings.push(`${t("import.errors.entry")} ${i + 1}: ${t("import.errors.couldNotParseDateTime")}`);
          continue;
        }
        result.entries.push({
          name: (nameField || "jobb").toLowerCase(),
          startTime: startDateTime.toISOString(),
          endTime: endDateTime ? endDateTime.toISOString() : null,
          collapsed: false,
          subEntries: null
        });
      }
      result.success = result.entries.length > 0;
    } catch (error) {
      result.errors.push(`${t("import.errors.jsonError")}: ${error instanceof Error ? error.message : String(error)}`);
    }
    return result;
  }
  combineDateAndTime(dateStr, timeStr) {
    let date = null;
    if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
      date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
    } else if (dateStr.match(/^\d{1,2}\.\d{1,2}\.\d{4}$/)) {
      const [day, month, year] = dateStr.split(".").map(Number);
      date = new Date(year, month - 1, day);
    }
    if (!date || isNaN(date.getTime())) return null;
    const timeMatch = timeStr.match(/^(\d{1,2}):(\d{2})$/);
    if (timeMatch) {
      date.setHours(parseInt(timeMatch[1]), parseInt(timeMatch[2]), 0, 0);
      return date;
    }
    return null;
  }
};
function autoDetectAndParse(content) {
  const parsers = [
    new TimekeepParser(),
    new CSVParser(),
    new GenericJSONParser()
  ];
  for (const parser of parsers) {
    if (parser.canParse(content)) {
      const result = parser.parse(content);
      return { ...result, format: parser.name };
    }
  }
  return {
    success: false,
    entries: [],
    errors: [t("import.errors.unknownFormat")],
    warnings: [],
    format: "?"
  };
}

// src/importModal.ts
var ImportModal = class extends import_obsidian.Modal {
  constructor(app, timerManager, onSuccess) {
    super(app);
    this.selectedFormat = "auto";
    this.parsedEntries = [];
    this.parseWarnings = [];
    this.timerManager = timerManager;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("timeflow-import-modal");
    contentEl.createEl("h2", { text: t("import.title") });
    contentEl.createEl("p", {
      text: t("import.description"),
      cls: "setting-item-description"
    });
    const formatDiv = contentEl.createDiv({ cls: "tf-import-format-div" });
    formatDiv.createEl("label", { text: t("import.format") + " ", cls: "tf-import-label" });
    const formatSelect = formatDiv.createEl("select", { cls: "tf-import-select" });
    const formats = [
      { value: "auto", label: t("import.autoDetect") },
      { value: "timekeep", label: "Timekeep JSON" },
      { value: "csv", label: "CSV" },
      { value: "json", label: "JSON Array" }
    ];
    formats.forEach((f) => {
      const option = formatSelect.createEl("option", { text: f.label, value: f.value });
      if (f.value === this.selectedFormat) option.selected = true;
    });
    formatSelect.onchange = () => {
      this.selectedFormat = formatSelect.value;
    };
    const uploadDiv = contentEl.createDiv({ cls: "tf-import-upload-div" });
    const fileInput = uploadDiv.createEl("input", {
      type: "file",
      cls: "tf-import-file-input",
      attr: { accept: ".json,.csv,.txt" }
    });
    const uploadBtn = uploadDiv.createEl("button", { text: "\u{1F4C1} " + t("import.selectFile"), cls: "tf-import-upload-btn" });
    uploadBtn.onclick = () => fileInput.click();
    const fileNameSpan = uploadDiv.createEl("span", { text: t("import.noFile"), cls: "tf-import-file-name" });
    contentEl.createEl("div", { text: t("import.orPasteData"), cls: "tf-import-textarea-label" });
    const textArea = contentEl.createEl("textarea", {
      cls: "tf-import-textarea",
      attr: {
        rows: "12",
        placeholder: t("import.placeholder")
      }
    });
    fileInput.onchange = () => {
      var _a;
      const file = (_a = fileInput.files) == null ? void 0 : _a[0];
      if (file) {
        fileNameSpan.textContent = file.name;
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a2;
          textArea.value = ((_a2 = e.target) == null ? void 0 : _a2.result) || "";
          this.updatePreview(textArea.value, previewDiv, importBtn);
        };
        reader.readAsText(file);
      }
    };
    const previewDiv = contentEl.createDiv({ cls: "tf-import-preview" });
    const parseBtn = contentEl.createEl("button", { text: "\u{1F50D} " + t("buttons.preview"), cls: "tf-import-parse-btn" });
    parseBtn.onclick = () => {
      this.updatePreview(textArea.value, previewDiv, importBtn);
    };
    let parseTimeout;
    textArea.oninput = () => {
      clearTimeout(parseTimeout);
      parseTimeout = window.setTimeout(() => {
        if (textArea.value.trim().length > 50) {
          this.updatePreview(textArea.value, previewDiv, importBtn);
        }
      }, 500);
    };
    const infoDiv = contentEl.createDiv({ cls: "tf-import-info" });
    infoDiv.createEl("strong", { text: "\u{1F4CB} " + t("import.supportedFormats") });
    const list = infoDiv.createEl("ul");
    list.createEl("li", { text: 'Timekeep JSON: {"entries": [...]}' });
    list.createEl("li", { text: `CSV: ${t("import.tableHeaders.date")};${t("import.tableHeaders.start")};${t("import.tableHeaders.end")};Type` });
    list.createEl("li", { text: 'JSON Array: [{"date": "...", "start": "...", ...}]' });
    const buttonDiv = contentEl.createDiv({ cls: "tf-import-buttons" });
    const cancelBtn = buttonDiv.createEl("button", { text: t("buttons.cancel") });
    cancelBtn.onclick = () => this.close();
    const importBtn = buttonDiv.createEl("button", { text: t("buttons.import"), cls: "mod-cta" });
    importBtn.disabled = true;
    importBtn.onclick = async () => {
      if (this.parsedEntries.length === 0) {
        new import_obsidian.Notice("\u26A0\uFE0F " + t("import.noEntries"));
        return;
      }
      try {
        const currentEntries = this.timerManager.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        this.parsedEntries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.timerManager.data.entries = currentEntries;
        await this.timerManager.save();
        if (skippedCount > 0) {
          new import_obsidian.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}, ${t("import.skippedDuplicates")} ${skippedCount} ${t("import.duplicates")}`);
        } else {
          new import_obsidian.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}!`);
        }
        this.close();
        void this.onSuccess();
      } catch (error) {
        new import_obsidian.Notice(`\u274C ${t("import.errors_label")}: ${error instanceof Error ? error.message : String(error)}`);
        console.error("Import error:", error);
      }
    };
  }
  updatePreview(content, previewDiv, importBtn) {
    previewDiv.empty();
    this.parsedEntries = [];
    this.parseWarnings = [];
    if (!content.trim()) {
      previewDiv.removeClass("is-visible");
      importBtn.disabled = true;
      return;
    }
    let result;
    if (this.selectedFormat === "auto") {
      result = autoDetectAndParse(content);
    } else {
      let parser;
      switch (this.selectedFormat) {
        case "timekeep":
          parser = new TimekeepParser();
          break;
        case "csv":
          parser = new CSVParser();
          break;
        case "json":
          parser = new GenericJSONParser();
          break;
        default:
          parser = new TimekeepParser();
      }
      result = { ...parser.parse(content), format: parser.name };
    }
    previewDiv.addClass("is-visible");
    const formatInfo = previewDiv.createEl("div", { cls: "tf-import-format-info" });
    formatInfo.createEl("strong", { text: t("import.format") });
    formatInfo.appendText(" " + (result.format || "?"));
    if (result.errors.length > 0) {
      const errorDiv = previewDiv.createEl("div", { cls: "tf-import-error" });
      errorDiv.createEl("strong", { text: "\u274C " + t("import.errors_label") + ":" });
      const errorList = errorDiv.createEl("ul");
      result.errors.forEach((err) => errorList.createEl("li", { text: err }));
    }
    if (result.warnings.length > 0) {
      const warnDiv = previewDiv.createEl("div", { cls: "tf-import-warning" });
      warnDiv.createEl("strong", { text: "\u26A0\uFE0F " + t("import.warnings") + ":" });
      const warnList = warnDiv.createEl("ul");
      result.warnings.slice(0, 5).forEach((warn) => warnList.createEl("li", { text: warn }));
      if (result.warnings.length > 5) {
        warnList.createEl("li", { text: `... ${t("import.andMore")} ${result.warnings.length - 5} ${t("import.more")}` });
      }
    }
    if (result.entries.length > 0) {
      this.parsedEntries = result.entries;
      importBtn.disabled = false;
      const successDiv = previewDiv.createEl("div", { cls: "tf-import-success" });
      successDiv.createEl("strong", { text: "\u2705 " + result.entries.length + " " + t("import.entriesFound") });
      const previewTable = previewDiv.createEl("table", { cls: "tf-import-preview-table" });
      const thead = previewTable.createEl("thead");
      const headerRow = thead.createEl("tr");
      [t("import.tableHeaders.date"), t("import.tableHeaders.start"), t("import.tableHeaders.end"), t("import.tableHeaders.type")].forEach((h) => {
        headerRow.createEl("th", { text: h });
      });
      const tbody = previewTable.createEl("tbody");
      result.entries.slice(0, 5).forEach((entry) => {
        const row = tbody.createEl("tr");
        const startDate = new Date(entry.startTime);
        const endDate = entry.endTime ? new Date(entry.endTime) : null;
        const dateStr = formatDate(startDate);
        const startStr = formatTime(startDate);
        const endStr = endDate ? formatTime(endDate) : "-";
        [dateStr, startStr, endStr, entry.name].forEach((val) => {
          row.createEl("td", { text: val });
        });
      });
      if (result.entries.length > 5) {
        const moreRow = tbody.createEl("tr", { cls: "tf-import-more-row" });
        moreRow.createEl("td", {
          text: `... ${t("import.andMore")} ${result.entries.length - 5} ${t("import.more")}`,
          attr: { colspan: "4" }
        });
      }
    } else {
      importBtn.disabled = true;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings.ts
var DEFAULT_SPECIAL_DAY_BEHAVIORS = [
  {
    id: "jobb",
    label: "Jobb",
    icon: "\u{1F4BC}",
    color: "#4caf50",
    // Green for positive flextime (over goal)
    textColor: "#ffffff",
    negativeColor: "#64b5f6",
    // Blue for negative flextime (under goal)
    negativeTextColor: "#ffffff",
    simpleColor: "#90caf9",
    // Light blue for simple tracking mode
    simpleTextColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true,
    isWorkType: true,
    showInTimerDropdown: true
  },
  {
    id: "ferie",
    label: "Ferie",
    icon: "\u{1F3D6}\uFE0F",
    color: "#b3e5fc",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true,
    maxDaysPerYear: 25
  },
  {
    id: "avspasering",
    label: "Avspasering",
    icon: "\u{1F6CC}",
    color: "#ffe0b2",
    textColor: "#000000",
    noHoursRequired: true,
    flextimeEffect: "withdraw",
    includeInStats: true
  },
  {
    id: "egenmelding",
    label: "Egenmelding",
    icon: "\u{1F912}",
    color: "#c8e6c9",
    textColor: "#000000",
    noHoursRequired: false,
    // Can have hours (partial sick day)
    flextimeEffect: "reduce_goal",
    // Hours reduce daily goal
    includeInStats: true,
    maxDaysPerYear: 24,
    countingPeriod: "rolling365"
  },
  {
    id: "sykemelding",
    label: "Sykemelding",
    icon: "\u{1F3E5}",
    color: "#c8e6c9",
    textColor: "#000000",
    noHoursRequired: false,
    // Can have hours (partial sick day)
    flextimeEffect: "reduce_goal",
    // Hours reduce daily goal
    includeInStats: true
  },
  {
    id: "velferdspermisjon",
    label: "Velferdspermisjon",
    icon: "\u{1F3E5}",
    color: "#e1bee7",
    textColor: "#000000",
    noHoursRequired: false,
    // Can have hours (partial day)
    flextimeEffect: "reduce_goal",
    // Hours reduce daily goal
    includeInStats: true
  },
  {
    id: "kurs",
    label: "Kurs",
    icon: "\u{1F4DA}",
    color: "#f8bbd0",
    textColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true,
    showInTimerDropdown: true
  },
  {
    id: "studie",
    label: "Studie",
    icon: "\u{1F4D6}",
    color: "#f8bbd0",
    textColor: "#000000",
    noHoursRequired: false,
    flextimeEffect: "accumulate",
    includeInStats: true,
    showInTimerDropdown: true
  },
  {
    id: "helligdag",
    label: "Helligdag",
    icon: "\u{1F389}",
    color: "#ef5350",
    textColor: "#ffffff",
    noHoursRequired: true,
    flextimeEffect: "none",
    includeInStats: true
  },
  {
    id: "annet",
    label: "Other",
    icon: "\u{1F4CB}",
    color: "#e0e0e0",
    textColor: "#000000",
    noHoursRequired: false,
    // Dynamic - determined at parse time based on entry format
    flextimeEffect: "reduce_goal",
    // Dynamic - determined at parse time
    includeInStats: false
  }
];
var DEFAULT_ANNET_TEMPLATES = [
  { id: "doctor", label: "Doctor", icon: "\u{1F3E5}" },
  { id: "dentist", label: "Dentist", icon: "\u{1F9B7}" },
  { id: "funeral", label: "Funeral", icon: "\u26AB" }
];
var DEFAULT_SETTINGS = {
  version: "1.2.2",
  language: "nb",
  defaultViewLocation: "sidebar",
  hourUnit: "t",
  showWeekNumbers: true,
  hideEmptyStats: false,
  workPercent: 1,
  baseWorkday: 7.5,
  baseWorkweek: 37.5,
  lunchBreakMinutes: 0,
  includeSaturdayInWorkWeek: false,
  // DEPRECATED
  includeSundayInWorkWeek: false,
  // DEPRECATED
  workDays: [1, 2, 3, 4, 5],
  // Monday-Friday by default
  enableAlternatingWeeks: false,
  alternatingWeekWorkDays: [1, 2, 3, 4, 5],
  // Same as workDays by default
  enableGoalTracking: true,
  // NEW: Default to goal-based tracking (current behavior)
  enableWeeklyGoals: true,
  maxEgenmeldingDays: 8,
  maxFerieDays: 25,
  updateInterval: 30,
  clockInterval: 1,
  dataFilePath: "timeflow/data.md",
  holidaysFilePath: "timeflow/holidays.md",
  dailyNotesFolder: "Daily Notes",
  dailyNotesTemplatePath: "timeflow/templates/daily-notes.md",
  workdaysPerYear: 260,
  workdaysPerMonth: 21,
  workdaysPerWeek: 5,
  consecutiveFlextimeWarningDays: 5,
  defaultExportWeeks: 52,
  heatmapColumns: 48,
  heatmapShowSpecialDayColors: false,
  noteTypes: [
    {
      id: "daily",
      label: "Daily Note",
      icon: "\u{1F4C5}",
      folder: "Daily Notes",
      template: "timeflow/templates/daily-notes.md",
      tags: [],
      filenamePattern: "{YYYY}-{MM}-{DD}"
    },
    {
      id: "meeting",
      label: "Meeting Note",
      icon: "\u{1F465}",
      folder: "Meetings",
      template: "timeflow/templates/meeting-note.md",
      tags: ["#meeting", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Meeting"
    },
    {
      id: "project",
      label: "Project Note",
      icon: "\u{1F4CB}",
      folder: "Projects",
      template: "timeflow/templates/project-note.md",
      tags: ["#project", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Project"
    },
    {
      id: "review",
      label: "Weekly Review",
      icon: "\u{1F50D}",
      folder: "Reviews",
      template: "timeflow/templates/weekly-review.md",
      tags: ["#review", "#weekly", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Week {WEEK}"
    },
    {
      id: "reflection",
      label: "Reflection Note",
      icon: "\u{1F4AD}",
      folder: "Reflections",
      template: "timeflow/templates/reflection-note.md",
      tags: ["#reflection", "#timeflow"],
      filenamePattern: "{YYYY}-{MM}-{DD} Reflection"
    }
  ],
  specialDayBehaviors: DEFAULT_SPECIAL_DAY_BEHAVIORS,
  annetTemplates: DEFAULT_ANNET_TEMPLATES,
  specialDayColors: {
    avspasering: "#ffe0b2",
    ferie: "#b3e5fc",
    velferdspermisjon: "#e1bee7",
    egenmelding: "#c8e6c9",
    sykemelding: "#c8e6c9",
    kurs: "#f8bbd0",
    studie: "#f8bbd0"
  },
  specialDayLabels: {
    avspasering: "Avspasering",
    ferie: "Ferie",
    velferdspermisjon: "Velferdspermisjon",
    egenmelding: "Egenmelding",
    sykemelding: "Sykemelding",
    kurs: "Kurs",
    studie: "Studie"
  },
  // Advanced configuration settings
  balanceStartDate: "2025-01-01",
  startingFlextimeBalance: 0,
  halfDayHours: 4,
  halfDayMode: "fixed",
  balanceThresholds: {
    criticalLow: -15,
    warningLow: 0,
    warningHigh: 80,
    criticalHigh: 95
  },
  validationThresholds: {
    longRunningTimerHours: 12,
    veryLongSessionHours: 16,
    maxDurationHours: 24,
    highWeeklyTotalHours: 50
  },
  // NEW: Custom colors
  customColors: {
    balanceOk: "#4caf50",
    balanceWarning: "#ff9800",
    balanceCritical: "#f44336",
    progressBar: "#4caf50"
  },
  // Norwegian labor law compliance settings
  complianceSettings: {
    enableWarnings: true,
    dailyHoursLimit: 9,
    weeklyHoursLimit: 40,
    minimumRestHours: 11
  },
  // Migration flags
  hasTimestampMigration: false,
  // Overtime comment settings
  enableOvertimeComments: true,
  overtimeCommentThreshold: 0.5,
  overtimeCommentEffectiveDate: "2025-01-01"
};
var ConfirmModal = class extends import_obsidian2.Modal {
  constructor(app, message, onConfirm, title) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title || t("buttons.confirm");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("tf-confirm-modal");
    contentEl.createEl("h3", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    const buttonDiv = contentEl.createDiv({ cls: "tf-btn-container" });
    const cancelBtn = buttonDiv.createEl("button", { text: t("buttons.cancel") });
    cancelBtn.onclick = () => this.close();
    const confirmBtn = buttonDiv.createEl("button", { text: t("buttons.confirm"), cls: "mod-cta mod-warning" });
    confirmBtn.onclick = () => {
      this.close();
      void this.onConfirm();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SpecialDayBehaviorModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, behavior, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.behavior = behavior;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
    const { contentEl } = this;
    contentEl.empty();
    const isWorkType = (_b = (_a = this.behavior) == null ? void 0 : _a.isWorkType) != null ? _b : false;
    contentEl.createEl("h2", { text: isWorkType ? "Edit work entry type" : this.behavior ? "Edit absence type" : "Add absence type" });
    if (this.behavior && !isWorkType) {
      const norwegianTerms = {
        "egenmelding": "Norwegian self-reported sick leave (max 8 days/year per Norwegian labor law)",
        "velferdspermisjon": "Norwegian welfare leave for personal/family health matters",
        "avspasering": "Norwegian term: Time off as compensation for accumulated flextime"
      };
      const explanation = norwegianTerms[this.behavior.id];
      if (explanation) {
        const infoBox = contentEl.createDiv({ cls: "setting-item-description tf-settings-info-box" });
        infoBox.createSpan({ text: "\u2139\uFE0F " + explanation });
      }
    }
    if (isWorkType) {
      const infoBox = contentEl.createDiv({ cls: "setting-item-description tf-settings-info-box" });
      infoBox.createSpan({ text: "\u{1F4BC} This is your regular work entry type. Customize its appearance in the calendar." });
    }
    const formData = {
      id: ((_c = this.behavior) == null ? void 0 : _c.id) || "",
      label: ((_d = this.behavior) == null ? void 0 : _d.label) || "",
      icon: ((_e = this.behavior) == null ? void 0 : _e.icon) || "",
      color: ((_f = this.behavior) == null ? void 0 : _f.color) || "#b3e5fc",
      textColor: ((_g = this.behavior) == null ? void 0 : _g.textColor) || "#000000",
      negativeColor: ((_h = this.behavior) == null ? void 0 : _h.negativeColor) || "#64b5f6",
      negativeTextColor: ((_i = this.behavior) == null ? void 0 : _i.negativeTextColor) || "#ffffff",
      simpleColor: ((_j = this.behavior) == null ? void 0 : _j.simpleColor) || "#90caf9",
      simpleTextColor: ((_k = this.behavior) == null ? void 0 : _k.simpleTextColor) || "#000000",
      noHoursRequired: (_m = (_l = this.behavior) == null ? void 0 : _l.noHoursRequired) != null ? _m : false,
      flextimeEffect: ((_n = this.behavior) == null ? void 0 : _n.flextimeEffect) || "none",
      includeInStats: (_p = (_o = this.behavior) == null ? void 0 : _o.includeInStats) != null ? _p : true,
      maxDaysPerYear: ((_q = this.behavior) == null ? void 0 : _q.maxDaysPerYear) || void 0,
      countingPeriod: ((_r = this.behavior) == null ? void 0 : _r.countingPeriod) || "calendar",
      isWorkType,
      // Default to true for jobb, studie, kurs if not explicitly set
      showInTimerDropdown: (_u = (_s = this.behavior) == null ? void 0 : _s.showInTimerDropdown) != null ? _u : ["jobb", "studie", "kurs"].includes(((_t = this.behavior) == null ? void 0 : _t.id) || "")
    };
    if (!isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("ID").setDesc("Unique identifier (lowercase, no spaces). Used in holiday file format.").addText((text) => {
        text.setPlaceholder("Vacation").setValue(formData.id).onChange((value) => formData.id = value.toLowerCase().replace(/\s+/g, ""));
        if (this.behavior) {
          text.setDisabled(true);
        }
      });
    }
    new import_obsidian2.Setting(contentEl).setName("Label").setDesc("Display name shown in the dashboard").addText((text) => text.setPlaceholder(isWorkType ? "Jobb" : "Ferie").setValue(formData.label).onChange((value) => formData.label = value));
    new import_obsidian2.Setting(contentEl).setName("Icon").setDesc("Emoji to display").addText((text) => text.setPlaceholder(isWorkType ? "\u{1F4BC}" : "\u{1F3D6}\uFE0F").setValue(formData.icon).onChange((value) => formData.icon = value));
    if (isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("Positive flextime color").setDesc("Background color when hours exceed daily goal (green gradient base)").addColorPicker((color) => color.setValue(formData.color).onChange((value) => formData.color = value));
      new import_obsidian2.Setting(contentEl).setName("Positive flextime text color").setDesc("Text color for positive flextime days").addColorPicker((color) => color.setValue(formData.textColor).onChange((value) => formData.textColor = value));
      new import_obsidian2.Setting(contentEl).setName("Negative flextime color").setDesc("Background color when hours are below daily goal (blue gradient base)").addColorPicker((color) => color.setValue(formData.negativeColor).onChange((value) => formData.negativeColor = value));
      new import_obsidian2.Setting(contentEl).setName("Negative flextime text color").setDesc("Text color for negative flextime days").addColorPicker((color) => color.setValue(formData.negativeTextColor).onChange((value) => formData.negativeTextColor = value));
      contentEl.createEl("h4", { text: "Simple tracking mode colors" });
      contentEl.createDiv({
        cls: "setting-item-description tf-settings-info-box mb-10",
        text: "These colors are used when goal tracking is disabled."
      });
      new import_obsidian2.Setting(contentEl).setName("Work day color").setDesc("Background color for work days in simple tracking mode").addColorPicker((color) => color.setValue(formData.simpleColor).onChange((value) => formData.simpleColor = value));
      new import_obsidian2.Setting(contentEl).setName("Work day text color").setDesc("Text color for work days in simple tracking mode").addColorPicker((color) => color.setValue(formData.simpleTextColor).onChange((value) => formData.simpleTextColor = value));
    } else {
      new import_obsidian2.Setting(contentEl).setName("Color").setDesc("Background color for this day type in calendar").addColorPicker((color) => color.setValue(formData.color).onChange((value) => formData.color = value));
      new import_obsidian2.Setting(contentEl).setName("Text color").setDesc("Text color for this day type (use white for dark backgrounds)").addColorPicker((color) => color.setValue(formData.textColor).onChange((value) => formData.textColor = value));
    }
    if (!isWorkType) {
      new import_obsidian2.Setting(contentEl).setName("No hours required").setDesc("If enabled, you don't need to log any work hours this day (e.g., vacation, sick leave). If disabled, regular workday goal applies.").addToggle((toggle) => toggle.setValue(formData.noHoursRequired).onChange((value) => formData.noHoursRequired = value));
      new import_obsidian2.Setting(contentEl).setName("Flextime effect").setDesc("How this day type affects your flextime balance").addDropdown((dropdown) => dropdown.addOption("none", "No effect (counts as full workday)").addOption("withdraw", "Withdraw (uses flextime balance)").addOption("accumulate", "Accumulate (excess hours add to flextime)").addOption("reduce_goal", "Reduce goal (hours reduce daily goal, for sick days)").setValue(formData.flextimeEffect).onChange((value) => formData.flextimeEffect = value));
      new import_obsidian2.Setting(contentEl).setName("Include in statistics").setDesc("Show this day type in yearly statistics").addToggle((toggle) => toggle.setValue(formData.includeInStats).onChange((value) => formData.includeInStats = value));
      new import_obsidian2.Setting(contentEl).setName("Max days per year (optional)").setDesc("Yearly limit for this day type (e.g., 25 for vacation). Leave empty for no limit.").addText((text) => {
        var _a2;
        return text.setPlaceholder("25").setValue(((_a2 = formData.maxDaysPerYear) == null ? void 0 : _a2.toString()) || "").onChange((value) => {
          const num = parseInt(value);
          formData.maxDaysPerYear = isNaN(num) ? void 0 : num;
        });
      });
      new import_obsidian2.Setting(contentEl).setName("Counting period").setDesc("How to count the max days limit. The calendar year option resets each january 1st, while rolling 365 days counts backwards from today.").addDropdown((dropdown) => dropdown.addOption("calendar", "Calendar year").addOption("rolling365", "Rolling 365 days").setValue(formData.countingPeriod).onChange((value) => formData.countingPeriod = value));
    }
    new import_obsidian2.Setting(contentEl).setName("Show in timer dropdown").setDesc("Include this type in the quick-start timer menu").addToggle((toggle) => toggle.setValue(formData.showInTimerDropdown).onChange((value) => formData.showInTimerDropdown = value));
    const buttonDiv = contentEl.createDiv({ cls: "tf-settings-button-row" });
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = () => {
      if (!formData.id) {
        new import_obsidian2.Notice("\u26A0\uFE0F ID is required");
        return;
      }
      if (!formData.label) {
        new import_obsidian2.Notice("\u26A0\uFE0F a label is required");
        return;
      }
      if (!formData.icon) {
        new import_obsidian2.Notice("\u26A0\uFE0F an icon is required");
        return;
      }
      if (!this.behavior || this.behavior.id !== formData.id) {
        const isDuplicate = this.plugin.settings.specialDayBehaviors.some(
          (b, i) => b.id === formData.id && i !== this.index
        );
        if (isDuplicate) {
          new import_obsidian2.Notice("\u26A0\uFE0F an absence type with this ID already exists");
          return;
        }
      }
      const behavior = {
        id: formData.isWorkType ? this.behavior.id : formData.id,
        // Keep original ID for work types
        label: formData.label,
        icon: formData.icon,
        color: formData.color,
        textColor: formData.textColor,
        negativeColor: formData.isWorkType ? formData.negativeColor : void 0,
        negativeTextColor: formData.isWorkType ? formData.negativeTextColor : void 0,
        simpleColor: formData.isWorkType ? formData.simpleColor : void 0,
        simpleTextColor: formData.isWorkType ? formData.simpleTextColor : void 0,
        noHoursRequired: formData.isWorkType ? false : formData.noHoursRequired,
        flextimeEffect: formData.isWorkType ? "accumulate" : formData.flextimeEffect,
        includeInStats: formData.isWorkType ? true : formData.includeInStats,
        maxDaysPerYear: formData.isWorkType ? void 0 : formData.maxDaysPerYear,
        countingPeriod: formData.isWorkType ? void 0 : formData.countingPeriod,
        isWorkType: formData.isWorkType,
        showInTimerDropdown: formData.showInTimerDropdown
      };
      void this.onSave(behavior, this.index);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AnnetTemplateModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, template, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.template = template;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.template ? t("annet.editTemplate") : t("annet.addTemplate") });
    const infoBox = contentEl.createDiv({ cls: "setting-item-description tf-settings-info-box" });
    infoBox.createSpan({ text: t("annet.templateDescription") });
    const formData = {
      id: ((_a = this.template) == null ? void 0 : _a.id) || "",
      label: ((_b = this.template) == null ? void 0 : _b.label) || "",
      icon: ((_c = this.template) == null ? void 0 : _c.icon) || "\u{1F4CB}"
    };
    new import_obsidian2.Setting(contentEl).setName("ID").setDesc(t("annet.idDesc")).addText((text) => {
      text.setPlaceholder("Doctor").setValue(formData.id).onChange((value) => formData.id = value.toLowerCase().replace(/\s+/g, ""));
      if (this.template) {
        text.setDisabled(true);
      }
    });
    new import_obsidian2.Setting(contentEl).setName(t("annet.labelField")).setDesc(t("annet.labelDesc")).addText((text) => text.setPlaceholder(t("annet.labelPlaceholder")).setValue(formData.label).onChange((value) => formData.label = value));
    new import_obsidian2.Setting(contentEl).setName(t("annet.iconField")).setDesc(t("annet.iconDesc")).addText((text) => text.setPlaceholder("\u{1F3E5}").setValue(formData.icon).onChange((value) => formData.icon = value));
    const buttonDiv = contentEl.createDiv({ cls: "tf-settings-button-row" });
    const cancelBtn = buttonDiv.createEl("button", { text: t("common.cancel") });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonDiv.createEl("button", { text: t("common.save"), cls: "mod-cta" });
    saveBtn.onclick = () => {
      if (!formData.id) {
        new import_obsidian2.Notice(t("annet.idRequired"));
        return;
      }
      if (!formData.label) {
        new import_obsidian2.Notice(t("annet.labelRequired"));
        return;
      }
      if (!formData.icon) {
        new import_obsidian2.Notice(t("annet.iconRequired"));
        return;
      }
      if (!this.template) {
        const isDuplicate = this.plugin.settings.annetTemplates.some(
          (tmpl) => tmpl.id === formData.id
        );
        if (isDuplicate) {
          new import_obsidian2.Notice(t("annet.duplicateId"));
          return;
        }
      }
      const template = {
        id: this.template ? this.template.id : formData.id,
        // Keep original ID if editing
        label: formData.label,
        icon: formData.icon
      };
      void this.onSave(template, this.index);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var WorkSchedulePeriodModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, period, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.period = period;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.period ? "Edit work schedule period" : "Add work schedule period" });
    const infoBox = contentEl.createDiv({ cls: "setting-item-description tf-settings-info-box" });
    infoBox.createSpan({ text: "Define a work schedule period. Historical time entries will use the schedule that was active on their date." });
    const formData = {
      effectiveFrom: ((_a = this.period) == null ? void 0 : _a.effectiveFrom) || Utils.toLocalDateStr(/* @__PURE__ */ new Date()),
      workPercent: (_c = (_b = this.period) == null ? void 0 : _b.workPercent) != null ? _c : this.plugin.settings.workPercent,
      baseWorkday: (_e = (_d = this.period) == null ? void 0 : _d.baseWorkday) != null ? _e : this.plugin.settings.baseWorkday,
      baseWorkweek: (_g = (_f = this.period) == null ? void 0 : _f.baseWorkweek) != null ? _g : this.plugin.settings.baseWorkweek,
      workDays: ((_h = this.period) == null ? void 0 : _h.workDays) ? [...this.period.workDays] : [...this.plugin.settings.workDays],
      halfDayHours: (_j = (_i = this.period) == null ? void 0 : _i.halfDayHours) != null ? _j : this.plugin.settings.halfDayHours
    };
    let updateImpactPreview = () => {
    };
    new import_obsidian2.Setting(contentEl).setName("Effective from").setDesc("Date when this schedule becomes active (yyyy-mm-dd)").addText((text) => text.setPlaceholder("Yyyy-mm-dd").setValue(formData.effectiveFrom).onChange((value) => {
      formData.effectiveFrom = value;
      updateImpactPreview();
    }));
    new import_obsidian2.Setting(contentEl).setName("Work percentage").setDesc("Employment percentage (0-1, e.g., 0.8 = 80%)").addText((text) => text.setPlaceholder("1.0").setValue(formData.workPercent.toString()).onChange((value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) {
        formData.workPercent = num;
        updateImpactPreview();
      }
    }));
    new import_obsidian2.Setting(contentEl).setName("Base workday hours").setDesc("Standard hours for a full workday").addText((text) => text.setPlaceholder("7.5").setValue(formData.baseWorkday.toString()).onChange((value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) {
        formData.baseWorkday = num;
        updateImpactPreview();
      }
    }));
    new import_obsidian2.Setting(contentEl).setName("Base workweek hours").setDesc("Standard hours for a full workweek").addText((text) => text.setPlaceholder("37.5").setValue(formData.baseWorkweek.toString()).onChange((value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) formData.baseWorkweek = num;
    }));
    new import_obsidian2.Setting(contentEl).setName("Half-day hours").setDesc("Hours counted for a half workday").addText((text) => text.setPlaceholder("4").setValue(formData.halfDayHours.toString()).onChange((value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) formData.halfDayHours = num;
    }));
    new import_obsidian2.Setting(contentEl).setName("Work days").setDesc("Select which days are part of this work week");
    const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const workDaysContainer = contentEl.createDiv({ cls: "tf-settings-workdays-container" });
    dayNames.forEach((dayName, dayIndex) => {
      const dayButton = workDaysContainer.createEl("button", { cls: "tf-settings-day-button" });
      dayButton.textContent = dayName;
      if (formData.workDays.includes(dayIndex)) {
        dayButton.addClass("is-selected");
      }
      dayButton.onclick = () => {
        const index = formData.workDays.indexOf(dayIndex);
        if (index > -1) {
          formData.workDays.splice(index, 1);
        } else {
          formData.workDays.push(dayIndex);
          formData.workDays.sort((a, b) => a - b);
        }
        dayButton.toggleClass("is-selected", formData.workDays.includes(dayIndex));
        updateImpactPreview();
      };
    });
    const impactPreview = contentEl.createDiv({ cls: "tf-settings-impact-preview" });
    updateImpactPreview = () => {
      var _a2;
      impactPreview.empty();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(formData.effectiveFrom)) {
        impactPreview.createEl("div", {
          text: "Enter a valid date to see impact preview",
          cls: "setting-item-description"
        });
        return;
      }
      const periodDate = formData.effectiveFrom;
      const history = this.plugin.settings.workScheduleHistory || [];
      const timerManager = this.plugin.timerManager;
      if (!timerManager || !timerManager.data || !timerManager.data.entries) {
        impactPreview.createEl("div", { text: "Loading data..." });
        return;
      }
      const entries = timerManager.data.entries;
      let affectedDays = /* @__PURE__ */ new Set();
      const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
      const sortedHistory = [...history].sort((a, b) => a.effectiveFrom.localeCompare(b.effectiveFrom));
      let nextPeriodDate = null;
      for (const p of sortedHistory) {
        if (p.effectiveFrom > periodDate && (this.index === -1 || p.effectiveFrom !== ((_a2 = this.period) == null ? void 0 : _a2.effectiveFrom))) {
          nextPeriodDate = p.effectiveFrom;
          break;
        }
      }
      entries.forEach((entry) => {
        if (!entry.startTime) return;
        const entryDate = Utils.toLocalDateStr(new Date(entry.startTime));
        if (entryDate >= periodDate && (!nextPeriodDate || entryDate < nextPeriodDate)) {
          affectedDays.add(entryDate);
        }
      });
      const currentDailyGoal = this.plugin.settings.baseWorkday * this.plugin.settings.workPercent;
      const newDailyGoal = formData.baseWorkday * formData.workPercent;
      const goalDifference = newDailyGoal - currentDailyGoal;
      let oldWorkdays = 0;
      let newWorkdays = 0;
      const currentWorkDays = this.plugin.settings.workDays;
      affectedDays.forEach((dateStr) => {
        const date = new Date(dateStr);
        const dayOfWeek = date.getDay();
        if (currentWorkDays.includes(dayOfWeek)) oldWorkdays++;
        if (formData.workDays.includes(dayOfWeek)) newWorkdays++;
      });
      const title = impactPreview.createEl("div", { cls: "tf-settings-impact-title" });
      title.textContent = `Impact preview`;
      const affectedText = impactPreview.createEl("div", { cls: "tf-settings-impact-item" });
      affectedText.textContent = `\u2022 Affects ${affectedDays.size} days with existing data`;
      if (affectedDays.size > 0) {
        const workdayChange = impactPreview.createEl("div", { cls: "tf-settings-impact-item" });
        if (oldWorkdays !== newWorkdays) {
          workdayChange.textContent = `\u2022 Workdays in period: ${oldWorkdays} \u2192 ${newWorkdays}`;
        } else {
          workdayChange.textContent = `\u2022 Workdays in period: ${newWorkdays}`;
        }
        if (Math.abs(goalDifference) > 0.1) {
          const goalChange = impactPreview.createEl("div", { cls: "tf-settings-impact-item" });
          const sign = goalDifference > 0 ? "+" : "";
          goalChange.textContent = `\u2022 Daily goal: ${currentDailyGoal.toFixed(1)}h \u2192 ${newDailyGoal.toFixed(1)}h (${sign}${goalDifference.toFixed(1)}h)`;
        }
        const requiredHoursChange = (newWorkdays - oldWorkdays) * newDailyGoal + oldWorkdays * goalDifference;
        if (Math.abs(requiredHoursChange) > 0.5) {
          const changeEl = impactPreview.createEl("div", { cls: "tf-settings-impact-item" });
          const sign = requiredHoursChange > 0 ? "+" : "";
          changeEl.textContent = `\u2022 Required hours change: ${sign}${requiredHoursChange.toFixed(1)}h`;
          const balanceImpact = -requiredHoursChange;
          const balanceEl = impactPreview.createEl("div", {
            cls: balanceImpact > 0 ? "tf-settings-impact-balance-positive" : "tf-settings-impact-balance-negative"
          });
          const balanceSign = balanceImpact > 0 ? "+" : "";
          balanceEl.textContent = `\u2022 Flextime balance impact: ${balanceSign}${balanceImpact.toFixed(1)}h`;
        }
      }
      if (periodDate > today) {
        const futureNote = impactPreview.createEl("div", { cls: "tf-settings-future-note" });
        futureNote.textContent = "This is a future period - will apply from " + periodDate;
      }
    };
    updateImpactPreview();
    const buttonDiv = contentEl.createDiv({ cls: "tf-settings-button-row" });
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = () => {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(formData.effectiveFrom)) {
        new import_obsidian2.Notice("Invalid date format, use yyyy-mm-dd");
        return;
      }
      if (formData.workDays.length === 0) {
        new import_obsidian2.Notice("At least one work day is required");
        return;
      }
      if (formData.workPercent <= 0 || formData.workPercent > 2) {
        new import_obsidian2.Notice("Work percentage must be between 0 and 2");
        return;
      }
      if (formData.baseWorkday <= 0 || formData.baseWorkday > 24) {
        new import_obsidian2.Notice("Base workday must be between 0 and 24 hours");
        return;
      }
      if (formData.halfDayHours <= 0 || formData.halfDayHours > formData.baseWorkday) {
        new import_obsidian2.Notice("Half-day hours must be between 0 and base workday");
        return;
      }
      const period = {
        effectiveFrom: formData.effectiveFrom,
        workPercent: formData.workPercent,
        baseWorkday: formData.baseWorkday,
        baseWorkweek: formData.baseWorkweek,
        workDays: formData.workDays,
        halfDayHours: formData.halfDayHours
      };
      void this.onSave(period, this.index);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TimeFlowSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async refreshView() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("timeflow-view");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && typeof view.refresh === "function") {
        await view.refresh();
      }
    }
  }
  /**
   * Sync current work settings to the most recent (active) schedule period.
   * This ensures that when a user changes settings in the main Work Configuration,
   * those changes are reflected in the currently active period.
   */
  syncCurrentSettingsToActivePeriod() {
    const history = this.plugin.settings.workScheduleHistory;
    if (!history || history.length === 0) return;
    const todayStr = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    const sortedHistory = [...history].sort((a, b) => a.effectiveFrom.localeCompare(b.effectiveFrom));
    let activeIndex = -1;
    for (let i = 0; i < sortedHistory.length; i++) {
      if (sortedHistory[i].effectiveFrom <= todayStr) {
        activeIndex = i;
      } else {
        break;
      }
    }
    if (activeIndex === -1) {
      activeIndex = 0;
    }
    const activePeriod = sortedHistory[activeIndex];
    const originalIndex = history.findIndex((p) => p.effectiveFrom === activePeriod.effectiveFrom);
    if (originalIndex !== -1) {
      history[originalIndex].workPercent = this.plugin.settings.workPercent;
      history[originalIndex].baseWorkday = this.plugin.settings.baseWorkday;
      history[originalIndex].baseWorkweek = this.plugin.settings.baseWorkweek;
      history[originalIndex].workDays = [...this.plugin.settings.workDays];
      history[originalIndex].halfDayHours = this.plugin.settings.halfDayHours;
    }
  }
  addResetButton(setting, settingKey, defaultValue, refreshCallback) {
    setting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[settingKey] = defaultValue;
        await this.plugin.saveSettings();
        this.display();
        if (refreshCallback) {
          refreshCallback();
        }
      })
    );
  }
  validateNumber(value, min, max, settingName) {
    const num = parseFloat(value);
    if (isNaN(num)) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Please enter a valid number`);
      return null;
    }
    if (num < min) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Value must be at least ${min}`);
      return null;
    }
    if (num > max) {
      new import_obsidian2.Notice(`\u274C ${settingName}: Value must be at most ${max}`);
      return null;
    }
    return num;
  }
  validateDateFormat(dateStr) {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      new import_obsidian2.Notice("\u274C balance start date: format must be yyyy-mm-dd");
      return false;
    }
    const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
    if (isNaN(date.getTime())) {
      new import_obsidian2.Notice("\u274C balance start date: invalid date");
      return false;
    }
    if (date > /* @__PURE__ */ new Date()) {
      new import_obsidian2.Notice("\u274C balance start date: cannot be in the future");
      return false;
    }
    return true;
  }
  createCollapsibleSubsection(container, title, startOpen = false) {
    const header = container.createDiv({
      cls: startOpen ? "tf-collapsible-subsection open" : "tf-collapsible-subsection"
    });
    header.createSpan({ text: title });
    const content = container.createDiv({
      cls: startOpen ? "tf-collapsible-content open" : "tf-collapsible-content"
    });
    header.onclick = () => {
      header.classList.toggle("open");
      content.classList.toggle("open");
    };
    return { header, content };
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const searchContainer = containerEl.createDiv({ cls: "tf-settings-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u{1F50D} Search settings...",
      cls: "tf-search-input"
    });
    const settingsContainer = containerEl.createDiv({ cls: "tf-settings-container" });
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase();
      const allSettings = settingsContainer.querySelectorAll(".setting-item");
      allSettings.forEach((setting) => {
        var _a, _b, _c, _d;
        const name = ((_b = (_a = setting.querySelector(".setting-item-name")) == null ? void 0 : _a.textContent) == null ? void 0 : _b.toLowerCase()) || "";
        const desc = ((_d = (_c = setting.querySelector(".setting-item-description")) == null ? void 0 : _c.textContent) == null ? void 0 : _d.toLowerCase()) || "";
        if (name.includes(query) || desc.includes(query)) {
          setting.removeClass("tf-hidden");
        } else {
          setting.addClass("tf-hidden");
        }
      });
    });
    new import_obsidian2.Setting(settingsContainer).setName("Quick start").setDesc("Essential settings to get started with timeflow").setHeading();
    const syncInfo = settingsContainer.createDiv({ cls: "tf-settings-info-box" });
    syncInfo.createEl("strong", { text: "\u{1F4F1} cross-device settings sync" });
    syncInfo.createEl("br");
    syncInfo.appendText("Settings are automatically saved to ");
    syncInfo.createEl("code", { text: "timeflow/data.md" });
    syncInfo.appendText(" and will sync across devices when using Obsidian Sync or any other vault sync solution. When you open the plugin on another device, your settings will be automatically loaded.");
    new import_obsidian2.Setting(settingsContainer).setName("Language").setDesc("Interface language").addDropdown((dropdown) => dropdown.addOption("nb", "Norsk").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      setLanguage(value);
      await this.plugin.saveSettings();
      this.display();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Data file path").setDesc("Path to the file containing timer data and settings").addText((text) => text.setPlaceholder("timeflow/data.md").setValue(this.plugin.settings.dataFilePath).onChange(async (value) => {
      this.plugin.settings.dataFilePath = value;
      await this.plugin.saveSettings();
      this.plugin.timerManager.dataFile = value;
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Holidays file path").setDesc("Path to the file containing future planned days/holidays").addText((text) => text.setPlaceholder("timeflow/holidays.md").setValue(this.plugin.settings.holidaysFilePath).onChange(async (value) => {
      this.plugin.settings.holidaysFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName(t("settings.startingFlextimeBalance")).setDesc(t("settings.startingFlextimeBalanceDesc")).addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.startingFlextimeBalance.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num)) {
        this.plugin.settings.startingFlextimeBalance = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Work configuration").setDesc("Configure your work schedule and goals").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Enable goal tracking").setDesc("Enable flextime calculations and daily/weekly goals. Disable for simple hour tracking without goals (e.g., shift workers, freelancers).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableGoalTracking).onChange(async (value) => {
      this.plugin.settings.enableGoalTracking = value;
      await this.plugin.saveSettings();
      this.display();
      await this.refreshView();
    }));
    if (this.plugin.settings.enableGoalTracking) {
      new import_obsidian2.Setting(settingsContainer).setName("Base workday hours").setDesc("Standard hours for a full workday (e.g., 7.5 for standard, 6 for 6-hour days)").addText((text) => text.setPlaceholder("7.5").setValue(this.plugin.settings.baseWorkday.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.baseWorkday = num;
          this.syncCurrentSettingsToActivePeriod();
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      new import_obsidian2.Setting(settingsContainer).setName("Enable weekly goals").setDesc("Disable if you don't have a specific amount of work each week. This will hide goal progress bars and weekly targets.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWeeklyGoals).onChange(async (value) => {
        this.plugin.settings.enableWeeklyGoals = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableWeeklyGoals) {
        new import_obsidian2.Setting(settingsContainer).setName("Work percentage").setDesc("Your employment percentage. Adjusts weekly work goal. Example: 0.8 (80%) = 30h/week if base is 37.5h").addText((text) => text.setPlaceholder("1.0").setValue(this.plugin.settings.workPercent.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0 && num <= 1) {
            this.plugin.settings.workPercent = num;
            this.syncCurrentSettingsToActivePeriod();
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
        new import_obsidian2.Setting(settingsContainer).setName("Base workweek hours").setDesc("Standard hours for a full workweek (e.g., 37.5 for 5 days, 30 for 4 days)").addText((text) => text.setPlaceholder("37.5").setValue(this.plugin.settings.baseWorkweek.toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.baseWorkweek = num;
            this.syncCurrentSettingsToActivePeriod();
            await this.plugin.saveSettings();
            await this.refreshView();
          }
        }));
      }
      new import_obsidian2.Setting(settingsContainer).setName("Lunch break duration").setDesc("Daily lunch break in minutes (e.g., 30 for 30 minutes). This will be deducted from your work hours automatically.").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.lunchBreakMinutes.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.lunchBreakMinutes = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
      const dayNames2 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      new import_obsidian2.Setting(settingsContainer).setName("Work days").setDesc("Select which days are part of your work week");
      const workDaysContainer = settingsContainer.createDiv({ cls: "tf-settings-workdays-container" });
      dayNames2.forEach((dayName, dayIndex) => {
        const dayButton = workDaysContainer.createEl("button", { cls: "tf-settings-day-button" });
        dayButton.textContent = dayName.substring(0, 3);
        if (this.plugin.settings.workDays.includes(dayIndex)) {
          dayButton.addClass("is-selected");
        }
        dayButton.onclick = async () => {
          const currentWorkDays = [...this.plugin.settings.workDays];
          const index = currentWorkDays.indexOf(dayIndex);
          if (index > -1) {
            currentWorkDays.splice(index, 1);
          } else {
            currentWorkDays.push(dayIndex);
            currentWorkDays.sort((a, b) => a - b);
          }
          this.plugin.settings.workDays = currentWorkDays;
          this.syncCurrentSettingsToActivePeriod();
          await this.plugin.saveSettings();
          dayButton.toggleClass("is-selected", currentWorkDays.includes(dayIndex));
        };
      });
      new import_obsidian2.Setting(settingsContainer).setName("Enable alternating weeks").setDesc("Enable if you have different work days in alternating weeks (e.g., every other weekend)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAlternatingWeeks).onChange(async (value) => {
        this.plugin.settings.enableAlternatingWeeks = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableAlternatingWeeks) {
        new import_obsidian2.Setting(settingsContainer).setName("Alternating week work days").setDesc("Select which days are work days in the alternating week");
        const altWorkDaysContainer = settingsContainer.createDiv({ cls: "tf-settings-workdays-container" });
        dayNames2.forEach((dayName, dayIndex) => {
          const dayButton = altWorkDaysContainer.createEl("button", { cls: "tf-settings-day-button" });
          dayButton.textContent = dayName.substring(0, 3);
          if (this.plugin.settings.alternatingWeekWorkDays.includes(dayIndex)) {
            dayButton.addClass("is-selected");
          }
          dayButton.onclick = async () => {
            const currentAltWorkDays = [...this.plugin.settings.alternatingWeekWorkDays];
            const index = currentAltWorkDays.indexOf(dayIndex);
            if (index > -1) {
              currentAltWorkDays.splice(index, 1);
            } else {
              currentAltWorkDays.push(dayIndex);
              currentAltWorkDays.sort((a, b) => a - b);
            }
            this.plugin.settings.alternatingWeekWorkDays = currentAltWorkDays;
            await this.plugin.saveSettings();
            dayButton.toggleClass("is-selected", currentAltWorkDays.includes(dayIndex));
          };
        });
      }
    }
    const scheduleHistorySection = this.createCollapsibleSubsection(
      settingsContainer,
      "Work schedule history",
      false
    );
    const scheduleHistoryInfo = scheduleHistorySection.content.createDiv({ cls: "tf-settings-info-box" });
    scheduleHistoryInfo.createEl("strong", { text: "Track changes to your work schedule" });
    scheduleHistoryInfo.createEl("br");
    scheduleHistoryInfo.appendText("If you change roles or work hours, add a new period to preserve accurate historical calculations. ");
    scheduleHistoryInfo.appendText("Each period defines the schedule that was active from its effective date.");
    const scheduleHistory = [...this.plugin.settings.workScheduleHistory || []];
    scheduleHistory.sort((a, b) => b.effectiveFrom.localeCompare(a.effectiveFrom));
    const currentSettingsInfo = scheduleHistorySection.content.createDiv({ cls: "tf-settings-current-info" });
    const currentLabel = currentSettingsInfo.createEl("div", { cls: "tf-settings-current-label" });
    currentLabel.textContent = "Current settings (active)";
    const currentDetails = currentSettingsInfo.createEl("div", { cls: "tf-settings-current-details" });
    const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const currentWorkDaysStr = this.plugin.settings.workDays.map((d) => dayNames[d]).join(", ");
    currentDetails.textContent = `${(this.plugin.settings.workPercent * 100).toFixed(0)}% \xB7 ${this.plugin.settings.baseWorkday}h/day \xB7 ${this.plugin.settings.baseWorkweek}h/week \xB7 ${currentWorkDaysStr}`;
    if (scheduleHistory.length > 0) {
      scheduleHistory.forEach((period, arrayIndex) => {
        const originalIndex = this.plugin.settings.workScheduleHistory.findIndex(
          (p) => p.effectiveFrom === period.effectiveFrom
        );
        const periodDiv = scheduleHistorySection.content.createDiv({ cls: "tf-settings-period-item" });
        const infoDiv = periodDiv.createDiv();
        const dateLabel = infoDiv.createEl("div", { cls: "tf-settings-period-date" });
        dateLabel.textContent = `From ${period.effectiveFrom}`;
        const details = infoDiv.createEl("div", { cls: "tf-settings-period-details" });
        const workDaysStr = period.workDays.map((d) => dayNames[d]).join(", ");
        details.textContent = `${(period.workPercent * 100).toFixed(0)}% \xB7 ${period.baseWorkday}h/day \xB7 ${period.baseWorkweek}h/week \xB7 ${workDaysStr}`;
        const buttonsDiv = periodDiv.createDiv({ cls: "tf-settings-period-buttons" });
        const editBtn = buttonsDiv.createEl("button", { text: "Edit" });
        editBtn.onclick = () => {
          new WorkSchedulePeriodModal(
            this.app,
            this.plugin,
            period,
            originalIndex,
            async (updatedPeriod, idx) => {
              this.plugin.settings.workScheduleHistory[idx] = updatedPeriod;
              this.plugin.settings.workScheduleHistory.sort((a, b) => a.effectiveFrom.localeCompare(b.effectiveFrom));
              await this.plugin.saveSettings();
              await this.refreshView();
              this.display();
            }
          ).open();
        };
        if (scheduleHistory.length > 1) {
          const deleteBtn = buttonsDiv.createEl("button", { text: "Delete", cls: "tf-settings-delete-btn" });
          deleteBtn.onclick = () => {
            new ConfirmModal(this.app, `Delete schedule period from ${period.effectiveFrom}?`, async () => {
              this.plugin.settings.workScheduleHistory.splice(originalIndex, 1);
              await this.plugin.saveSettings();
              await this.refreshView();
              this.display();
            }).open();
          };
        }
      });
    } else {
      const noPeriods = scheduleHistorySection.content.createDiv({ cls: "tf-settings-no-periods" });
      noPeriods.textContent = "No historical periods defined. Add a period when your schedule changes.";
    }
    new import_obsidian2.Setting(scheduleHistorySection.content).setName("Add historical period").setDesc("Add a period for when your work schedule was different").addButton((btn) => btn.setButtonText("+ add period").setCta().onClick(() => {
      new WorkSchedulePeriodModal(
        this.app,
        this.plugin,
        null,
        -1,
        async (newPeriod) => {
          if (!this.plugin.settings.workScheduleHistory) {
            this.plugin.settings.workScheduleHistory = [];
          }
          this.plugin.settings.workScheduleHistory.push(newPeriod);
          this.plugin.settings.workScheduleHistory.sort((a, b) => a.effectiveFrom.localeCompare(b.effectiveFrom));
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      ).open();
    }));
    const complianceSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Work time limits",
      false
    );
    complianceSection.content.addClass("tf-compliance-settings");
    new import_obsidian2.Setting(complianceSection.content).setName("Enable compliance warnings").setDesc("Show warnings when approaching or exceeding labor law limits").addToggle((toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) != null ? _b : true).onChange(async (value) => {
        if (!this.plugin.settings.complianceSettings) {
          this.plugin.settings.complianceSettings = {
            enableWarnings: true,
            dailyHoursLimit: 9,
            weeklyHoursLimit: 40,
            minimumRestHours: 11
          };
        }
        this.plugin.settings.complianceSettings.enableWarnings = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Daily hours limit").setDesc("Maximum hours per day before showing a warning (default: 9 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("9").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.dailyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Weekly hours limit").setDesc("Maximum hours per week before showing a warning (default: 40 hours)").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("40").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.weeklyHoursLimit) != null ? _b : 40).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.weeklyHoursLimit = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName("Rest-period").setDesc("Default 11 hours").addText((text) => {
      var _a, _b;
      return text.setPlaceholder("11").setValue(((_b = (_a = this.plugin.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11).toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          if (!this.plugin.settings.complianceSettings) {
            this.plugin.settings.complianceSettings = {
              enableWarnings: true,
              dailyHoursLimit: 9,
              weeklyHoursLimit: 40,
              minimumRestHours: 11
            };
          }
          this.plugin.settings.complianceSettings.minimumRestHours = num;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      });
    });
    new import_obsidian2.Setting(complianceSection.content).setName(t("settings.enableOvertimeComments")).setDesc(t("settings.enableOvertimeCommentsDesc")).addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.enableOvertimeComments) != null ? _a : false).onChange(async (value) => {
        this.plugin.settings.enableOvertimeComments = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.enableOvertimeComments) {
      new import_obsidian2.Setting(complianceSection.content).setName(t("settings.overtimeCommentThreshold")).setDesc(t("settings.overtimeCommentThresholdDesc")).addText((text) => {
        var _a;
        return text.setPlaceholder("0.5").setValue(((_a = this.plugin.settings.overtimeCommentThreshold) != null ? _a : 0.5).toString()).onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num >= 0 && num <= 5) {
            this.plugin.settings.overtimeCommentThreshold = num;
            await this.plugin.saveSettings();
          }
        });
      });
      new import_obsidian2.Setting(complianceSection.content).setName(t("settings.overtimeCommentEffectiveDate")).setDesc(t("settings.overtimeCommentEffectiveDateDesc")).addText((text) => {
        var _a;
        return text.setPlaceholder("2025-01-01").setValue((_a = this.plugin.settings.overtimeCommentEffectiveDate) != null ? _a : "2025-01-01").onChange(async (value) => {
          if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
              this.plugin.settings.overtimeCommentEffectiveDate = value;
              await this.plugin.saveSettings();
            }
          }
        });
      });
    }
    const getBehaviorDescription = (behavior) => {
      const parts = [];
      if (behavior.isWorkType) {
        parts.push("Regular work entry");
      } else {
        parts.push(behavior.noHoursRequired ? "No hours required" : "Regular workday applies");
      }
      if (behavior.flextimeEffect === "withdraw") {
        parts.push("withdraws from flextime");
      } else if (behavior.flextimeEffect === "accumulate") {
        parts.push("excess counts as flextime");
      } else {
        parts.push("no flextime change");
      }
      if (behavior.maxDaysPerYear) {
        parts.push(`max ${behavior.maxDaysPerYear} days/year`);
      }
      return parts.join(", ");
    };
    const workTypes = this.plugin.settings.specialDayBehaviors.filter((b) => b.isWorkType || b.id === "jobb");
    const absenceTypes = this.plugin.settings.specialDayBehaviors.filter((b) => !b.isWorkType && b.id !== "jobb");
    new import_obsidian2.Setting(settingsContainer).setName("Work entry type").setDesc("Configure the appearance of your regular work entries").setHeading();
    workTypes.forEach((behavior) => {
      const index = this.plugin.settings.specialDayBehaviors.findIndex((b) => b.id === behavior.id);
      new import_obsidian2.Setting(settingsContainer).setName(`${behavior.icon} ${behavior.label}`).setDesc(getBehaviorDescription(behavior)).addButton((btn) => btn.setButtonText("Edit").onClick(() => {
        new SpecialDayBehaviorModal(
          this.app,
          this.plugin,
          behavior,
          index,
          async (updatedBehavior, idx) => {
            this.plugin.settings.specialDayBehaviors[idx] = updatedBehavior;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName("Absence types").setDesc(t("settings.absenceTypesDesc")).setHeading();
    absenceTypes.forEach((behavior) => {
      const index = this.plugin.settings.specialDayBehaviors.findIndex((b) => b.id === behavior.id);
      new import_obsidian2.Setting(settingsContainer).setName(`${behavior.icon} ${behavior.label}`).setDesc(getBehaviorDescription(behavior)).addButton((btn) => btn.setButtonText("Edit").onClick(() => {
        new SpecialDayBehaviorModal(
          this.app,
          this.plugin,
          behavior,
          index,
          async (updatedBehavior, idx) => {
            this.plugin.settings.specialDayBehaviors[idx] = updatedBehavior;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      })).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(() => {
        new ConfirmModal(
          this.app,
          `Are you sure you want to delete "${behavior.label}"?

Note: Historical data in your holidays file using "${behavior.id}" will no longer be recognized.`,
          async () => {
            this.plugin.settings.specialDayBehaviors.splice(index, 1);
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName(t("settings.addAbsenceType")).addButton((btn) => btn.setButtonText("+ " + t("common.add")).setCta().onClick(() => {
      new SpecialDayBehaviorModal(
        this.app,
        this.plugin,
        null,
        // New absence type
        this.plugin.settings.specialDayBehaviors.length,
        // Index at end
        async (newBehavior) => {
          this.plugin.settings.specialDayBehaviors.push(newBehavior);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      ).open();
    }));
    new import_obsidian2.Setting(settingsContainer).setName(t("annet.templatesSection")).setDesc(t("annet.templatesDesc")).setHeading();
    this.plugin.settings.annetTemplates.forEach((template, index) => {
      const translatedName = translateAnnetTemplateName(template.id, template.label);
      new import_obsidian2.Setting(settingsContainer).setName(`${template.icon} ${translatedName}`).setDesc(`ID: ${template.id}`).addButton((btn) => btn.setButtonText(t("common.edit")).onClick(() => {
        new AnnetTemplateModal(
          this.app,
          this.plugin,
          template,
          index,
          async (updatedTemplate, idx) => {
            this.plugin.settings.annetTemplates[idx] = updatedTemplate;
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      })).addButton((btn) => btn.setButtonText(t("common.delete")).setWarning().onClick(() => {
        new ConfirmModal(
          this.app,
          `Are you sure you want to delete "${translatedName}"?

Note: Historical data using "annet:${template.id}" will still work but show a generic icon.`,
          async () => {
            this.plugin.settings.annetTemplates.splice(index, 1);
            await this.plugin.saveSettings();
            await this.refreshView();
            this.display();
          }
        ).open();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName(t("annet.addTemplate")).addButton((btn) => btn.setButtonText("+ " + t("common.add")).setCta().onClick(() => {
      new AnnetTemplateModal(
        this.app,
        this.plugin,
        null,
        // New template
        this.plugin.settings.annetTemplates.length,
        // Index at end
        async (newTemplate) => {
          this.plugin.settings.annetTemplates.push(newTemplate);
          await this.plugin.saveSettings();
          await this.refreshView();
          this.display();
        }
      ).open();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Display & interface").setDesc("Customize the appearance and behavior of the timeflow interface").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Default view location").setDesc("Choose where timeflow opens by default").addDropdown((dropdown) => dropdown.addOption("sidebar", "Sidebar (right panel)").addOption("main", "Main area (as a tab)").setValue(this.plugin.settings.defaultViewLocation).onChange(async (value) => {
      this.plugin.settings.defaultViewLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Hour unit").setDesc('Choose the unit symbol for displaying hours: "h" for hours or "t" for timer').addDropdown((dropdown) => dropdown.addOption("h", "H").addOption("t", "T").setValue(this.plugin.settings.hourUnit).onChange(async (value) => {
      this.plugin.settings.hourUnit = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Show week numbers").setDesc("Show week numbers in calendar and week card").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.showWeekNumbers) != null ? _a : true).onChange(async (value) => {
        this.plugin.settings.showWeekNumbers = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian2.Setting(settingsContainer).setName(t("settings.hideEmptyStats")).setDesc(t("settings.hideEmptyStatsDesc")).addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.hideEmptyStats) != null ? _a : false).onChange(async (value) => {
        this.plugin.settings.hideEmptyStats = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    new import_obsidian2.Setting(settingsContainer).setName("Consecutive flextime warning days").setDesc("Number of consecutive days with flextime before showing a warning").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.consecutiveFlextimeWarningDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.consecutiveFlextimeWarningDays = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Heatmap columns").setDesc("Number of columns in the heatmap view (adjust for your screen width)").addText((text) => text.setPlaceholder("48").setValue(this.plugin.settings.heatmapColumns.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.heatmapColumns = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Heatmap absence colors").setDesc("Show absence colors (ferie, egenmelding, etc.) instead of flextime gradient in heatmap").addToggle((toggle) => toggle.setValue(this.plugin.settings.heatmapShowSpecialDayColors).onChange(async (value) => {
      this.plugin.settings.heatmapShowSpecialDayColors = value;
      await this.plugin.saveSettings();
      await this.refreshView();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Update interval (seconds)").setDesc("How often to update the dashboard data (in seconds)").addText((text) => text.setPlaceholder("30").setValue(this.plugin.settings.updateInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1) {
        this.plugin.settings.updateInterval = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(settingsContainer).setName("File paths & templates").setDesc("Configure file paths and note templates").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Daily notes folder").setDesc("Folder where daily notes are stored").addText((text) => text.setPlaceholder("Daily notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
      this.plugin.settings.dailyNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Daily notes template path").setDesc("Path to the template for daily notes").addText((text) => text.setPlaceholder("Templates/Daily Notes Template.md").setValue(this.plugin.settings.dailyNotesTemplatePath).onChange(async (value) => {
      this.plugin.settings.dailyNotesTemplatePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Note types").setDesc("Configure the types of notes available in the calendar context menu. Each note type can have its own template, folder, and filename pattern.").setHeading();
    this.plugin.settings.noteTypes.forEach((noteType, index) => {
      new import_obsidian2.Setting(settingsContainer).setName(`${noteType.icon} ${noteType.label}`).setDesc(`Folder: ${noteType.folder} | Template: ${noteType.template}`).addButton((button) => button.setButtonText("Edit").onClick(() => {
        this.showNoteTypeModal(noteType, index);
      })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        this.plugin.settings.noteTypes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.refreshView();
        this.display();
      }));
    });
    new import_obsidian2.Setting(settingsContainer).setName("Add new note type").setDesc("Create a new note type for the context menu").addButton((button) => button.setButtonText("+ add note type").setCta().onClick(() => {
      this.showNoteTypeModal(null, -1);
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Data management").setDesc("Import and export your time tracking data").setHeading();
    new import_obsidian2.Setting(settingsContainer).setName("Export data to CSV").setDesc("Export all your time tracking data to a CSV file").addButton((button) => button.setButtonText("Export CSV").setCta().onClick(() => {
      this.exportToCSV();
    }));
    new import_obsidian2.Setting(settingsContainer).setName(t("settings.importData")).setDesc(t("settings.importDataDesc")).addButton((button) => button.setButtonText(t("settings.importData")).setCta().onClick(() => {
      this.showImportModal();
    }));
    new import_obsidian2.Setting(settingsContainer).setName("Advanced").setDesc("Fine-tune balance calculations, thresholds, and visual customization").setHeading();
    const advancedInfo = settingsContainer.createDiv({ cls: "tf-settings-info-box" });
    advancedInfo.createEl("strong", { text: "\u2699\uFE0F advanced configuration" });
    advancedInfo.createEl("br");
    advancedInfo.appendText("These settings affect balance calculations and visual indicators. Settings sync across devices via your data file.");
    const balanceCalcSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance calculation",
      false
    );
    new import_obsidian2.Setting(balanceCalcSection.content).setName("Balance start date").setDesc("Set the date from which flextime balance is calculated. Earlier entries are ignored in balance calculations. Format: yyyy-mm-dd").addText((text) => text.setPlaceholder("2025-01-01").setValue(this.plugin.settings.balanceStartDate).onChange(async (value) => {
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          this.plugin.settings.balanceStartDate = value;
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }
    }));
    new import_obsidian2.Setting(balanceCalcSection.content).setName("Half-day calculation mode").setDesc("How half-day hours should be calculated").addDropdown((dropdown) => dropdown.addOption("fixed", "Fixed hours (set specific value)").addOption("percentage", "Percentage (half of base workday)").setValue(this.plugin.settings.halfDayMode).onChange(async (value) => {
      this.plugin.settings.halfDayMode = value;
      await this.plugin.saveSettings();
      await this.refreshView();
      this.display();
    }));
    if (this.plugin.settings.halfDayMode === "fixed") {
      new import_obsidian2.Setting(balanceCalcSection.content).setName("Half-day hours").setDesc("Hours counted for a half workday").addText((text) => text.setPlaceholder("4.0").setValue(this.plugin.settings.halfDayHours.toString()).onChange(async (value) => {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0 && num < this.plugin.settings.baseWorkday) {
          this.plugin.settings.halfDayHours = num;
          this.syncCurrentSettingsToActivePeriod();
          await this.plugin.saveSettings();
          await this.refreshView();
        }
      }));
    }
    const balanceThresholdsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Balance color thresholds",
      false
    );
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Balance color thresholds").setDesc("Configure the hour thresholds for balance indicator colors. These control the color-coding of your flextime balance badge: red = significant under/overtime, yellow = approaching limits, green = healthy balance.");
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Critical low threshold (red)").setDesc("Below this many hours = red badge (significant undertime)").addText((text) => text.setPlaceholder("-15").setValue(this.plugin.settings.balanceThresholds.criticalLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num < this.plugin.settings.balanceThresholds.warningLow) {
        this.plugin.settings.balanceThresholds.criticalLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Warning low threshold (yellow)").setDesc("Below this = yellow badge (approaching undertime)").addText((text) => text.setPlaceholder("0").setValue(this.plugin.settings.balanceThresholds.warningLow.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.criticalLow && num < this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.warningLow = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Warning high threshold (yellow)").setDesc("Above this = yellow badge (approaching overtime limit)").addText((text) => text.setPlaceholder("80").setValue(this.plugin.settings.balanceThresholds.warningHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningLow && num < this.plugin.settings.balanceThresholds.criticalHigh) {
        this.plugin.settings.balanceThresholds.warningHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    new import_obsidian2.Setting(balanceThresholdsSection.content).setName("Critical high threshold (red)").setDesc("Above this = red badge (significant overtime accumulation)").addText((text) => text.setPlaceholder("95").setValue(this.plugin.settings.balanceThresholds.criticalHigh.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > this.plugin.settings.balanceThresholds.warningHigh) {
        this.plugin.settings.balanceThresholds.criticalHigh = num;
        await this.plugin.saveSettings();
        await this.refreshView();
      }
    }));
    const dataValidationSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Data validation thresholds",
      false
    );
    new import_obsidian2.Setting(dataValidationSection.content).setName("Data validation thresholds").setDesc("Automatic data quality checks. Adjust these if you frequently work long hours or want stricter validation.");
    new import_obsidian2.Setting(dataValidationSection.content).setName("Long-running timer warning (hours)").setDesc("Warn if a timer runs more than X hours without being stopped (default: 12)").addText((text) => text.setPlaceholder("12").setValue(this.plugin.settings.validationThresholds.longRunningTimerHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.longRunningTimerHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("Very long session warning (hours)").setDesc("Warn if a work session exceeds X hours (default: 16)").addText((text) => text.setPlaceholder("16").setValue(this.plugin.settings.validationThresholds.veryLongSessionHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.veryLongSessionHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("Maximum session duration (hours)").setDesc("Prevent entries longer than X hours - likely a data error (default: 24)").addText((text) => text.setPlaceholder("24").setValue(this.plugin.settings.validationThresholds.maxDurationHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.maxDurationHours = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(dataValidationSection.content).setName("High weekly total info (hours)").setDesc("Show info notice if weekly total exceeds X hours (default: 60)").addText((text) => text.setPlaceholder("60").setValue(this.plugin.settings.validationThresholds.highWeeklyTotalHours.toString()).onChange(async (value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.validationThresholds.highWeeklyTotalHours = num;
        await this.plugin.saveSettings();
      }
    }));
    const customColorsSection = this.createCollapsibleSubsection(
      settingsContainer,
      "Custom colors",
      false
    );
    const balanceOkSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance OK color").setDesc("Color when flextime balance is in acceptable range").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceOk) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceOkSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceOk = DEFAULT_SETTINGS.customColors.balanceOk;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceWarningSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance warning color").setDesc("Color when flextime balance is approaching limits").addText((text) => {
      var _a;
      return text.setPlaceholder("#ff9800").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceWarning) || "#ff9800").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceWarningSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceWarning = DEFAULT_SETTINGS.customColors.balanceWarning;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const balanceCriticalSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Balance critical color").setDesc("Color when flextime balance is critically out of range").addText((text) => {
      var _a;
      return text.setPlaceholder("#f44336").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.balanceCritical) || "#f44336").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    balanceCriticalSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.balanceCritical = DEFAULT_SETTINGS.customColors.balanceCritical;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
    const progressBarSetting = new import_obsidian2.Setting(customColorsSection.content).setName("Progress bar color").setDesc("Color for progress bars showing daily/weekly completion").addText((text) => {
      var _a;
      return text.setPlaceholder("#4caf50").setValue(((_a = this.plugin.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50").onChange(async (value) => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = value;
        await this.plugin.saveSettings();
        await this.refreshView();
      });
    });
    progressBarSetting.addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        if (!this.plugin.settings.customColors) {
          this.plugin.settings.customColors = {};
        }
        this.plugin.settings.customColors.progressBar = DEFAULT_SETTINGS.customColors.progressBar;
        await this.plugin.saveSettings();
        this.display();
        await this.refreshView();
      })
    );
  }
  exportToCSV() {
    const entries = this.plugin.timerManager.data.entries;
    const availableMonths = [];
    entries.forEach((entry) => {
      if (entry.startTime) {
        const yearMonth = entry.startTime.substring(0, 7);
        if (!availableMonths.includes(yearMonth)) {
          availableMonths.push(yearMonth);
        }
      }
    });
    if (availableMonths.length === 0) {
      new import_obsidian2.Notice(t("export.noData"));
      return;
    }
    availableMonths.sort().reverse();
    const now = /* @__PURE__ */ new Date();
    const currentYearMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    const defaultMonth = availableMonths.includes(currentYearMonth) ? currentYearMonth : availableMonths[0];
    const overlay = document.createElement("div");
    overlay.className = "modal-container mod-dim";
    const modal = document.createElement("div");
    modal.className = "modal tf-export-modal";
    const title = document.createElement("h3");
    title.className = "tf-export-modal-title";
    title.textContent = t("export.selectMonth");
    modal.appendChild(title);
    const selectContainer = document.createElement("div");
    selectContainer.className = "tf-export-select-container";
    const label = document.createElement("label");
    label.textContent = t("export.month") + ":";
    selectContainer.appendChild(label);
    const select = document.createElement("select");
    select.className = "tf-export-select";
    const allOption = document.createElement("option");
    allOption.value = "all";
    allOption.textContent = t("export.allMonths");
    select.appendChild(allOption);
    availableMonths.forEach((yearMonth) => {
      const [year, month] = yearMonth.split("-").map(Number);
      const monthName = getMonthName(new Date(year, month - 1, 1));
      const option = document.createElement("option");
      option.value = yearMonth;
      option.textContent = monthName;
      if (yearMonth === defaultMonth) option.selected = true;
      select.appendChild(option);
    });
    selectContainer.appendChild(select);
    modal.appendChild(selectContainer);
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-export-buttons";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => overlay.remove();
    buttonDiv.appendChild(cancelBtn);
    const exportBtn = document.createElement("button");
    exportBtn.className = "mod-cta";
    exportBtn.textContent = `\u{1F4E5} ${t("buttons.export")}`;
    exportBtn.onclick = () => {
      const selectedMonth = select.value;
      overlay.remove();
      this.downloadMonthCSV(selectedMonth, entries);
    };
    buttonDiv.appendChild(exportBtn);
    modal.appendChild(buttonDiv);
    overlay.appendChild(modal);
    overlay.onclick = (e) => {
      if (e.target === overlay) overlay.remove();
    };
    document.body.appendChild(overlay);
  }
  downloadMonthCSV(yearMonth, allEntries) {
    const BOM = "\uFEFF";
    let csvContent = "";
    let filename;
    let noticeText;
    if (yearMonth === "all") {
      const availableMonths = [];
      allEntries.forEach((entry) => {
        if (entry.startTime) {
          const ym = entry.startTime.substring(0, 7);
          if (!availableMonths.includes(ym)) availableMonths.push(ym);
        }
      });
      availableMonths.sort().reverse();
      if (availableMonths.length === 0) {
        new import_obsidian2.Notice(t("export.noData"));
        return;
      }
      availableMonths.forEach((ym, index) => {
        if (index > 0) csvContent += "\n\n";
        csvContent += this.generateMonthCSV(ym, allEntries);
      });
      filename = `timeflow-${t("export.allMonths").toLowerCase().replace(/\s+/g, "-")}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
      noticeText = t("export.allMonths");
    } else {
      csvContent = this.generateMonthCSV(yearMonth, allEntries);
      if (!csvContent) {
        new import_obsidian2.Notice(t("export.noData"));
        return;
      }
      const [year, month] = yearMonth.split("-").map(Number);
      filename = `timeflow-${yearMonth}.csv`;
      noticeText = getMonthName(new Date(year, month - 1, 1));
    }
    const blob = new Blob([BOM + csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
    new import_obsidian2.Notice(`\u2705 ${t("export.success")}: ${noticeText}`);
  }
  generateMonthCSV(yearMonth, allEntries) {
    const [year, month] = yearMonth.split("-").map(Number);
    const monthEntries = allEntries.filter((entry) => {
      if (!entry.startTime) return false;
      return entry.startTime.startsWith(yearMonth);
    });
    if (monthEntries.length === 0) return "";
    const monthName = getMonthName(new Date(year, month - 1, 1));
    let csvContent = "";
    csvContent += `"${monthName}"

`;
    csvContent += `"${t("export.date")}","${t("export.type")}","${t("export.start")}","${t("export.end")}","${t("export.hours")}","${t("export.comment")}"
`;
    const sortedEntries = [...monthEntries].sort((a, b) => {
      const dateA = a.startTime || "";
      const dateB = b.startTime || "";
      return dateA.localeCompare(dateB);
    });
    sortedEntries.forEach((entry) => {
      if (!entry.startTime || !entry.endTime) return;
      const startDate = new Date(entry.startTime);
      const endDate = new Date(entry.endTime);
      const dateStr = Utils.toLocalDateStr(startDate);
      const startTime = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
      const endTime = `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}`;
      const hours = ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(2);
      const comment = entry.comment || "";
      const escapedComment = comment.replace(/"/g, '""');
      const typeName = translateSpecialDayName(entry.name.toLowerCase(), entry.name);
      csvContent += `"${dateStr}","${typeName}","${startTime}","${endTime}","${hours}","${escapedComment}"
`;
    });
    let totalHours = 0;
    let workDays = 0;
    const daysWithEntries = /* @__PURE__ */ new Set();
    sortedEntries.forEach((entry) => {
      if (entry.startTime && entry.endTime) {
        const startDate = new Date(entry.startTime);
        const endDate = new Date(entry.endTime);
        totalHours += (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
        daysWithEntries.add(Utils.toLocalDateStr(startDate));
      }
    });
    workDays = daysWithEntries.size;
    csvContent += "\n";
    csvContent += `"${t("export.monthlySummary")}"
`;
    csvContent += `"${t("export.totalHours")}","${totalHours.toFixed(2)}"
`;
    csvContent += `"${t("export.workDays")}","${workDays}"
`;
    csvContent += `"${t("export.avgDaily")}","${workDays > 0 ? (totalHours / workDays).toFixed(2) : "0.00"}"
`;
    csvContent += "\n";
    csvContent += `"${t("export.typeBreakdown")}"
`;
    csvContent += `"${t("export.typeHeader")}","${t("export.daysHeader")}","${t("export.hoursHeader")}"
`;
    const typeStats = {};
    sortedEntries.forEach((entry) => {
      if (entry.startTime && entry.endTime) {
        const typeName = entry.name.toLowerCase();
        if (!typeStats[typeName]) {
          typeStats[typeName] = { days: /* @__PURE__ */ new Set(), hours: 0 };
        }
        const startDate = new Date(entry.startTime);
        const endDate = new Date(entry.endTime);
        typeStats[typeName].days.add(Utils.toLocalDateStr(startDate));
        typeStats[typeName].hours += (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
      }
    });
    Object.keys(typeStats).forEach((type) => {
      const stat = typeStats[type];
      csvContent += `"${translateSpecialDayName(type)}","${stat.days.size}","${stat.hours.toFixed(2)}"
`;
    });
    return csvContent;
  }
  showImportModal() {
    new ImportModal(this.app, this.plugin.timerManager, async () => {
      await this.refreshView();
    }).open();
  }
  showNoteTypeModal(noteType, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(noteType ? "Edit note type" : "Add note type");
    const { contentEl } = modal;
    const formData = {
      id: (noteType == null ? void 0 : noteType.id) || "",
      label: (noteType == null ? void 0 : noteType.label) || "",
      icon: (noteType == null ? void 0 : noteType.icon) || "\u{1F4C4}",
      folder: (noteType == null ? void 0 : noteType.folder) || "",
      template: (noteType == null ? void 0 : noteType.template) || "",
      tags: (noteType == null ? void 0 : noteType.tags.join(", ")) || "",
      filenamePattern: (noteType == null ? void 0 : noteType.filenamePattern) || "{YYYY}-{MM}-{DD}"
    };
    new import_obsidian2.Setting(contentEl).setName("ID").setDesc("Unique identifier for this note type (lowercase, no spaces)").addText((text) => {
      text.setPlaceholder("Meeting").setValue(formData.id).onChange((value) => {
        formData.id = value.toLowerCase().replace(/\s+/g, "-");
      });
      if (noteType) {
        text.inputEl.disabled = true;
      }
    });
    new import_obsidian2.Setting(contentEl).setName("Label").setDesc("Display name shown in the context menu").addText((text) => text.setPlaceholder("M\xF8tenotat").setValue(formData.label).onChange((value) => {
      formData.label = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Icon").setDesc("Emoji or icon to display (single character)").addText((text) => text.setPlaceholder("\u{1F465}").setValue(formData.icon).onChange((value) => {
      formData.icon = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Folder").setDesc("Folder where notes will be created").addText((text) => text.setPlaceholder("M\xF8ter").setValue(formData.folder).onChange((value) => {
      formData.folder = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Template path").setDesc("Path to the template file (relative to vault root)").addText((text) => text.setPlaceholder("timeflow/templates/meeting-note.md").setValue(formData.template).onChange((value) => {
      formData.template = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Tags").setDesc("Comma-separated tags to add to notes (e.g., #m\xF8te, #timeflow)").addText((text) => text.setPlaceholder("#m\xF8te, #timeflow").setValue(formData.tags).onChange((value) => {
      formData.tags = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Filename pattern").setDesc("Pattern for note filenames. Available: {YYYY}, {MM}, {DD}, {WEEK}").addText((text) => text.setPlaceholder("{YYYY}-{MM}-{DD} M\xF8te").setValue(formData.filenamePattern).onChange((value) => {
      formData.filenamePattern = value;
    }));
    const infoDiv = contentEl.createDiv({ cls: "tf-settings-info-box" });
    infoDiv.createEl("strong", { text: "\u{1F4CB} pattern variables:" });
    const ul = infoDiv.createEl("ul", { cls: "tf-settings-info-list" });
    const patterns = [
      ["{YYYY}", "Four-digit year (e.g., 2025)"],
      ["{MM}", "Two-digit month (e.g., 01)"],
      ["{DD}", "Two-digit day (e.g., 15)"],
      ["{WEEK}", "ISO week number (e.g., 07)"]
    ];
    patterns.forEach(([code, desc]) => {
      const li = ul.createEl("li");
      li.createEl("code", { text: code });
      li.appendText(" - " + desc);
    });
    const buttonDiv = contentEl.createDiv({ cls: "tf-settings-button-row" });
    const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonDiv.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!formData.id || !formData.label || !formData.folder) {
        new import_obsidian2.Notice("\u26A0\uFE0F please fill in all required fields (ID, label, folder)");
        return;
      }
      const tagsArray = formData.tags.split(",").map((t2) => t2.trim()).filter((t2) => t2.length > 0);
      const newNoteType = {
        id: formData.id,
        label: formData.label,
        icon: formData.icon || "\u{1F4C4}",
        folder: formData.folder,
        template: formData.template,
        tags: tagsArray,
        filenamePattern: formData.filenamePattern || "{YYYY}-{MM}-{DD}"
      };
      if (index >= 0) {
        this.plugin.settings.noteTypes[index] = newNoteType;
      } else {
        const existingIndex = this.plugin.settings.noteTypes.findIndex((nt) => nt.id === newNoteType.id);
        if (existingIndex >= 0) {
          new import_obsidian2.Notice("\u26A0\uFE0F a note type with this ID already exists");
          return;
        }
        this.plugin.settings.noteTypes.push(newNoteType);
      }
      await this.plugin.saveSettings();
      await this.refreshView();
      modal.close();
      this.display();
      new import_obsidian2.Notice(`\u2705 Note type ${noteType ? "updated" : "added"} successfully`);
    };
    modal.open();
  }
};

// src/view.ts
var import_obsidian6 = require("obsidian");

// src/dataManager.ts
var import_obsidian3 = require("obsidian");
var DataManager = class {
  constructor(entries, settings, app) {
    this.daily = {};
    this.months = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.holidays = {};
    // Cache for expensive calculations
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries = entries;
    this.settings = settings;
    this.app = app;
    this.workdayHours = settings.baseWorkday * settings.workPercent;
    this.workweekHours = settings.baseWorkweek * settings.workPercent;
  }
  async loadHolidays() {
    const status = { success: false, message: "", count: 0, warning: null };
    this.holidays = {};
    try {
      const holidayFile = this.app.vault.getAbstractFileByPath((0, import_obsidian3.normalizePath)(this.settings.holidaysFilePath));
      if (holidayFile && holidayFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.read(holidayFile);
        const lines = content.split("\n");
        lines.forEach((line) => {
          const match = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*(\w+)(?::(half|\d{2}:\d{2}-\d{2}:\d{2})?)?:\s*(.+)$/);
          const annetMatch = line.match(/^-\s*(\d{4}-\d{2}-\d{2}):\s*annet(?::([^:]+))?(?::(\d{2}:\d{2}-\d{2}:\d{2}))?:\s*(.+)$/);
          if (annetMatch) {
            const [, date, templateOrTime, timeRange, description] = annetMatch;
            let annetTemplateId;
            let startTime;
            let endTime;
            if (templateOrTime && /^\d{2}:\d{2}-\d{2}:\d{2}$/.test(templateOrTime)) {
              const [start, end] = templateOrTime.split("-");
              startTime = start;
              endTime = end;
            } else if (templateOrTime) {
              annetTemplateId = templateOrTime.trim().toLowerCase();
              if (timeRange) {
                const [start, end] = timeRange.split("-");
                startTime = start;
                endTime = end;
              }
            }
            this.holidays[date] = {
              type: "annet",
              description: description.trim(),
              halfDay: false,
              startTime,
              endTime,
              annetTemplateId
            };
          } else if (match) {
            const [, date, type, modifier, description] = match;
            const isHalfDay = modifier === "half";
            let startTime;
            let endTime;
            if (modifier && modifier.includes("-") && modifier.includes(":")) {
              const [start, end] = modifier.split("-");
              startTime = start;
              endTime = end;
            }
            this.holidays[date] = {
              type: type.trim().toLowerCase(),
              description: description.trim(),
              halfDay: isHalfDay,
              startTime,
              endTime
            };
          }
        });
        status.success = true;
        status.count = Object.keys(this.holidays).length;
        status.message = t("status.loadedPlannedDays").replace("{count}", String(status.count));
      } else {
        status.warning = `Holiday file not found: ${this.settings.holidaysFilePath}`;
        console.warn(status.warning);
      }
    } catch (error) {
      status.warning = `Error loading holidays: ${error instanceof Error ? error.message : String(error)}`;
      console.warn("Could not load future days file:", error);
    }
    return status;
  }
  isHoliday(dateStr) {
    return Object.prototype.hasOwnProperty.call(this.holidays, dateStr);
  }
  getHolidayInfo(dateStr) {
    return this.holidays[dateStr] || null;
  }
  getSpecialDayBehavior(id) {
    const behavior = this.settings.specialDayBehaviors.find((b) => b.id.toLowerCase() === id.toLowerCase());
    if (!behavior) {
      return {
        id,
        label: id,
        icon: "\u2753",
        color: "#cccccc",
        textColor: "#000000",
        noHoursRequired: false,
        flextimeEffect: "none",
        isWorkType: true,
        includeInStats: true
      };
    }
    return behavior;
  }
  /**
   * Check if a comment is required for stopping a timer on a given date.
   * Required if:
   * - Date >= effective date
   * - Entry is work type or accumulate type
   * - Day's total work + additionalDuration exceeds (dailyGoal + threshold)
   */
  checkCommentRequired(dateStr, entryType, additionalDuration) {
    var _a, _b;
    if (!this.settings.enableOvertimeComments) {
      return { required: false, hoursOverThreshold: 0, dailyGoal: 0 };
    }
    const threshold = (_a = this.settings.overtimeCommentThreshold) != null ? _a : 0.5;
    const effectiveDate = (_b = this.settings.overtimeCommentEffectiveDate) != null ? _b : "2025-01-01";
    if (dateStr < effectiveDate) {
      return { required: false, hoursOverThreshold: 0, dailyGoal: 0 };
    }
    const behavior = this.getSpecialDayBehavior(entryType);
    if (!(behavior == null ? void 0 : behavior.isWorkType) && (behavior == null ? void 0 : behavior.flextimeEffect) !== "accumulate") {
      return { required: false, hoursOverThreshold: 0, dailyGoal: 0 };
    }
    const dailyGoal = this.getDailyGoal(dateStr);
    const dayEntries = this.daily[dateStr] || [];
    let dayWorkTotal = 0;
    dayEntries.forEach((e) => {
      if (!e.isActive) {
        const eBehavior = this.getSpecialDayBehavior(e.name);
        if ((eBehavior == null ? void 0 : eBehavior.isWorkType) || (eBehavior == null ? void 0 : eBehavior.flextimeEffect) === "accumulate") {
          dayWorkTotal += e.duration || 0;
        }
      }
    });
    dayWorkTotal += additionalDuration;
    const thresholdLimit = dailyGoal + threshold;
    const hoursOverThreshold = dayWorkTotal - thresholdLimit;
    return {
      required: hoursOverThreshold > 0,
      hoursOverThreshold: Math.max(0, hoursOverThreshold),
      dailyGoal
    };
  }
  /**
   * Get the behavior for an 'annet' holiday entry with dynamic properties based on time range.
   * - Full day (no time range): noHoursRequired=true, flextimeEffect='none'
   * - Partial day (with time range): noHoursRequired=false, flextimeEffect='reduce_goal'
   */
  getAnnetBehavior(holidayInfo) {
    var _a;
    const baseBehavior = this.getSpecialDayBehavior("annet");
    const hasTimeRange = !!holidayInfo.startTime && !!holidayInfo.endTime;
    let icon = (baseBehavior == null ? void 0 : baseBehavior.icon) || "\u{1F4CB}";
    let label = (baseBehavior == null ? void 0 : baseBehavior.label) || "Annet";
    if (holidayInfo.annetTemplateId) {
      const template = (_a = this.settings.annetTemplates) == null ? void 0 : _a.find(
        (t2) => {
          var _a2;
          return t2.id.toLowerCase() === ((_a2 = holidayInfo.annetTemplateId) == null ? void 0 : _a2.toLowerCase());
        }
      );
      if (template) {
        icon = template.icon;
        label = translateAnnetTemplateName(template.id, template.label);
      }
    }
    if (hasTimeRange) {
      return {
        ...baseBehavior,
        icon,
        label,
        noHoursRequired: false,
        flextimeEffect: "reduce_goal"
      };
    } else {
      return {
        ...baseBehavior,
        icon,
        label,
        noHoursRequired: true,
        flextimeEffect: "none"
      };
    }
  }
  /**
   * Get the work schedule that was active on a specific date.
   *
   * Logic:
   * - Periods are sorted by effectiveFrom date
   * - Find the most recent period that started on or before the given date
   * - If the date is before ALL periods, use the earliest period (not current settings)
   *   This ensures historical consistency even before the first recorded period
   * - Future periods work correctly: they won't apply until their effective date
   */
  getScheduleForDate(dateStr) {
    const history = this.settings.workScheduleHistory;
    if (!history || history.length === 0) {
      return {
        workPercent: this.settings.workPercent,
        baseWorkday: this.settings.baseWorkday,
        baseWorkweek: this.settings.baseWorkweek,
        workDays: this.settings.workDays,
        halfDayHours: this.settings.halfDayHours
      };
    }
    const sortedHistory = [...history].sort((a, b) => a.effectiveFrom.localeCompare(b.effectiveFrom));
    let activePeriod = null;
    for (const period of sortedHistory) {
      if (period.effectiveFrom <= dateStr) {
        activePeriod = period;
      } else {
        break;
      }
    }
    if (activePeriod) {
      return {
        workPercent: activePeriod.workPercent,
        baseWorkday: activePeriod.baseWorkday,
        baseWorkweek: activePeriod.baseWorkweek,
        workDays: activePeriod.workDays,
        halfDayHours: activePeriod.halfDayHours
      };
    }
    const earliestPeriod = sortedHistory[0];
    return {
      workPercent: earliestPeriod.workPercent,
      baseWorkday: earliestPeriod.baseWorkday,
      baseWorkweek: earliestPeriod.baseWorkweek,
      workDays: earliestPeriod.workDays,
      halfDayHours: earliestPeriod.halfDayHours
    };
  }
  getDailyGoal(dateStr) {
    if (!this.settings.enableGoalTracking) {
      return 0;
    }
    const schedule = this.getScheduleForDate(dateStr);
    const date = new Date(dateStr);
    const dayOfWeek = date.getDay();
    const isWeekend = !schedule.workDays.includes(dayOfWeek);
    if (isWeekend) return 0;
    const holidayInfo = this.getHolidayInfo(dateStr);
    if (holidayInfo) {
      const behavior = holidayInfo.type === "annet" ? this.getAnnetBehavior(holidayInfo) : this.getSpecialDayBehavior(holidayInfo.type);
      if (behavior && behavior.noHoursRequired) {
        return 0;
      }
      if (holidayInfo.halfDay) {
        const halfDayHours = this.settings.halfDayMode === "percentage" ? schedule.baseWorkday / 2 : schedule.halfDayHours;
        return halfDayHours;
      }
    }
    if (this.daily[dateStr]) {
      const specialEntry = this.daily[dateStr].find((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return behavior && (behavior.noHoursRequired || behavior.countsAsWorkday);
      });
      if (specialEntry) {
        return 0;
      }
    }
    return schedule.baseWorkday * schedule.workPercent;
  }
  processEntries() {
    this.daily = {};
    this.activeEntries = [];
    this.activeEntriesByDate = {};
    this.months = {};
    this._cachedAverages = null;
    this._cachedContextData = {};
    this.rawEntries.forEach((e) => {
      if (!e.startTime) return;
      const start = Utils.parseDate(e.startTime);
      if (!start) return;
      const dayKey = Utils.toLocalDateStr(start);
      if (!e.endTime) {
        this.activeEntries.push(e);
        if (!this.activeEntriesByDate[dayKey]) this.activeEntriesByDate[dayKey] = [];
        this.activeEntriesByDate[dayKey].push(e);
        const now = /* @__PURE__ */ new Date();
        let duration2 = Utils.hoursDiff(start, now);
        if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
          const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
          duration2 = Math.max(0, duration2 - lunchBreakHours);
        }
        if (!this.daily[dayKey]) this.daily[dayKey] = [];
        this.daily[dayKey].push({ ...e, duration: duration2, date: start, isActive: true });
        return;
      }
      const end = Utils.parseDate(e.endTime);
      if (!end) return;
      let duration = Utils.hoursDiff(start, end);
      if (e.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
        const lunchBreakHours = this.settings.lunchBreakMinutes / 60;
        duration = Math.max(0, duration - lunchBreakHours);
      }
      if (!this.daily[dayKey]) this.daily[dayKey] = [];
      this.daily[dayKey].push({ ...e, duration, date: start });
    });
    this.calculateFlextime();
    this.groupByMonths();
  }
  calculateFlextime() {
    if (!this.settings.enableGoalTracking) {
      for (let day in this.daily) {
        this.daily[day].forEach((e) => {
          e.flextime = 0;
        });
      }
      return;
    }
    for (let day in this.daily) {
      const dayGoal = this.getDailyGoal(day);
      const holidayInfo = this.getHolidayInfo(day);
      const dayEntries = this.daily[day];
      let goalReduction = 0;
      dayEntries.forEach((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        if ((behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal") {
          const reduction = e.duration && e.duration > 0 ? e.duration : dayGoal;
          goalReduction += reduction;
        }
      });
      const effectiveGoal = Math.max(0, dayGoal - goalReduction);
      let totalWorkHours = 0;
      dayEntries.forEach((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        if (!behavior || behavior.isWorkType || behavior.flextimeEffect === "accumulate") {
          totalWorkHours += e.duration || 0;
        }
      });
      dayEntries.forEach((e) => {
        let flextime = 0;
        const behavior = this.getSpecialDayBehavior(e.name);
        if ((behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal") {
          e.flextime = 0;
          return;
        }
        const effectiveBehavior = behavior || (holidayInfo ? holidayInfo.type === "annet" ? this.getAnnetBehavior(holidayInfo) : this.getSpecialDayBehavior(holidayInfo.type) : null);
        const isWorkTypeEntry = (effectiveBehavior == null ? void 0 : effectiveBehavior.isWorkType) || !behavior && !holidayInfo;
        if (effectiveBehavior && !isWorkTypeEntry) {
          if (effectiveBehavior.flextimeEffect === "withdraw") {
            flextime -= e.duration || 0;
          } else if (effectiveBehavior.flextimeEffect === "accumulate") {
            if (effectiveGoal > 0 && (e.duration || 0) > effectiveGoal) {
              flextime += (e.duration || 0) - effectiveGoal;
            } else if (effectiveGoal === 0) {
              flextime += e.duration || 0;
            }
          } else if (effectiveBehavior.noHoursRequired && effectiveGoal === 0) {
            flextime += e.duration || 0;
          }
        } else if (effectiveGoal === 0) {
          flextime += e.duration || 0;
        } else {
          if (totalWorkHours !== effectiveGoal && effectiveGoal > 0 && totalWorkHours > 0) {
            const proportion = (e.duration || 0) / totalWorkHours;
            flextime += (totalWorkHours - effectiveGoal) * proportion;
          }
        }
        e.flextime = flextime;
      });
    }
  }
  groupByMonths() {
    for (let day of Object.keys(this.daily)) {
      const date = new Date(day);
      const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
      if (!this.months[monthKey]) this.months[monthKey] = {};
      const weekNum = Utils.getWeekNumber(date);
      if (!this.months[monthKey][weekNum]) this.months[monthKey][weekNum] = [];
      this.months[monthKey][weekNum].push(...this.daily[day]);
    }
  }
  getOngoing() {
    const now = /* @__PURE__ */ new Date();
    return this.activeEntries.reduce((sum, e) => {
      const start = Utils.parseDate(e.startTime);
      return start ? sum + Utils.hoursDiff(start, now) : sum;
    }, 0);
  }
  getBalanceUpToDate(endDate) {
    let balance = this.settings.startingFlextimeBalance || 0;
    const startDate = this.settings.balanceStartDate;
    const sortedDays = Object.keys(this.daily).filter((day) => day >= startDate && day <= endDate).sort();
    for (const day of sortedDays) {
      const dayGoal = this.getDailyGoal(day);
      const dayEntries = this.daily[day] || [];
      let regularWorked = 0;
      let accumulateWorked = 0;
      let avspaseringHours = 0;
      let goalReduction = 0;
      let hasAccumulateEntry = false;
      let hasActiveEntry = false;
      dayEntries.forEach((e) => {
        if (e.isActive) {
          hasActiveEntry = true;
          const behavior2 = this.getSpecialDayBehavior(e.name);
          if (!behavior2 || behavior2.isWorkType) {
            regularWorked += e.duration || 0;
          } else if ((behavior2 == null ? void 0 : behavior2.flextimeEffect) === "accumulate") {
            accumulateWorked += e.duration || 0;
            hasAccumulateEntry = true;
          }
          return;
        }
        const behavior = this.getSpecialDayBehavior(e.name);
        if ((behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal") {
          const reduction = e.duration && e.duration > 0 ? e.duration : dayGoal;
          goalReduction += reduction;
        } else if ((behavior == null ? void 0 : behavior.flextimeEffect) === "withdraw") {
          avspaseringHours += e.duration || 0;
        } else if (behavior && (behavior.noHoursRequired || behavior.countsAsWorkday)) {
          regularWorked += e.duration || 0;
        } else if ((behavior == null ? void 0 : behavior.flextimeEffect) === "accumulate" && !behavior.isWorkType) {
          accumulateWorked += e.duration || 0;
          hasAccumulateEntry = true;
        } else {
          regularWorked += e.duration || 0;
        }
      });
      if (hasActiveEntry) continue;
      const effectiveGoal = Math.max(0, dayGoal - goalReduction);
      if (hasAccumulateEntry && regularWorked === 0) {
        if (effectiveGoal === 0) {
          balance += accumulateWorked;
        } else {
          const excess = accumulateWorked - effectiveGoal;
          if (excess > 0) {
            balance += excess;
          }
        }
      } else {
        const totalWorked = regularWorked + accumulateWorked;
        if (effectiveGoal === 0) {
          balance += totalWorked;
        } else {
          balance += totalWorked - effectiveGoal;
        }
      }
      balance -= avspaseringHours;
    }
    return balance;
  }
  getCurrentBalance() {
    const today = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    return this.getBalanceUpToDate(today);
  }
  getTotalFlextime() {
    return this.getCurrentBalance();
  }
  getCurrentWeekHours(today) {
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    const lastDayOfWeek = new Date(firstDayOfWeek);
    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
    let total = 0;
    for (let d = new Date(firstDayOfWeek); d <= lastDayOfWeek; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        if (entry.isActive) return;
        const behavior = this.getSpecialDayBehavior(entry.name);
        const shouldExclude = behavior && (behavior.flextimeEffect === "withdraw" || behavior.flextimeEffect === "reduce_goal" || behavior.flextimeEffect === "none" && behavior.noHoursRequired);
        if (!shouldExclude) {
          total += entry.duration || 0;
        }
      });
    }
    return total + this.getOngoing();
  }
  getTodayHours(today) {
    const todayKey = Utils.toLocalDateStr(today);
    const todayEntries = this.daily[todayKey] || [];
    return todayEntries.filter((e) => {
      if (e.isActive) return false;
      const behavior = this.getSpecialDayBehavior(e.name);
      return !behavior || behavior.isWorkType || behavior.flextimeEffect === "accumulate";
    }).reduce((sum, e) => sum + (e.duration || 0), 0) + this.getOngoing();
  }
  getAverages() {
    if (this._cachedAverages) {
      return this._cachedAverages;
    }
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const pastKeys = Object.keys(this.daily).filter((d) => d < todayKey);
    const weekdayKeys = pastKeys.filter((dk) => {
      const date = Utils.parseDate(dk);
      return date && !Utils.isWeekend(date, this.settings);
    });
    const workDayKeys = weekdayKeys.filter((dk) => {
      const entries = this.daily[dk];
      return entries.some((e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return (behavior == null ? void 0 : behavior.isWorkType) && (e.duration || 0) > 0;
      });
    });
    const totalHoursWorked = workDayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => {
        const behavior = this.getSpecialDayBehavior(e.name);
        return s + ((behavior == null ? void 0 : behavior.isWorkType) ? e.duration || 0 : 0);
      }, 0),
      0
    );
    const avgDaily = workDayKeys.length > 0 ? totalHoursWorked / workDayKeys.length : 0;
    const weeksWorked = this.settings.workdaysPerWeek > 0 ? workDayKeys.length / this.settings.workdaysPerWeek : 0;
    const avgWeekly = weeksWorked > 0 ? totalHoursWorked / weeksWorked : 0;
    this._cachedAverages = {
      avgDaily,
      avgWeekly,
      totalDaysWorked: workDayKeys.length,
      totalHoursWorked
    };
    return this._cachedAverages;
  }
  getStatistics(timeframe = "total", year, month) {
    var _a, _b;
    const today = /* @__PURE__ */ new Date();
    let filterFn;
    if (timeframe === "year") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      filterFn = (dateStr) => new Date(dateStr).getFullYear() === targetYear;
    } else if (timeframe === "month") {
      const targetYear = year !== void 0 ? year : today.getFullYear();
      const targetMonth = month !== void 0 ? month : today.getMonth();
      filterFn = (dateStr) => {
        const d = new Date(dateStr);
        return d.getFullYear() === targetYear && d.getMonth() === targetMonth;
      };
    } else {
      filterFn = () => true;
    }
    const filteredDays = Object.keys(this.daily).filter(filterFn);
    const allEntries = filteredDays.flatMap((day) => this.daily[day]);
    const stats = {
      totalHours: allEntries.reduce((sum, e) => sum + (e.duration || 0), 0),
      totalFlextime: allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0),
      jobb: { count: 0, hours: 0 },
      avspasering: { count: 0, hours: 0, planned: 0 },
      ferie: { count: 0, hours: 0, max: ((_a = this.getSpecialDayBehavior("ferie")) == null ? void 0 : _a.maxDaysPerYear) || this.settings.maxFerieDays, planned: 0 },
      velferdspermisjon: { count: 0, hours: 0, planned: 0 },
      egenmelding: { count: 0, hours: 0, max: ((_b = this.getSpecialDayBehavior("egenmelding")) == null ? void 0 : _b.maxDaysPerYear) || this.settings.maxEgenmeldingDays },
      sykemelding: { count: 0, hours: 0 },
      studie: { count: 0, hours: 0, planned: 0 },
      kurs: { count: 0, hours: 0, planned: 0 },
      workDays: 0,
      weekendDays: 0,
      weekendHours: 0,
      avgDailyHours: 0,
      workloadPercent: 0
    };
    const daysByType = {
      jobb: /* @__PURE__ */ new Set(),
      avspasering: /* @__PURE__ */ new Set(),
      ferie: /* @__PURE__ */ new Set(),
      velferdspermisjon: /* @__PURE__ */ new Set(),
      egenmelding: /* @__PURE__ */ new Set(),
      sykemelding: /* @__PURE__ */ new Set(),
      studie: /* @__PURE__ */ new Set(),
      kurs: /* @__PURE__ */ new Set()
    };
    const uniqueDays = /* @__PURE__ */ new Set();
    const weekendDaysSet = /* @__PURE__ */ new Set();
    const workDaysSet = /* @__PURE__ */ new Set();
    filteredDays.forEach((dayKey) => {
      const dayDate = /* @__PURE__ */ new Date(dayKey + "T12:00:00");
      const dayEntries = this.daily[dayKey];
      uniqueDays.add(dayKey);
      const isWeekendDay = Utils.isWeekend(dayDate, this.settings);
      if (isWeekendDay) {
        weekendDaysSet.add(dayKey);
      } else {
        workDaysSet.add(dayKey);
      }
      dayEntries.forEach((e) => {
        const name = e.name.toLowerCase();
        const behavior = this.getSpecialDayBehavior(name);
        if (isWeekendDay) {
          stats.weekendHours += e.duration || 0;
        }
        if (daysByType[name]) {
          const isReduceGoalType = (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal";
          const isFullDay = !e.duration || e.duration === 0;
          if (!isReduceGoalType || isFullDay) {
            daysByType[name].add(dayKey);
            const statKey = name;
            const stat = stats[statKey];
            if (name !== "jobb" && typeof stat === "object" && stat !== null && "hours" in stat) {
              stat.hours += e.duration || 0;
            }
          }
        }
        if ((behavior == null ? void 0 : behavior.isWorkType) || (behavior == null ? void 0 : behavior.flextimeEffect) === "accumulate" || !behavior) {
          daysByType.jobb.add(dayKey);
          stats.jobb.hours += e.duration || 0;
        }
      });
    });
    stats.weekendDays = weekendDaysSet.size;
    stats.workDays = workDaysSet.size;
    stats.jobb.count = daysByType.jobb.size;
    stats.avspasering.count = daysByType.avspasering.size;
    stats.ferie.count = daysByType.ferie.size;
    stats.velferdspermisjon.count = daysByType.velferdspermisjon.size;
    stats.egenmelding.count = daysByType.egenmelding.size;
    stats.sykemelding.count = daysByType.sykemelding.size;
    stats.studie.count = daysByType.studie.size;
    stats.kurs.count = daysByType.kurs.size;
    Object.keys(this.holidays).forEach((dateStr) => {
      const plannedInfo = this.holidays[dateStr];
      const plannedDate = new Date(dateStr);
      if (filterFn(dateStr) && plannedDate > today) {
        const type = plannedInfo.type;
        if (type === "ferie" && stats.ferie.planned !== void 0) {
          stats.ferie.planned++;
        } else if (type === "avspasering" && stats.avspasering.planned !== void 0) {
          stats.avspasering.planned++;
        } else if (type === "velferdspermisjon" && stats.velferdspermisjon.planned !== void 0) {
          stats.velferdspermisjon.planned++;
        } else if (type === "studie" && stats.studie.planned !== void 0) {
          stats.studie.planned++;
        } else if (type === "kurs" && stats.kurs.planned !== void 0) {
          stats.kurs.planned++;
        }
      }
    });
    stats.avgDailyHours = uniqueDays.size > 0 ? stats.totalHours / uniqueDays.size : 0;
    if (timeframe === "year" || timeframe === "month") {
      const expectedWorkdays = timeframe === "year" ? this.settings.workdaysPerYear : this.settings.workdaysPerMonth;
      let noHoursRequiredDays = 0;
      filteredDays.forEach((dayKey) => {
        const holidayInfo = this.getHolidayInfo(dayKey);
        if (holidayInfo) {
          const behavior = holidayInfo.type === "annet" ? this.getAnnetBehavior(holidayInfo) : this.getSpecialDayBehavior(holidayInfo.type);
          if (behavior == null ? void 0 : behavior.noHoursRequired) {
            noHoursRequiredDays++;
          }
        }
      });
      const adjustedWorkdays = Math.max(0, expectedWorkdays - noHoursRequiredDays);
      const expectedHours = adjustedWorkdays * this.workdayHours;
      stats.workloadPercent = expectedHours > 0 ? stats.totalHours / expectedHours * 100 : 0;
    }
    return stats;
  }
  getAvailableYears() {
    const years = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const year = new Date(dateStr).getFullYear();
      years.add(year);
    });
    return Array.from(years).sort((a, b) => b - a);
  }
  getAvailableMonthsForYear(year) {
    const months = /* @__PURE__ */ new Set();
    Object.keys(this.daily).forEach((dateStr) => {
      const date = new Date(dateStr);
      if (date.getFullYear() === year) {
        months.add(date.getMonth());
      }
    });
    return Array.from(months).sort((a, b) => a - b);
  }
  getContextualData(today) {
    const todayKey = Utils.toLocalDateStr(today);
    if (this._cachedContextData[todayKey]) {
      return this._cachedContextData[todayKey];
    }
    const weekday = today.getDay();
    let consecutiveFlextimeDays = 0;
    const sortedDays = Object.keys(this.daily).sort().reverse();
    for (let day of sortedDays) {
      if (day >= todayKey) continue;
      const dayFlextime = this.daily[day].reduce(
        (sum, e) => sum + (e.flextime || 0),
        0
      );
      if (dayFlextime > 0) {
        consecutiveFlextimeDays++;
      } else {
        break;
      }
    }
    const sameWeekdayKeys = Object.keys(this.daily).filter((d) => {
      const date = new Date(d);
      return date.getDay() === weekday && d < todayKey;
    });
    const sameDayTotal = sameWeekdayKeys.reduce(
      (sum, dk) => sum + this.daily[dk].reduce((s, e) => s + (e.duration || 0), 0),
      0
    );
    const sameDayAvg = sameWeekdayKeys.length > 0 ? sameDayTotal / sameWeekdayKeys.length : 0;
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const thisWeekMonday = new Date(today);
    thisWeekMonday.setDate(today.getDate() - daysFromMonday);
    const lastWeekStart = new Date(thisWeekMonday);
    lastWeekStart.setDate(thisWeekMonday.getDate() - 7);
    const lastWeekEnd = new Date(lastWeekStart);
    lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
    let lastWeekHours = 0;
    for (let d = new Date(lastWeekStart); d <= lastWeekEnd; d = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1)) {
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      lastWeekHours += dayEntries.reduce((s, e) => s + (e.duration || 0), 0);
    }
    const result = { consecutiveFlextimeDays, sameDayAvg, lastWeekHours };
    this._cachedContextData[todayKey] = result;
    return result;
  }
  getWeekTotals(numWeeks = 8) {
    const today = /* @__PURE__ */ new Date();
    const weekTotals = [];
    for (let i = numWeeks - 1; i >= 0; i--) {
      const d = new Date(today);
      d.setDate(today.getDate() - i * 7);
      const dayOfWeek = d.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const weekStart = new Date(d);
      weekStart.setDate(d.getDate() - daysFromMonday);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      let weekSum = 0;
      for (let wd = new Date(weekStart); wd <= weekEnd; wd = new Date(wd.getFullYear(), wd.getMonth(), wd.getDate() + 1)) {
        const dayKey = Utils.toLocalDateStr(wd);
        const dayEntries = this.daily[dayKey] || [];
        weekSum += dayEntries.filter((e) => {
          const behavior = this.getSpecialDayBehavior(e.name);
          return !behavior || behavior.isWorkType || behavior.flextimeEffect === "accumulate";
        }).reduce((s, e) => s + (e.duration || 0), 0);
      }
      weekTotals.push(weekSum);
    }
    return weekTotals;
  }
  validateData() {
    const issues = {
      errors: [],
      warnings: [],
      info: [],
      stats: {
        totalEntries: 0,
        entriesChecked: 0,
        entriesWithIssues: 0
      }
    };
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const createIssue = (severity, type, description, entry, dayKey) => {
      issues.stats.entriesWithIssues++;
      return {
        severity,
        type,
        description,
        date: dayKey,
        entry: {
          name: entry.name,
          startTime: entry.startTime,
          endTime: entry.endTime,
          duration: entry.duration
        }
      };
    };
    for (const dayKey in this.daily) {
      const dayEntries = this.daily[dayKey];
      issues.stats.totalEntries += dayEntries.length;
      dayEntries.forEach((entry) => {
        var _a, _b, _c;
        issues.stats.entriesChecked++;
        if (!entry.name || entry.name.trim() === "") {
          issues.errors.push(createIssue(
            "error",
            "Missing Entry Name",
            "Entry has no name/type",
            entry,
            dayKey
          ));
        }
        if (!entry.startTime) {
          issues.errors.push(createIssue(
            "error",
            "Missing Start Time",
            "Entry has no start time",
            entry,
            dayKey
          ));
          return;
        }
        if ((entry.duration || 0) < 0) {
          issues.errors.push(createIssue(
            "error",
            "Negative Duration",
            `End time is before start time (${(_a = entry.duration) == null ? void 0 : _a.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.maxDurationHours) {
          issues.errors.push(createIssue(
            "error",
            "Excessive Duration",
            `Entry spans more than ${this.settings.validationThresholds.maxDurationHours} hours (${(_b = entry.duration) == null ? void 0 : _b.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) > this.settings.validationThresholds.veryLongSessionHours && (entry.duration || 0) <= this.settings.validationThresholds.maxDurationHours) {
          issues.warnings.push(createIssue(
            "warning",
            "Very Long Session",
            `Entry duration exceeds ${this.settings.validationThresholds.veryLongSessionHours} hours (${(_c = entry.duration) == null ? void 0 : _c.toFixed(1)}h)`,
            entry,
            dayKey
          ));
        }
        if ((entry.duration || 0) === 0) {
          issues.info.push(createIssue(
            "info",
            "Zero Duration",
            "Entry has zero duration",
            entry,
            dayKey
          ));
        }
        if (dayKey > todayStr) {
          issues.info.push(createIssue(
            "info",
            "Future Date",
            "Entry is dated in the future",
            entry,
            dayKey
          ));
        }
      });
      if (dayEntries.length > 1) {
        const sortedEntries = [...dayEntries].filter((e) => Boolean(e.startTime && e.endTime)).sort((a, b) => {
          const aStart = new Date(a.startTime);
          const bStart = new Date(b.startTime);
          return aStart.getTime() - bStart.getTime();
        });
        for (let i = 0; i < sortedEntries.length - 1; i++) {
          const current = sortedEntries[i];
          const next = sortedEntries[i + 1];
          if (current.startTime && current.endTime && next.startTime && next.endTime) {
            const currentEnd = new Date(current.endTime);
            const nextStart = new Date(next.startTime);
            if (currentEnd > nextStart) {
              const overlapMinutes = Math.round((currentEnd.getTime() - nextStart.getTime()) / 6e4);
              issues.errors.push({
                severity: "error",
                type: "Overlapping Entries",
                description: `Entries overlap by ${overlapMinutes} minutes`,
                date: dayKey,
                entry: {
                  name: `${current.name} \u2192 ${next.name}`,
                  startTime: current.startTime,
                  endTime: next.endTime
                }
              });
              issues.stats.entriesWithIssues++;
            }
          }
        }
      }
    }
    const allDates = Object.keys(this.daily).sort();
    if (allDates.length > 0) {
      const firstDate = new Date(allDates[0]);
      const lastDate = today;
      for (let d = new Date(firstDate); d <= lastDate; d.setDate(d.getDate() + 1)) {
        const dateStr = Utils.toLocalDateStr(d);
        const isWeekend = Utils.isWeekend(d, this.settings);
        const holidayInfo = this.getHolidayInfo(dateStr);
        const hasEntries = this.daily[dateStr] && this.daily[dateStr].length > 0;
        if (isWeekend) continue;
        if (holidayInfo) {
          const behavior = holidayInfo.type === "annet" ? this.getAnnetBehavior(holidayInfo) : this.getSpecialDayBehavior(holidayInfo.type);
          if ((behavior == null ? void 0 : behavior.noHoursRequired) || (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal") {
            continue;
          }
        }
        if (dateStr >= todayStr) continue;
        if (!hasEntries) {
          issues.warnings.push({
            severity: "warning",
            type: "Missing Entry",
            description: "No work entries registered for this workday",
            date: dateStr
          });
        }
      }
    }
    issues.stats.totalEntries += this.activeEntries.length;
    this.activeEntries.forEach((entry) => {
      issues.stats.entriesChecked++;
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        const now = /* @__PURE__ */ new Date();
        const hoursRunning = Utils.hoursDiff(startTime, now);
        if (hoursRunning > this.settings.validationThresholds.longRunningTimerHours) {
          issues.warnings.push({
            severity: "warning",
            type: "Long-Running Timer",
            description: `Active timer has been running for ${hoursRunning.toFixed(1)} hours (threshold: ${this.settings.validationThresholds.longRunningTimerHours}h)`,
            date: Utils.toLocalDateStr(startTime),
            entry: {
              name: entry.name,
              startTime: entry.startTime,
              duration: hoursRunning
            }
          });
          issues.stats.entriesWithIssues++;
        }
      }
    });
    const currentWeekHours = this.getCurrentWeekHours(today);
    if (currentWeekHours > this.settings.validationThresholds.highWeeklyTotalHours) {
      issues.info.push({
        severity: "info",
        type: "High Weekly Total",
        description: `Current week total exceeds ${this.settings.validationThresholds.highWeeklyTotalHours} hours (${currentWeekHours.toFixed(1)}h)`,
        date: todayStr
      });
    }
    return {
      hasErrors: issues.errors.length > 0,
      hasWarnings: issues.warnings.length > 0,
      hasInfo: issues.info.length > 0,
      issues,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Check if there's a rest period violation for a given date
   * A violation occurs when the gap between the last work session ending on the previous day
   * and the first work session starting on the given day is less than the minimum rest hours
   */
  checkRestPeriodViolation(dateStr) {
    var _a, _b;
    const minimumRestHours = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.minimumRestHours) != null ? _b : 11;
    const currentDate = new Date(dateStr);
    const previousDate = new Date(currentDate);
    previousDate.setDate(previousDate.getDate() - 1);
    const previousDayKey = Utils.toLocalDateStr(previousDate);
    const previousDayEntries = this.daily[previousDayKey] || [];
    const currentDayEntries = this.daily[dateStr] || [];
    if (previousDayEntries.length === 0 || currentDayEntries.length === 0) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    let lastEndTimeMs = 0;
    let lastEndTimeStr = "";
    previousDayEntries.forEach((entry) => {
      if (entry.endTime) {
        const endTime = new Date(entry.endTime);
        if (endTime.getTime() > lastEndTimeMs) {
          lastEndTimeMs = endTime.getTime();
          lastEndTimeStr = endTime.toISOString();
        }
      }
    });
    let firstStartTimeMs = Infinity;
    let firstStartTimeStr = "";
    currentDayEntries.forEach((entry) => {
      if (entry.startTime) {
        const startTime = new Date(entry.startTime);
        if (startTime.getTime() < firstStartTimeMs) {
          firstStartTimeMs = startTime.getTime();
          firstStartTimeStr = startTime.toISOString();
        }
      }
    });
    if (lastEndTimeMs === 0 || firstStartTimeMs === Infinity) {
      return { violated: false, restHours: null, previousDayEnd: null, currentDayStart: null };
    }
    const restHours = (firstStartTimeMs - lastEndTimeMs) / (1e3 * 60 * 60);
    const violated = restHours < minimumRestHours;
    return {
      violated,
      restHours,
      previousDayEnd: lastEndTimeStr,
      currentDayStart: firstStartTimeStr
    };
  }
  /**
   * Get statistics for a special day type, respecting the counting period setting
   * For historical years, always use calendar year counting
   * For current year, respect the countingPeriod setting
   */
  getSpecialDayStats(typeId, year) {
    const behavior = this.getSpecialDayBehavior(typeId);
    const today = /* @__PURE__ */ new Date();
    const currentYear = today.getFullYear();
    const targetYear = year != null ? year : currentYear;
    const isCurrentYear = targetYear === currentYear;
    const countingPeriod = (behavior == null ? void 0 : behavior.countingPeriod) || "calendar";
    const useRolling = isCurrentYear && countingPeriod === "rolling365";
    const isReduceGoalType = (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal";
    let count = 0;
    const daysSeen = /* @__PURE__ */ new Set();
    if (useRolling) {
      const cutoffDate = new Date(today);
      cutoffDate.setDate(cutoffDate.getDate() - 365);
      const cutoffStr = Utils.toLocalDateStr(cutoffDate);
      Object.keys(this.daily).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              if (isReduceGoalType && entry.duration && entry.duration > 0) {
                return;
              }
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        if (dateStr >= cutoffStr && dateStr <= Utils.toLocalDateStr(today)) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    } else {
      Object.keys(this.daily).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const entries = this.daily[dateStr];
          entries.forEach((entry) => {
            if (entry.name.toLowerCase() === typeId && !daysSeen.has(dateStr)) {
              if (isReduceGoalType && entry.duration && entry.duration > 0) {
                return;
              }
              daysSeen.add(dateStr);
              count++;
            }
          });
        }
      });
      Object.keys(this.holidays).forEach((dateStr) => {
        const date = new Date(dateStr);
        if (date.getFullYear() === targetYear) {
          const holidayInfo = this.holidays[dateStr];
          if (holidayInfo.type === typeId && !daysSeen.has(dateStr)) {
            daysSeen.add(dateStr);
            count++;
          }
        }
      });
    }
    return {
      count,
      max: behavior == null ? void 0 : behavior.maxDaysPerYear,
      isRolling: useRolling,
      periodLabel: useRolling ? "365d" : targetYear.toString()
    };
  }
  /**
   * Get total hours for a specific week (Monday to Sunday)
   */
  getWeekHours(weekStart) {
    let total = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(weekStart);
      d.setDate(weekStart.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        if (!entry.isActive) {
          const behavior = this.getSpecialDayBehavior(entry.name);
          const shouldExclude = behavior && (behavior.flextimeEffect === "withdraw" || behavior.flextimeEffect === "reduce_goal" || behavior.flextimeEffect === "none" && behavior.noHoursRequired);
          if (!shouldExclude) {
            total += entry.duration || 0;
          }
        }
      });
    }
    return total;
  }
  /**
   * Get total hours for a specific month
   */
  getMonthHours(year, month) {
    let total = 0;
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    for (let day = 1; day <= daysInMonth; day++) {
      const d = new Date(year, month, day);
      const dayKey = Utils.toLocalDateStr(d);
      const dayEntries = this.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        if (!entry.isActive) {
          const behavior = this.getSpecialDayBehavior(entry.name);
          const shouldExclude = behavior && (behavior.flextimeEffect === "withdraw" || behavior.flextimeEffect === "reduce_goal" || behavior.flextimeEffect === "none" && behavior.noHoursRequired);
          if (!shouldExclude) {
            total += entry.duration || 0;
          }
        }
      });
    }
    return total;
  }
  /**
   * Get total hours for a specific year
   */
  getYearHours(year) {
    let total = 0;
    for (let month = 0; month < 12; month++) {
      total += this.getMonthHours(year, month);
    }
    return total;
  }
  /**
   * Get historical hours data for bar chart
   * Returns array of { label, hours, target? }
   */
  getHistoricalHoursData(timeframe, selectedYear, selectedMonth) {
    const data = [];
    const today = /* @__PURE__ */ new Date();
    const weeklyTarget = this.workweekHours;
    if (timeframe === "month") {
      const currentWeekStart = this.getWeekStart(today);
      const weekPrefix = t("stats.weekPrefix") || "U";
      for (let i = 5; i >= 0; i--) {
        const weekStart = new Date(currentWeekStart);
        weekStart.setDate(currentWeekStart.getDate() - i * 7);
        const weekNum = this.getISOWeekNumber(weekStart);
        const hours = this.getWeekHours(weekStart);
        data.push({
          label: `${weekPrefix}${weekNum}`,
          hours,
          target: weeklyTarget
        });
      }
    } else if (timeframe === "year") {
      const year = selectedYear || today.getFullYear();
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"];
      const monthlyTarget = weeklyTarget * 4.33;
      for (let month = 0; month < 12; month++) {
        const hours = this.getMonthHours(year, month);
        data.push({
          label: monthNames[month],
          hours,
          target: monthlyTarget
        });
      }
    } else {
      const currentYear = today.getFullYear();
      for (let i = 5; i >= 0; i--) {
        const year = currentYear - i;
        const hours = this.getYearHours(year);
        data.push({
          label: year.toString(),
          hours
        });
      }
    }
    return data;
  }
  /**
   * Get the Monday of the week containing the given date
   */
  getWeekStart(date) {
    const d = new Date(date);
    const dayOfWeek = d.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    d.setDate(d.getDate() - daysFromMonday);
    d.setHours(0, 0, 0, 0);
    return d;
  }
  /**
   * Get ISO week number for a date
   */
  getISOWeekNumber(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil(((d.getTime() - yearStart.getTime()) / 864e5 + 1) / 7);
  }
};

// src/uiBuilder.ts
var import_obsidian5 = require("obsidian");

// src/commentModal.ts
var import_obsidian4 = require("obsidian");
var CommentModal = class extends import_obsidian4.Modal {
  constructor(app, timer, isRequired, hoursOverThreshold, onSubmit, onSkip) {
    super(app);
    this.timer = timer;
    this.isRequired = isRequired;
    this.hoursOverThreshold = hoursOverThreshold;
    this.onSubmit = onSubmit;
    this.onSkip = onSkip;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("tf-comment-modal");
    contentEl.createEl("h3", {
      text: t("modals.commentTitle"),
      cls: "tf-comment-modal-title"
    });
    if (this.isRequired) {
      const noticeDiv = contentEl.createDiv({ cls: "tf-comment-required-notice" });
      noticeDiv.createEl("strong", { text: "\u26A0\uFE0F " + t("modals.commentRequired") });
      noticeDiv.createEl("br");
      const explanation = t("modals.overtimeExplanation").replace(
        "{hours}",
        Utils.formatHoursToHM(this.hoursOverThreshold)
      );
      noticeDiv.appendText(explanation);
    }
    contentEl.createEl("p", {
      text: t("modals.commentPrompt"),
      cls: "tf-comment-prompt"
    });
    const textarea = contentEl.createEl("textarea", {
      cls: "tf-comment-textarea",
      attr: {
        rows: "4",
        maxlength: "500",
        placeholder: this.timer.comment || ""
      }
    });
    textarea.value = this.timer.comment || "";
    const charCount = contentEl.createDiv({ cls: "tf-comment-char-count" });
    const updateCharCount = () => {
      charCount.textContent = `${textarea.value.length}/500`;
    };
    updateCharCount();
    textarea.addEventListener("input", updateCharCount);
    const buttonDiv = contentEl.createDiv({ cls: "tf-comment-buttons" });
    const skipBtn = buttonDiv.createEl("button", {
      text: t("modals.skip"),
      cls: "tf-comment-skip-btn"
    });
    if (this.isRequired) {
      skipBtn.disabled = true;
      skipBtn.addClass("tf-comment-skip-disabled");
      skipBtn.title = t("modals.commentRequired");
    }
    skipBtn.addEventListener("click", async () => {
      this.close();
      await this.onSkip();
    });
    const saveBtn = buttonDiv.createEl("button", {
      text: t("buttons.save"),
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", async () => {
      const comment = textarea.value.trim();
      if (this.isRequired && !comment) {
        textarea.addClass("tf-comment-textarea-error");
        return;
      }
      this.close();
      await this.onSubmit(comment);
    });
    textarea.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/uiBuilder.ts
var UIBuilder = class {
  constructor(dataManager, systemStatus, settings, app, timerManager, plugin) {
    this.intervals = [];
    this.statsTimeframe = "month";
    this.historyView = "list";
    this.currentMonthOffset = 0;
    this.historyFilter = [];
    // empty = all, or list of type IDs to filter by
    this.inlineEditMode = false;
    // toggle for inline editing in wide view
    this.isModalOpen = false;
    this.data = dataManager;
    this.systemStatus = systemStatus;
    this.settings = settings;
    this.app = app;
    this.timerManager = timerManager;
    this.plugin = plugin;
    this.container = this.createContainer();
    this.today = /* @__PURE__ */ new Date();
    this.selectedYear = this.today.getFullYear();
    this.selectedMonth = this.today.getMonth();
    this.elements = {
      badge: null,
      complianceBadge: null,
      timerBadge: null,
      clock: null,
      dayCard: null,
      weekCard: null,
      statsCard: null,
      monthCard: null
    };
  }
  getBalanceColor(balance) {
    const t2 = this.settings.balanceThresholds;
    const colors = this.settings.customColors;
    if (balance < t2.criticalLow || balance > t2.criticalHigh)
      return (colors == null ? void 0 : colors.balanceCritical) || "#f44336";
    if (balance < t2.warningLow || balance > t2.warningHigh)
      return (colors == null ? void 0 : colors.balanceWarning) || "#ff9800";
    return (colors == null ? void 0 : colors.balanceOk) || "#4caf50";
  }
  darkenColor(color, percent) {
    const hex = color.replace("#", "");
    const r = Math.max(0, parseInt(hex.substring(0, 2), 16) - percent);
    const g = Math.max(0, parseInt(hex.substring(2, 4), 16) - percent);
    const b = Math.max(0, parseInt(hex.substring(4, 6), 16) - percent);
    return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
  }
  /**
   * Validate time input and parse hours/minutes.
   * Returns null if invalid, otherwise returns { hours, minutes }.
   */
  parseTimeInput(value) {
    if (!value || !value.includes(":")) return null;
    const parts = value.split(":");
    if (parts.length !== 2) return null;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    if (isNaN(hours) || isNaN(minutes)) return null;
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
    return { hours, minutes };
  }
  /**
   * Create a text-based time input with validation (HH:MM format).
   * Uses a regular text input instead of type="time" to avoid clock pickers on mobile.
   */
  createTimeInput(initialValue, onChange) {
    const input = document.createElement("input");
    input.type = "text";
    input.value = initialValue;
    input.placeholder = "Hh:mm";
    input.maxLength = 5;
    input.pattern = "[0-2][0-9]:[0-5][0-9]";
    input.inputMode = "numeric";
    input.classList.add("tf-time-input");
    let lastValidValue = initialValue;
    input.oninput = () => {
      let val = input.value.replace(/[^0-9]/g, "");
      if (val.length >= 3) {
        val = val.slice(0, 2) + ":" + val.slice(2, 4);
      }
      if (val.length > 5) val = val.slice(0, 5);
      input.value = val;
    };
    input.onblur = () => {
      if (!input.value) {
        input.value = lastValidValue;
        return;
      }
      const parsed = this.parseTimeInput(input.value);
      if (parsed) {
        const formatted = `${parsed.hours.toString().padStart(2, "0")}:${parsed.minutes.toString().padStart(2, "0")}`;
        input.value = formatted;
        lastValidValue = formatted;
        void onChange(formatted);
      } else {
        new import_obsidian5.Notice(t("validation.invalidTime"));
        input.value = lastValidValue;
      }
    };
    input.onkeydown = (e) => {
      if (e.key === "Enter") {
        input.blur();
      }
    };
    return input;
  }
  /**
   * Wrapper for timerManager.save() with error handling.
   * Shows a notice on failure and returns false.
   */
  async saveWithErrorHandling() {
    try {
      await this.timerManager.save();
      return true;
    } catch (error) {
      console.error("TimeFlow: Error saving data:", error);
      new import_obsidian5.Notice(t("notifications.saveError"));
      return false;
    }
  }
  createContainer() {
    const container = document.createElement("div");
    container.className = "tf-container";
    return container;
  }
  // Note: Styles are now in styles.css instead of being injected dynamically
  buildBadgeSection() {
    const section = document.createElement("div");
    section.className = "tf-badge-section";
    const badge = document.createElement("div");
    badge.className = "tf-badge";
    this.elements.badge = badge;
    const clock = document.createElement("div");
    clock.className = "tf-clock";
    this.elements.clock = clock;
    const complianceBadge = document.createElement("div");
    complianceBadge.className = "tf-compliance-badge";
    this.elements.complianceBadge = complianceBadge;
    const timerBadge = document.createElement("button");
    timerBadge.className = "tf-timer-badge";
    this.elements.timerBadge = timerBadge;
    if (!this.settings.enableGoalTracking) {
      badge.addClass("tf-hidden");
      complianceBadge.addClass("tf-hidden");
    }
    section.appendChild(badge);
    section.appendChild(clock);
    section.appendChild(complianceBadge);
    section.appendChild(timerBadge);
    this.updateBadge();
    this.updateComplianceBadge();
    this.updateTimerBadge();
    this.updateClock();
    return section;
  }
  updateTimerBadge() {
    if (!this.elements.timerBadge) return;
    const activeTimers = this.timerManager.getActiveTimers();
    if (activeTimers.length === 0) {
      this.elements.timerBadge.empty();
      this.elements.timerBadge.className = "tf-timer-badge tf-bg-transparent tf-inline-flex tf-items-stretch tf-gap-0 tf-p-0 tf-relative";
      this.elements.timerBadge.onclick = null;
      const startBtn = document.createElement("div");
      startBtn.textContent = "Start";
      startBtn.className = "tf-timer-start-btn";
      startBtn.onclick = async (e) => {
        e.stopPropagation();
        const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
        const timerName = (workType == null ? void 0 : workType.id) || "jobb";
        await this.timerManager.startTimer(timerName);
        this.updateTimerBadge();
      };
      const arrowBtn = document.createElement("div");
      arrowBtn.textContent = "\u25BC";
      arrowBtn.className = "tf-timer-dropdown-btn";
      arrowBtn.onclick = (e) => {
        e.stopPropagation();
        this.showTimerTypeMenu(arrowBtn);
      };
      this.elements.timerBadge.appendChild(startBtn);
      this.elements.timerBadge.appendChild(arrowBtn);
    } else {
      this.elements.timerBadge.empty();
      this.elements.timerBadge.textContent = t("buttons.stop");
      this.elements.timerBadge.className = "tf-timer-badge tf-timer-stop-btn";
      this.elements.timerBadge.onclick = async () => {
        for (const timer of activeTimers) {
          await this.stopTimerWithCommentCheck(timer);
        }
        this.updateTimerBadge();
      };
    }
  }
  /**
   * Stop a timer with optional comment modal.
   * Shows comment modal; skip is disabled if overtime threshold is exceeded.
   */
  async stopTimerWithCommentCheck(timer) {
    if (!timer.startTime) return;
    const start = new Date(timer.startTime);
    const now = /* @__PURE__ */ new Date();
    let duration = Utils.hoursDiff(start, now);
    if (timer.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
      duration = Math.max(0, duration - this.settings.lunchBreakMinutes / 60);
    }
    const dateStr = Utils.toLocalDateStr(start);
    const commentCheck = this.data.checkCommentRequired(dateStr, timer.name, duration);
    return new Promise((resolve) => {
      const modal = new CommentModal(
        this.app,
        timer,
        commentCheck.required,
        commentCheck.hoursOverThreshold,
        async (comment) => {
          timer.comment = comment || void 0;
          await this.timerManager.stopTimer(timer);
          resolve();
        },
        async () => {
          await this.timerManager.stopTimer(timer);
          resolve();
        }
      );
      modal.open();
    });
  }
  showTimerTypeMenu(button) {
    const existingMenu = document.querySelector(".tf-timer-type-menu");
    if (existingMenu) {
      existingMenu.remove();
      return;
    }
    const menu = document.createElement("div");
    menu.className = "tf-timer-type-menu";
    const defaultTimerTypes = ["jobb", "studie", "kurs"];
    const timerTypes = this.settings.specialDayBehaviors.filter((b) => {
      var _a;
      return (_a = b.showInTimerDropdown) != null ? _a : defaultTimerTypes.includes(b.id);
    }).map((b) => ({
      name: b.id,
      icon: b.icon,
      label: translateSpecialDayName(b.id, b.label)
    }));
    timerTypes.forEach((type) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.createSpan({ text: type.icon });
      item.createSpan({ text: type.label });
      item.onclick = async () => {
        await this.timerManager.startTimer(type.name);
        this.updateTimerBadge();
        menu.remove();
      };
      menu.appendChild(item);
    });
    document.body.appendChild(menu);
    const rect = button.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const margin = 10;
    let top = rect.bottom + 5;
    let left = rect.left;
    if (top + menuRect.height + margin > viewportHeight) {
      top = rect.top - menuRect.height - 5;
    }
    if (left + menuRect.width + margin > viewportWidth) {
      left = viewportWidth - menuRect.width - margin;
    }
    if (left < margin) {
      left = margin;
    }
    if (top < margin) {
      top = margin;
    }
    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 0);
  }
  buildSummaryCards() {
    const container = document.createElement("div");
    container.className = "tf-summary-cards";
    container.appendChild(this.createDayCard());
    container.appendChild(this.createWeekCard());
    container.appendChild(this.createMonthCard());
    return container;
  }
  createDayCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-day";
    this.elements.dayCard = card;
    this.updateDayCard();
    return card;
  }
  createWeekCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-week";
    this.elements.weekCard = card;
    this.updateWeekCard();
    return card;
  }
  createMonthCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-month";
    const header = document.createElement("div");
    header.className = "tf-card-header";
    const title = document.createElement("h3");
    title.textContent = t("ui.calendar");
    title.className = "tf-card-title";
    const controls = document.createElement("div");
    controls.className = "tf-card-controls";
    const prevBtn = document.createElement("button");
    prevBtn.textContent = "\u25C4";
    prevBtn.className = "tf-button";
    prevBtn.onclick = () => {
      this.currentMonthOffset--;
      this.updateMonthCard();
    };
    const todayBtn = document.createElement("button");
    todayBtn.textContent = t("ui.today");
    todayBtn.className = "tf-button";
    todayBtn.onclick = () => {
      this.currentMonthOffset = 0;
      this.updateMonthCard();
    };
    const nextBtn = document.createElement("button");
    nextBtn.textContent = "\u25BA";
    nextBtn.className = "tf-button";
    nextBtn.onclick = () => {
      this.currentMonthOffset++;
      this.updateMonthCard();
    };
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);
    header.appendChild(title);
    header.appendChild(controls);
    card.appendChild(header);
    const gridContainer = document.createElement("div");
    this.elements.monthCard = gridContainer;
    card.appendChild(gridContainer);
    const futureDaysContainer = document.createElement("div");
    futureDaysContainer.className = "tf-future-days-list";
    card.appendChild(futureDaysContainer);
    this.updateMonthCard();
    return card;
  }
  createStatsCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-stats";
    const contentWrapper = document.createElement("div");
    contentWrapper.className = "tf-collapsible-content open";
    const headerRow = document.createElement("div");
    headerRow.className = "tf-collapsible tf-stats-header";
    const header = document.createElement("h3");
    header.textContent = t("ui.statistics");
    header.className = "tf-m-0";
    headerRow.appendChild(header);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs tf-tabs-inline";
    const timeframes = ["month", "year", "total"];
    const labels = { month: t("timeframes.month"), year: t("timeframes.year"), total: t("timeframes.total") };
    timeframes.forEach((tf) => {
      const tab = document.createElement("button");
      tab.className = `tf-tab ${tf === this.statsTimeframe ? "active" : ""}`;
      tab.textContent = labels[tf];
      tab.onclick = () => {
        this.statsTimeframe = tf;
        tabs.querySelectorAll(".tf-tab").forEach((t2) => t2.classList.remove("active"));
        tab.classList.add("active");
        if (!contentWrapper.classList.contains("open")) {
          contentWrapper.classList.add("open");
        }
        this.updateStatsCard();
      };
      tabs.appendChild(tab);
    });
    headerRow.appendChild(tabs);
    card.appendChild(headerRow);
    const timeframeSelectorContainer = document.createElement("div");
    timeframeSelectorContainer.className = "tf-timeframe-selector";
    contentWrapper.appendChild(timeframeSelectorContainer);
    const statsContainer = document.createElement("div");
    statsContainer.className = "tf-stats-grid";
    this.elements.statsCard = statsContainer;
    contentWrapper.appendChild(statsContainer);
    card.appendChild(contentWrapper);
    header.onclick = () => {
      contentWrapper.classList.toggle("open");
    };
    header.addClass("tf-cursor-pointer");
    this.updateStatsCard();
    return card;
  }
  buildInfoCard() {
    var _a, _b, _c, _d;
    const card = document.createElement("div");
    card.className = "tf-card tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible";
    const h3 = header.createEl("h3", { text: t("ui.information") });
    h3.className = "tf-m-0";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const specialDayInfo = this.settings.specialDayBehaviors.filter((b) => !b.isWorkType).map((behavior) => ({
      key: behavior.id,
      emoji: behavior.icon,
      desc: this.getFlextimeEffectDescription(behavior)
    }));
    specialDayInfo.push({ key: t("ui.noRegistration"), emoji: "\u26AA", desc: t("ui.noDataForDay") });
    const infoGrid = content.createDiv({ cls: "tf-info-grid" });
    const leftColumn = infoGrid.createDiv({ cls: "tf-info-column" });
    const specialDaysBox = leftColumn.createDiv({ cls: "tf-info-box" });
    specialDaysBox.createEl("h4", { text: t("info.specialDayTypes") });
    const specialDaysList = specialDaysBox.createEl("ul");
    specialDaysList.className = "tf-legend-list";
    specialDayInfo.forEach((item) => {
      const color = getSpecialDayColors(this.settings)[item.key] || "transparent";
      const label = translateSpecialDayName(item.key);
      const li = specialDaysList.createEl("li");
      li.className = "tf-legend-item";
      const colorBox = li.createDiv();
      colorBox.className = "tf-legend-color-dynamic";
      colorBox.setCssProps({ "--tf-bg": color });
      const textSpan = li.createSpan({ text: item.emoji + " " });
      textSpan.createEl("strong", { text: label });
      textSpan.appendText(": " + item.desc);
    });
    if (this.settings.enableGoalTracking) {
      const gradientBox = leftColumn.createDiv({ cls: "tf-info-box" });
      gradientBox.createEl("h4", { text: t("info.workDaysGradient") });
      const gradientP = gradientBox.createEl("p", { text: t("info.colorShowsFlextime") + " (" + this.settings.baseWorkday + "h):" });
      gradientP.className = "tf-info-text";
      const posGradient = gradientBox.createDiv();
      posGradient.className = "tf-gradient-dynamic";
      posGradient.setCssProps({ "--tf-gradient": `linear-gradient(to right, ${this.flextimeColor(0)}, ${this.flextimeColor(1.5)}, ${this.flextimeColor(3)})` });
      const posLabels = gradientBox.createDiv();
      posLabels.className = "tf-gradient-labels";
      posLabels.createSpan({ text: "0h" });
      posLabels.createSpan({ text: "+1.5h" });
      posLabels.createSpan({ text: "+3h" });
      const workBehavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.isWorkType);
      const negBaseColor = (workBehavior == null ? void 0 : workBehavior.negativeColor) || "#64b5f6";
      const negGradient = gradientBox.createDiv();
      negGradient.className = "tf-gradient-dynamic";
      negGradient.setCssProps({ "--tf-gradient": `linear-gradient(to right, ${this.flextimeColor(-3)}, ${this.flextimeColor(-1.5)}, ${negBaseColor})` });
      const negLabels = gradientBox.createDiv();
      negLabels.className = "tf-gradient-labels";
      negLabels.createSpan({ text: "-3h" });
      negLabels.createSpan({ text: "-1.5h" });
      negLabels.createSpan({ text: "0h" });
    }
    const rightColumn = infoGrid.createDiv({ cls: "tf-info-column" });
    const calendarBox = rightColumn.createDiv({ cls: "tf-info-box" });
    calendarBox.createEl("h4", { text: t("info.calendarContextMenu") });
    const calendarP = calendarBox.createEl("p", { text: t("info.clickDayFor") });
    calendarP.className = "tf-info-text-small";
    const calendarList = calendarBox.createEl("ul");
    calendarList.className = "tf-info-list";
    calendarList.createEl("li", { text: t("info.createDailyNote") });
    calendarList.createEl("li", { text: t("info.editFlextimeManually") });
    calendarList.createEl("li", { text: t("info.registerSpecialDays") });
    const createColorRow = (container, color, label, desc) => {
      const row = container.createDiv();
      row.className = "tf-color-row";
      const colorSpan = row.createSpan();
      colorSpan.className = "tf-color-indicator tf-dynamic-bg";
      colorSpan.setCssProps({ "--tf-bg": color });
      const textSpan = row.createSpan();
      textSpan.createEl("strong", { text: label + ":" });
      textSpan.appendText(" " + desc);
    };
    if (this.settings.enableGoalTracking) {
      const balanceBox = rightColumn.createDiv({ cls: "tf-info-box" });
      balanceBox.createEl("h4", { text: t("info.flextimeBalanceZones") });
      const balanceContainer = balanceBox.createDiv();
      balanceContainer.className = "tf-balance-container";
      createColorRow(balanceContainer, ((_b = this.settings.customColors) == null ? void 0 : _b.balanceOk) || "#4caf50", t("info.green"), this.settings.balanceThresholds.warningLow + "h " + t("info.to") + " +" + this.settings.balanceThresholds.warningHigh + "h");
      createColorRow(balanceContainer, ((_c = this.settings.customColors) == null ? void 0 : _c.balanceWarning) || "#ff9800", t("info.yellow"), this.settings.balanceThresholds.criticalLow + "h " + t("info.to") + " " + (this.settings.balanceThresholds.warningLow - 1) + "h / +" + this.settings.balanceThresholds.warningHigh + "h " + t("info.to") + " +" + this.settings.balanceThresholds.criticalHigh + "h");
      createColorRow(balanceContainer, ((_d = this.settings.customColors) == null ? void 0 : _d.balanceCritical) || "#f44336", t("info.red"), "<" + this.settings.balanceThresholds.criticalLow + "h / >+" + this.settings.balanceThresholds.criticalHigh + "h");
      const weekBox = rightColumn.createDiv({ cls: "tf-info-box" });
      weekBox.createEl("h4", { text: t("info.weekNumberCompliance") });
      const weekContainer = weekBox.createDiv();
      weekContainer.className = "tf-balance-container";
      createColorRow(weekContainer, "linear-gradient(135deg, #c8e6c9, #a5d6a7)", t("info.green"), t("info.reachedGoal") + " (\xB10.5h)");
      createColorRow(weekContainer, "linear-gradient(135deg, #ffcdd2, #ef9a9a)", t("info.red"), t("info.overGoal"));
      createColorRow(weekContainer, "linear-gradient(135deg, #ffe0b2, #ffcc80)", t("info.orange"), t("info.underGoal"));
      createColorRow(weekContainer, "linear-gradient(135deg, #e0e0e0, #bdbdbd)", t("info.gray"), t("info.weekInProgress"));
      const weekTip = weekBox.createEl("p");
      weekTip.className = "tf-tip-text";
      weekTip.createEl("em", { text: t("info.clickWeekForDetails") });
    }
    header.onclick = () => {
      content.classList.toggle("open");
    };
    card.appendChild(header);
    card.appendChild(content);
    return card;
  }
  buildHistoryCard() {
    const card = document.createElement("div");
    card.className = "tf-card tf-card-history tf-card-spaced";
    const header = document.createElement("div");
    header.className = "tf-collapsible tf-history-header";
    const title = document.createElement("h3");
    title.textContent = t("ui.history");
    title.className = "tf-history-title";
    header.appendChild(title);
    const rightControls = document.createElement("div");
    rightControls.className = "tf-history-controls";
    const content = document.createElement("div");
    content.className = "tf-collapsible-content";
    const detailsElement = document.createElement("div");
    detailsElement.className = "tf-history-content";
    const exportBtn = document.createElement("button");
    exportBtn.className = "tf-history-export-btn";
    exportBtn.textContent = `\u{1F4E5} ${t("buttons.export")}`;
    exportBtn.title = t("export.csvTooltip");
    exportBtn.onclick = (e) => {
      e.stopPropagation();
      this.exportHistoryToCSV();
    };
    rightControls.appendChild(exportBtn);
    const editToggle = document.createElement("button");
    editToggle.className = `tf-history-edit-btn ${this.inlineEditMode ? "active" : ""}`;
    editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
    editToggle.onclick = (e) => {
      e.stopPropagation();
      this.inlineEditMode = !this.inlineEditMode;
      editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
      editToggle.classList.toggle("active", this.inlineEditMode);
      this.refreshHistoryView(detailsElement);
    };
    rightControls.appendChild(editToggle);
    const tabs = document.createElement("div");
    tabs.className = "tf-tabs tf-tabs-inline";
    const views = [
      { id: "list", label: t("buttons.list") },
      { id: "heatmap", label: t("buttons.heatmap") }
    ];
    views.forEach((view) => {
      const tab = document.createElement("button");
      tab.textContent = view.label;
      tab.className = `tf-tab ${this.historyView === view.id ? "active" : ""}`;
      tab.onclick = (e) => {
        e.stopPropagation();
        this.historyView = view.id;
        this.inlineEditMode = false;
        editToggle.textContent = `\u270F\uFE0F ${t("buttons.edit")}`;
        editToggle.classList.remove("active");
        tabs.querySelectorAll(".tf-tab").forEach((t2) => t2.classList.remove("active"));
        tab.classList.add("active");
        if (!content.classList.contains("open")) {
          content.classList.add("open");
        }
        this.refreshHistoryView(detailsElement);
      };
      tabs.appendChild(tab);
    });
    rightControls.appendChild(tabs);
    header.appendChild(rightControls);
    editToggle.addClass("tf-history-edit-toggle");
    content.appendChild(detailsElement);
    header.onclick = () => {
      content.classList.toggle("open");
    };
    header.addClass("tf-cursor-pointer");
    card.appendChild(header);
    card.appendChild(content);
    this.refreshHistoryView(detailsElement);
    requestAnimationFrame(() => {
      this.updateEditToggleVisibility(detailsElement);
    });
    let lastWasWide = detailsElement.offsetWidth >= 450;
    const resizeObserver = new ResizeObserver(() => {
      const isWide = detailsElement.offsetWidth >= 450;
      if (isWide !== lastWasWide && this.historyView === "list") {
        lastWasWide = isWide;
        this.refreshHistoryView(detailsElement);
      }
      this.updateEditToggleVisibility(detailsElement);
    });
    resizeObserver.observe(detailsElement);
    return card;
  }
  buildStatusBar() {
    var _a, _b, _c, _d, _e, _f;
    const bar = document.createElement("div");
    bar.className = "tf-status-bar";
    const status = this.systemStatus;
    const hasErrors = (_a = status.validation) == null ? void 0 : _a.hasErrors;
    const hasWarnings = (_b = status.validation) == null ? void 0 : _b.hasWarnings;
    const statusIcon = hasErrors ? "\u274C" : hasWarnings ? "\u26A0\uFE0F" : "\u2705";
    const hasIssues = hasErrors || hasWarnings;
    const buildIssuesContent = (container) => {
      var _a2;
      if (hasIssues && ((_a2 = status.validation) == null ? void 0 : _a2.issues)) {
        const errors = status.validation.issues.errors || [];
        const warnings = status.validation.issues.warnings || [];
        if (errors.length > 0) {
          const errorHeader = container.createDiv();
          errorHeader.className = "tf-status-error";
          const errorStrong = errorHeader.createEl("strong");
          errorStrong.className = "tf-status-error-label";
          errorStrong.textContent = `Feil (${errors.length}):`;
          errors.slice(0, 5).forEach((err) => {
            const errorItem = container.createDiv();
            errorItem.className = "tf-status-error-item";
            errorItem.textContent = `\u2022 ${err.type}: ${err.description}${err.date ? ` (${err.date})` : ""}`;
          });
          if (errors.length > 5) {
            const moreErrors = container.createDiv();
            moreErrors.className = "tf-status-more";
            moreErrors.textContent = `...og ${errors.length - 5} flere feil`;
          }
        }
        if (warnings.length > 0) {
          const warningHeader = container.createDiv();
          warningHeader.className = "tf-status-error";
          const warningStrong = warningHeader.createEl("strong");
          warningStrong.className = "tf-status-warning-label";
          warningStrong.textContent = `Advarsler (${warnings.length}):`;
          warnings.slice(0, 5).forEach((warn) => {
            const warningItem = container.createDiv();
            warningItem.className = "tf-status-warning-item";
            warningItem.textContent = `\u2022 ${warn.type}: ${warn.description}${warn.date ? ` (${warn.date})` : ""}`;
          });
          if (warnings.length > 5) {
            const moreWarnings = container.createDiv();
            moreWarnings.className = "tf-status-more";
            moreWarnings.textContent = `...og ${warnings.length - 5} flere advarsler`;
          }
        }
      }
    };
    const header = document.createElement("div");
    header.className = "tf-status-header";
    header.createSpan({ text: statusIcon });
    const headerContent = header.createDiv();
    headerContent.className = "tf-status-content";
    const titleRow = headerContent.createDiv();
    titleRow.createEl("strong", { text: t("status.systemStatus") });
    if (hasIssues) {
      titleRow.createSpan({ text: ` (${t("status.clickForDetails")})`, cls: "tf-status-hint" });
    }
    const statusRow = headerContent.createDiv();
    statusRow.className = "tf-status-row";
    const statusText = statusRow.createSpan();
    statusText.textContent = `${((_c = status.holiday) == null ? void 0 : _c.message) || t("status.holidayNotLoaded")} \u2022 ${status.activeTimers || 0} ${t("status.activeTimers")} \u2022 ${((_f = (_e = (_d = status.validation) == null ? void 0 : _d.issues) == null ? void 0 : _e.stats) == null ? void 0 : _f.totalEntries) || 0} ${t("status.entriesChecked")}`;
    const versionText = statusRow.createSpan();
    versionText.className = "tf-status-version";
    versionText.textContent = `v${this.plugin.manifest.version}`;
    if (hasIssues) {
      header.createSpan({ cls: "tf-status-toggle", text: "\u25B6" });
    }
    bar.appendChild(header);
    if (hasIssues) {
      const details = document.createElement("div");
      details.className = "tf-status-details";
      const detailsInner = details.createDiv();
      detailsInner.className = "tf-status-details-inner";
      buildIssuesContent(detailsInner);
      bar.appendChild(details);
      let isOpen = false;
      header.onclick = () => {
        isOpen = !isOpen;
        const toggle = header.querySelector(".tf-status-toggle");
        if (toggle) {
          toggle.setCssProps({ "--tf-rotate": isOpen ? "90deg" : "0deg" });
        }
        if (isOpen) {
          details.setCssProps({ "--tf-max-height": details.scrollHeight + "px", "--tf-opacity": "1" });
        } else {
          details.setCssProps({ "--tf-max-height": "0", "--tf-opacity": "0" });
        }
      };
    }
    return bar;
  }
  buildViewToggle() {
    const container = document.createElement("div");
    container.className = "tf-view-toggle-container";
    const viewToggle = document.createElement("button");
    const isInSidebar = this.isViewInSidebar();
    viewToggle.className = "tf-view-toggle-btn";
    const iconSpan = viewToggle.createSpan({ cls: "tf-view-toggle-icon" });
    iconSpan.textContent = isInSidebar ? "\u229E" : "\u25E7";
    viewToggle.appendText(" " + (isInSidebar ? t("buttons.moveToMain") : t("buttons.moveToSidebar")));
    viewToggle.title = isInSidebar ? t("buttons.moveToMain") : t("buttons.moveToSidebar");
    viewToggle.onclick = (e) => {
      e.stopPropagation();
      const newLocation = isInSidebar ? "main" : "sidebar";
      void this.plugin.moveViewToLocation(newLocation);
    };
    container.appendChild(viewToggle);
    return container;
  }
  updateClock() {
    if (!this.elements.clock) return;
    const now = /* @__PURE__ */ new Date();
    this.elements.clock.textContent = now.toLocaleTimeString("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  updateBadge() {
    if (!this.elements.badge) return;
    const balance = this.data.getCurrentBalance();
    const formatted = Utils.formatHoursToHM(Math.abs(balance), this.settings.hourUnit);
    const sign = balance >= 0 ? "+" : "-";
    const color = this.getBalanceColor(balance);
    this.elements.badge.setCssProps({ "--tf-bg": color, "--tf-color": "white" });
    this.elements.badge.textContent = `${t("ui.flextimeBalance")}: ${sign}${formatted}`;
  }
  /**
   * Check if the current view is in the sidebar (right or left)
   */
  isViewInSidebar() {
    const leaves = this.app.workspace.getLeavesOfType("timeflow-view");
    if (leaves.length === 0) return true;
    const leaf = leaves[0];
    const root = leaf.getRoot();
    return root === this.app.workspace.rightSplit || root === this.app.workspace.leftSplit;
  }
  /**
   * Get compliance status: 'ok' | 'approaching' | 'exceeded'
   * Based on daily and weekly hours compared to limits
   */
  getComplianceStatus() {
    var _a, _b, _c, _d, _e;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      return { status: "ok", dailyStatus: "ok", weeklyStatus: "ok", tooltip: "" };
    }
    const today = /* @__PURE__ */ new Date();
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const weeklyLimit = (_e = (_d = this.settings.complianceSettings) == null ? void 0 : _d.weeklyHoursLimit) != null ? _e : 40;
    const dailyApproaching = this.settings.baseWorkday * this.settings.workPercent;
    const weeklyApproaching = this.settings.baseWorkweek * this.settings.workPercent;
    let dailyStatus = "ok";
    let weeklyStatus = "ok";
    if (todayHours >= dailyLimit) {
      dailyStatus = "exceeded";
    } else if (todayHours >= dailyApproaching) {
      dailyStatus = "approaching";
    }
    if (weekHours >= weeklyLimit) {
      weeklyStatus = "exceeded";
    } else if (weekHours >= weeklyApproaching) {
      weeklyStatus = "approaching";
    }
    let status = "ok";
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded") {
      status = "exceeded";
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      status = "approaching";
    }
    const tooltipParts = [];
    if (dailyStatus === "exceeded") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit} (max ${dailyLimit}${this.settings.hourUnit})`);
    } else if (dailyStatus === "approaching") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit} (${t("status.approachingLimits")} ${dailyLimit}${this.settings.hourUnit})`);
    }
    if (weeklyStatus === "exceeded") {
      tooltipParts.push(`${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} (max ${weeklyLimit}${this.settings.hourUnit})`);
    } else if (weeklyStatus === "approaching") {
      tooltipParts.push(`${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} (${t("status.approachingLimits")} ${weeklyLimit}${this.settings.hourUnit})`);
    }
    if (tooltipParts.length === 0 && status === "ok") {
      tooltipParts.push(`${t("ui.today")}: ${todayHours.toFixed(1)}${this.settings.hourUnit}, ${t("ui.week")}: ${weekHours.toFixed(1)}${this.settings.hourUnit} - ${t("status.withinLimits")}`);
    }
    return { status, dailyStatus, weeklyStatus, tooltip: tooltipParts.join("\n") };
  }
  /**
   * Update compliance status badge
   */
  updateComplianceBadge() {
    var _a;
    if (!this.elements.complianceBadge) return;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) {
      this.elements.complianceBadge.addClass("tf-hidden");
      return;
    }
    const { status } = this.getComplianceStatus();
    this.elements.complianceBadge.removeClass("tf-hidden");
    this.elements.complianceBadge.removeClass("tf-compliance-ok", "tf-compliance-approaching", "tf-compliance-over");
    if (status === "ok") {
      this.elements.complianceBadge.addClass("tf-compliance-ok");
      this.elements.complianceBadge.textContent = `\u{1F7E9} ${t("compliance.ok")}`;
    } else if (status === "approaching") {
      this.elements.complianceBadge.addClass("tf-compliance-approaching");
      this.elements.complianceBadge.textContent = `\u{1F7E8} ${t("compliance.near")}`;
    } else {
      this.elements.complianceBadge.addClass("tf-compliance-over");
      this.elements.complianceBadge.textContent = `\u{1F7E5} ${t("compliance.over")}`;
    }
    this.elements.complianceBadge.onclick = (e) => {
      e.stopPropagation();
      this.showComplianceInfoPanel();
    };
  }
  /**
   * Show compliance info panel with detailed information
   */
  showComplianceInfoPanel() {
    var _a, _b, _c, _d, _e, _f;
    const existingPanel = document.querySelector(".tf-compliance-info-panel");
    if (existingPanel) {
      existingPanel.remove();
      return;
    }
    const today = /* @__PURE__ */ new Date();
    const todayStr = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    const weekHours = this.data.getCurrentWeekHours(today);
    const dailyLimit = (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9;
    const weeklyLimit = (_d = (_c = this.settings.complianceSettings) == null ? void 0 : _c.weeklyHoursLimit) != null ? _d : 40;
    const minimumRest = (_f = (_e = this.settings.complianceSettings) == null ? void 0 : _e.minimumRestHours) != null ? _f : 11;
    const { dailyStatus, weeklyStatus } = this.getComplianceStatus();
    const restCheck = this.data.checkRestPeriodViolation(todayStr);
    const panel = document.createElement("div");
    panel.className = "tf-compliance-info-panel";
    panel.createEl("h4", { text: `\u2696\uFE0F ${t("compliance.title")}` });
    const dailyIcon = dailyStatus === "ok" ? "\u{1F7E9}" : dailyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    const dailyP = panel.createEl("p");
    dailyP.createEl("strong", { text: `${t("ui.today")}: ` });
    dailyP.appendText(`${dailyIcon} ${todayHours.toFixed(1)}t / ${dailyLimit}t`);
    const weeklyIcon = weeklyStatus === "ok" ? "\u{1F7E9}" : weeklyStatus === "approaching" ? "\u{1F7E8}" : "\u{1F7E5}";
    const weeklyP = panel.createEl("p");
    weeklyP.createEl("strong", { text: `${t("ui.thisWeek")}: ` });
    weeklyP.appendText(`${weeklyIcon} ${weekHours.toFixed(1)}t / ${weeklyLimit}t`);
    if (restCheck.violated && restCheck.restHours !== null) {
      const restP = panel.createEl("p", { cls: "tf-rest-warning" });
      restP.createEl("strong", { text: `${t("ui.restPeriod")}: ` });
      restP.appendText(`\u{1F7E5} ${restCheck.restHours.toFixed(1)}t (${t("ui.minimum")} ${minimumRest}t)`);
    } else if (restCheck.restHours !== null) {
      const restP = panel.createEl("p");
      restP.createEl("strong", { text: `${t("ui.restPeriod")}: ` });
      restP.appendText(`\u{1F7E9} ${restCheck.restHours.toFixed(1)}t (${t("ui.minimum")} ${minimumRest}t)`);
    }
    panel.createEl("hr");
    let statusText;
    if (dailyStatus === "exceeded" || weeklyStatus === "exceeded" || restCheck.violated) {
      statusText = `${t("compliance.exceeds")} ${t("compliance.limit")}.`;
    } else if (dailyStatus === "approaching" || weeklyStatus === "approaching") {
      statusText = `${t("status.approachingLimits")} ${t("compliance.limit")}.`;
    } else {
      statusText = t("status.allLimitsOk");
    }
    panel.createEl("p", { text: statusText, cls: "tf-compliance-status-text" });
    const badgeRect = this.elements.complianceBadge.getBoundingClientRect();
    document.body.appendChild(panel);
    const panelRect = panel.getBoundingClientRect();
    const padding = 10;
    let top = badgeRect.bottom + 8;
    let right = window.innerWidth - badgeRect.right;
    const leftEdge = window.innerWidth - right - panelRect.width;
    if (leftEdge < padding) right = window.innerWidth - panelRect.width - padding;
    if (right < padding) right = padding;
    if (top + panelRect.height > window.innerHeight - padding) top = badgeRect.top - panelRect.height - 8;
    if (top < padding) top = padding;
    panel.style.top = `${top}px`;
    panel.style.right = `${right}px`;
    const closeHandler = (e) => {
      if (!panel.contains(e.target) && e.target !== this.elements.complianceBadge) {
        panel.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  /**
   * Generate compliance warning HTML for daily hours
   */
  getDailyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) return "";
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const approachingThreshold = this.settings.baseWorkday * this.settings.workPercent;
    if (hours >= dailyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger daglig grense p\xE5 ${dailyLimit} timer">\u26A0\uFE0F >${dailyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg daglig grense p\xE5 ${dailyLimit} timer">\u23F0 ${dailyLimit}t grense</span>`;
    }
    return "";
  }
  /**
   * Generate compliance warning HTML for weekly hours
   */
  getWeeklyComplianceWarning(hours) {
    var _a, _b, _c;
    if (!((_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings)) return "";
    const weeklyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.weeklyHoursLimit) != null ? _c : 40;
    const approachingThreshold = this.settings.baseWorkweek * this.settings.workPercent;
    if (hours >= weeklyLimit) {
      return `<span class="tf-compliance-warning exceeded" title="Overstiger ukentlig grense p\xE5 ${weeklyLimit} timer">\u26A0\uFE0F >${weeklyLimit}t</span>`;
    } else if (hours >= approachingThreshold) {
      return `<span class="tf-compliance-warning approaching" title="N\xE6rmer seg ukentlig grense p\xE5 ${weeklyLimit} timer">\u23F0 ${weeklyLimit}t grense</span>`;
    }
    return "";
  }
  updateDayCard() {
    var _a, _b;
    if (!this.elements.dayCard) return;
    const today = /* @__PURE__ */ new Date();
    const todayKey = Utils.toLocalDateStr(today);
    const todayHours = this.data.getTodayHours(today);
    this.updateComplianceBadge();
    if (!this.settings.enableGoalTracking) {
      this.elements.dayCard.setCssProps({ "--tf-bg": "var(--background-secondary)", "--tf-color": "var(--text-normal)" });
      this.elements.dayCard.empty();
      this.elements.dayCard.createEl("h3", { text: "I dag" });
      this.elements.dayCard.createDiv({ text: Utils.formatHoursToHM(todayHours, this.settings.hourUnit), cls: "tf-card-big-number" });
      this.elements.dayCard.createDiv({ text: t("ui.hoursWorked"), cls: "tf-card-label" });
      return;
    }
    const goal = this.data.getDailyGoal(todayKey);
    const progress = goal > 0 ? Math.min(todayHours / goal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (todayHours <= goal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (todayHours <= goal + 1.75) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.dayCard.setCssProps({ "--tf-bg": bgColor, "--tf-color": textColor });
    this.elements.dayCard.empty();
    this.elements.dayCard.createEl("h3", { text: t("ui.today") });
    this.elements.dayCard.createDiv({ text: Utils.formatHoursToHM(todayHours, this.settings.hourUnit), cls: "tf-card-big-number" });
    this.elements.dayCard.createDiv({ text: `${t("ui.goal")}: ${Utils.formatHoursToHM(goal, this.settings.hourUnit)}`, cls: "tf-card-goal" });
    const progressBar = this.elements.dayCard.createDiv({ cls: "tf-progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "tf-progress-fill" });
    progressFill.style.cssText = `width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})`;
  }
  updateWeekCard() {
    var _a, _b;
    if (!this.elements.weekCard) return;
    const today = /* @__PURE__ */ new Date();
    const weekHours = this.data.getCurrentWeekHours(today);
    const currentWeekNumber = Utils.getWeekNumber(today);
    const addWeekBadge = (container) => {
      if (this.settings.showWeekNumbers) {
        container.createDiv({ cls: "tf-week-badge", text: `${t("ui.week")} ${currentWeekNumber}` });
      }
    };
    if (!this.settings.enableGoalTracking) {
      this.elements.weekCard.setCssProps({ "--tf-bg": "var(--background-secondary)", "--tf-color": "var(--text-normal)" });
      this.elements.weekCard.empty();
      addWeekBadge(this.elements.weekCard);
      this.elements.weekCard.createEl("h3", { text: t("ui.thisWeek") });
      this.elements.weekCard.createDiv({ text: Utils.formatHoursToHM(weekHours, this.settings.hourUnit), cls: "tf-card-big-number" });
      this.elements.weekCard.createDiv({ text: t("ui.hoursWorked"), cls: "tf-card-label" });
      return;
    }
    const dayOfWeek = today.getDay();
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - daysFromMonday);
    let adjustedGoal = 0;
    for (let i = 0; i < 7; i++) {
      const d = new Date(firstDayOfWeek);
      d.setDate(firstDayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(d);
      const dayGoal = this.data.getDailyGoal(dayKey);
      adjustedGoal += dayGoal;
    }
    const progress = adjustedGoal > 0 ? Math.min(weekHours / adjustedGoal * 100, 100) : 0;
    let bgColor;
    let textColor;
    if (!this.settings.enableWeeklyGoals) {
      bgColor = "var(--background-secondary)";
      textColor = "var(--text-normal)";
    } else if (weekHours <= adjustedGoal) {
      bgColor = "linear-gradient(135deg, #4caf50, #81c784)";
      textColor = "white";
    } else if (weekHours <= adjustedGoal + 3.5) {
      bgColor = "linear-gradient(135deg, #ffeb3b, #ffc107)";
      textColor = "black";
    } else {
      bgColor = "linear-gradient(135deg, #f44336, #d32f2f)";
      textColor = "white";
    }
    this.elements.weekCard.setCssProps({ "--tf-bg": bgColor, "--tf-color": textColor });
    this.elements.weekCard.empty();
    addWeekBadge(this.elements.weekCard);
    this.elements.weekCard.createEl("h3", { text: t("ui.thisWeek") });
    this.elements.weekCard.createDiv({ text: Utils.formatHoursToHM(weekHours, this.settings.hourUnit), cls: "tf-card-big-number" });
    if (this.settings.enableWeeklyGoals) {
      this.elements.weekCard.createDiv({ text: `${t("ui.goal")}: ${Utils.formatHoursToHM(adjustedGoal, this.settings.hourUnit)}`, cls: "tf-card-goal" });
      const progressBar = this.elements.weekCard.createDiv({ cls: "tf-progress-bar" });
      const progressFill = progressBar.createDiv({ cls: "tf-progress-fill" });
      progressFill.style.cssText = `width: ${progress}%; background: linear-gradient(90deg, ${((_a = this.settings.customColors) == null ? void 0 : _a.progressBar) || "#4caf50"}, ${this.darkenColor(((_b = this.settings.customColors) == null ? void 0 : _b.progressBar) || "#4caf50", 20)})`;
    }
  }
  updateStatsCard() {
    var _a, _b;
    if (!this.elements.statsCard) return;
    const stats = this.data.getStatistics(this.statsTimeframe, this.selectedYear, this.selectedMonth);
    const balance = this.data.getCurrentBalance();
    const { avgDaily, avgWeekly } = this.data.getAverages();
    const expectedWeeklyHours = this.settings.baseWorkweek * this.settings.workPercent;
    const workloadPct = expectedWeeklyHours > 0 ? (avgWeekly / expectedWeeklyHours * 100).toFixed(0) : "0";
    const selectorContainer = (_a = this.elements.statsCard.parentElement) == null ? void 0 : _a.querySelector(".tf-timeframe-selector");
    if (selectorContainer) {
      selectorContainer.empty();
      if (this.statsTimeframe === "year") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.className = "tf-select";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
        }
      } else if (this.statsTimeframe === "month") {
        const availableYears = this.data.getAvailableYears();
        if (availableYears.length > 0) {
          const yearSelect = document.createElement("select");
          yearSelect.className = "tf-select";
          availableYears.forEach((year) => {
            const option = document.createElement("option");
            option.value = year.toString();
            option.textContent = year.toString();
            option.selected = year === this.selectedYear;
            yearSelect.appendChild(option);
          });
          yearSelect.onchange = () => {
            this.selectedYear = parseInt(yearSelect.value);
            const months = this.data.getAvailableMonthsForYear(this.selectedYear);
            if (months.length > 0) {
              this.selectedMonth = months[months.length - 1];
            }
            this.updateStatsCard();
          };
          selectorContainer.appendChild(yearSelect);
          const availableMonths = this.data.getAvailableMonthsForYear(this.selectedYear);
          if (availableMonths.length > 0) {
            const monthSelect = document.createElement("select");
            monthSelect.className = "tf-select";
            const monthNames = [
              "Januar",
              "Februar",
              "Mars",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Desember"
            ];
            availableMonths.forEach((month) => {
              const option = document.createElement("option");
              option.value = month.toString();
              option.textContent = monthNames[month];
              option.selected = month === this.selectedMonth;
              monthSelect.appendChild(option);
            });
            monthSelect.onchange = () => {
              this.selectedMonth = parseInt(monthSelect.value);
              this.updateStatsCard();
            };
            selectorContainer.appendChild(monthSelect);
          }
        }
      } else {
        const label = document.createElement("div");
        label.className = "tf-text-lg tf-font-bold";
        label.textContent = t("ui.total");
        selectorContainer.appendChild(label);
      }
    }
    const context = this.data.getContextualData(this.today);
    const sign = balance >= 0 ? "+" : "";
    const timesaldoColor = this.getBalanceColor(balance);
    let ferieDisplay = `${stats.ferie.count} ${t("ui.days")}`;
    if (this.statsTimeframe === "year" && stats.ferie.max && stats.ferie.max > 0) {
      const feriePercent = (stats.ferie.count / stats.ferie.max * 100).toFixed(0);
      ferieDisplay = `${stats.ferie.count}/${stats.ferie.max} ${t("ui.days")} (${feriePercent}%)`;
    }
    let egenmeldingDisplay = `${stats.egenmelding.count} ${t("ui.days")}`;
    let egenmeldingPeriodLabel = "";
    if (this.statsTimeframe === "year") {
      const egenmeldingStats = this.data.getSpecialDayStats("egenmelding", this.selectedYear);
      if (egenmeldingStats.max && egenmeldingStats.max > 0) {
        const egenmeldingPercent = (egenmeldingStats.count / egenmeldingStats.max * 100).toFixed(0);
        egenmeldingDisplay = `${egenmeldingStats.count}/${egenmeldingStats.max} ${t("ui.days")} (${egenmeldingPercent}%)`;
      } else {
        egenmeldingDisplay = `${egenmeldingStats.count} ${t("ui.days")}`;
      }
      egenmeldingPeriodLabel = `(${egenmeldingStats.periodLabel})`;
    }
    this.elements.statsCard.empty();
    const createStatItem = (label, value, subtitle, extraCls, extraStyle) => {
      const item = this.elements.statsCard.createDiv({ cls: `tf-stat-item${extraCls ? " " + extraCls : ""}` });
      if (extraStyle) item.style.cssText = extraStyle;
      item.createDiv({ cls: "tf-stat-label", text: label });
      const valueDiv = item.createDiv({ cls: "tf-stat-value", text: value });
      if (subtitle !== void 0) {
        item.createDiv({ text: subtitle, cls: "tf-stat-subtitle" });
      }
      return { item, valueDiv };
    };
    if (this.settings.enableGoalTracking) {
      createStatItem(t("stats.flextimeBalance"), `${sign}${Utils.formatHoursToHM(Math.abs(balance), this.settings.hourUnit)}`, t("stats.totalBalance"), "tf-stat-colored", `background: ${timesaldoColor};`);
    }
    if (!this.settings.hideEmptyStats || stats.totalHours > 0) {
      createStatItem(`\u23F1\uFE0F ${t("stats.hours")}`, `${stats.totalHours.toFixed(1)}t`);
    }
    if (!this.settings.hideEmptyStats || avgDaily > 0) {
      createStatItem(`\u{1F4CA} ${t("stats.avgPerDay")}`, `${avgDaily.toFixed(1)}t`);
    }
    if (!this.settings.hideEmptyStats || avgWeekly > 0) {
      const weekItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
      weekItem.createDiv({ cls: "tf-stat-label", text: `\u{1F4C5} ${t("stats.avgPerWeek")}` });
      weekItem.createDiv({ cls: "tf-stat-value", text: `${avgWeekly.toFixed(1)}t` });
      if (context.lastWeekHours > 0) {
        const currWeekHours = this.data.getCurrentWeekHours(this.today);
        const diff = currWeekHours - context.lastWeekHours;
        if (Math.abs(diff) > 2) {
          const arrow = diff > 0 ? "\u{1F4C8}" : "\u{1F4C9}";
          const signDiff = diff > 0 ? "+" : "";
          weekItem.createDiv({ text: `${t("ui.vsLastWeek")}: ${signDiff}${diff.toFixed(1)}t ${arrow}`, cls: "tf-comp-small" });
        }
      }
    }
    if (this.settings.enableGoalTracking && this.settings.enableWeeklyGoals) {
      createStatItem(`\u{1F4AA} ${t("stats.workIntensity")}`, `${workloadPct}%`, t("stats.ofNormalWeek"));
    }
    if (!this.settings.hideEmptyStats || stats.jobb.count > 0) {
      createStatItem(`\u{1F4BC} ${t("stats.work")}`, `${stats.jobb.count} ${t("ui.days")}`, `${stats.jobb.hours.toFixed(1)}t`);
    }
    if (stats.weekendDays > 0) {
      createStatItem(`\u{1F319} ${t("stats.weekendDaysWorked")}`, `${stats.weekendDays} ${t("ui.days")}`, `${stats.weekendHours.toFixed(1)}${this.settings.hourUnit}`);
    }
    if (!this.settings.hideEmptyStats || stats.avspasering.count > 0) {
      createStatItem(`\u{1F6CC} ${t("stats.flexTimeOff")}`, `${stats.avspasering.count} ${t("ui.days")}`, `${stats.avspasering.hours.toFixed(1)}${this.settings.hourUnit}`);
    }
    if (!this.settings.hideEmptyStats || stats.ferie.count > 0) {
      const vacationItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
      vacationItem.createDiv({ cls: "tf-stat-label", text: `\u{1F3D6}\uFE0F ${t("stats.vacation")}` });
      const sizeClass = this.statsTimeframe === "year" ? "tf-text-year-size" : "tf-text-default-size";
      vacationItem.createDiv({ cls: `tf-stat-value ${sizeClass}`, text: ferieDisplay });
      vacationItem.createDiv({ cls: "tf-stat-subtitle" });
    }
    if (!this.settings.hideEmptyStats || stats.velferdspermisjon.count > 0) {
      createStatItem(`\u{1F3E5} ${t("stats.welfareLeave")}`, `${stats.velferdspermisjon.count} ${t("ui.days")}`);
    }
    if (!this.settings.hideEmptyStats || stats.egenmelding.count > 0) {
      const sickItem = this.elements.statsCard.createDiv({ cls: "tf-stat-item" });
      sickItem.createDiv({ cls: "tf-stat-label", text: `\u{1F912} ${t("stats.selfReportedSick")}` });
      const sickSizeClass = this.statsTimeframe === "year" ? "tf-text-year-size" : "tf-text-default-size";
      sickItem.createDiv({ cls: `tf-stat-value ${sickSizeClass}`, text: egenmeldingDisplay });
      sickItem.createDiv({ text: egenmeldingPeriodLabel, cls: "tf-stat-subtitle" });
    }
    if (!this.settings.hideEmptyStats || stats.sykemelding.count > 0) {
      createStatItem(`\u{1F3E5} ${t("stats.doctorSick")}`, `${stats.sykemelding.count} ${t("ui.days")}`);
    }
    if (!this.settings.hideEmptyStats || stats.studie.count > 0) {
      createStatItem(`\u{1F4DA} ${t("stats.study")}`, `${stats.studie.count} ${t("ui.days")}`, `${stats.studie.hours.toFixed(1)}${this.settings.hourUnit}`);
    }
    if (!this.settings.hideEmptyStats || stats.kurs.count > 0) {
      createStatItem(`\u{1F4DA} ${t("stats.course")}`, `${stats.kurs.count} ${t("ui.days")}`, `${stats.kurs.hours.toFixed(1)}${this.settings.hourUnit}`);
    }
    this.renderHoursBarChart();
    const tabs = (_b = this.elements.statsCard.parentElement) == null ? void 0 : _b.querySelectorAll(".tf-tab");
    tabs == null ? void 0 : tabs.forEach((tab) => {
      var _a2;
      const timeframe = (_a2 = tab.textContent) == null ? void 0 : _a2.toLowerCase();
      if (timeframe === "totalt" && this.statsTimeframe === "total" || timeframe === "\xE5r" && this.statsTimeframe === "year" || timeframe === "m\xE5ned" && this.statsTimeframe === "month") {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
  }
  /**
   * Render the hours bar chart at the bottom of the stats card section
   */
  renderHoursBarChart() {
    var _a;
    if (!this.elements.statsCard) return;
    const contentWrapper = this.elements.statsCard.parentElement;
    if (!contentWrapper) return;
    const existingChart = contentWrapper.querySelector(".tf-hours-chart");
    if (existingChart) {
      existingChart.remove();
    }
    const chartData = this.data.getHistoricalHoursData(
      this.statsTimeframe,
      this.selectedYear,
      this.selectedMonth
    );
    if (chartData.length === 0) return;
    const maxHours = Math.max(...chartData.map((d) => d.hours), ...chartData.map((d) => d.target || 0));
    if (maxHours === 0) return;
    const chartContainer = document.createElement("div");
    chartContainer.className = "tf-hours-chart";
    contentWrapper.appendChild(chartContainer);
    const createDiv = (className, text) => {
      const div = document.createElement("div");
      div.className = className;
      if (text) div.textContent = text;
      return div;
    };
    let title = "";
    if (this.statsTimeframe === "month") {
      title = t("stats.weeklyHours") || "Uketimer";
    } else if (this.statsTimeframe === "year") {
      title = t("stats.monthlyHours") || "M\xE5nedstimer";
    } else {
      title = t("stats.yearlyHours") || "\xC5rstimer";
    }
    chartContainer.appendChild(createDiv("tf-hours-chart-title", title));
    const chartInner = createDiv("tf-hours-chart-container");
    chartContainer.appendChild(chartInner);
    const barsArea = createDiv("tf-hours-bars-area");
    chartInner.appendChild(barsArea);
    const maxBarHeight = 80;
    const bottomOffset = 20;
    const target = (_a = chartData[0]) == null ? void 0 : _a.target;
    if (target && target > 0) {
      const targetHeight = target / maxHours * maxBarHeight;
      const targetLine = createDiv("tf-hours-target-line");
      targetLine.style.bottom = `${targetHeight + bottomOffset}px`;
      const targetLabelLeft = createDiv("tf-hours-target-label-left", t("stats.target") || "M\xE5l");
      const targetLabelRight = createDiv("tf-hours-target-label", `${target.toFixed(0)}t`);
      targetLine.appendChild(targetLabelLeft);
      targetLine.appendChild(targetLabelRight);
      chartInner.appendChild(targetLine);
    }
    chartData.forEach((item) => {
      const barWrapper = createDiv("tf-hours-bar-wrapper");
      const valueLabel = createDiv("tf-hours-bar-value", item.hours > 0 ? `${item.hours.toFixed(0)}` : "");
      barWrapper.appendChild(valueLabel);
      const barContainer = createDiv("tf-hours-bar-container");
      const bar = createDiv("tf-hours-bar");
      const barHeight = maxHours > 0 ? item.hours / maxHours * maxBarHeight : 0;
      bar.style.height = `${Math.max(barHeight, 2)}px`;
      if (item.hours === 0) {
        bar.classList.add("empty");
      }
      barContainer.appendChild(bar);
      barWrapper.appendChild(barContainer);
      barWrapper.appendChild(createDiv("tf-hours-bar-label", item.label));
      barsArea.appendChild(barWrapper);
    });
  }
  updateMonthCard() {
    if (!this.elements.monthCard) return;
    const displayDate = new Date(this.today);
    displayDate.setMonth(this.today.getMonth() + this.currentMonthOffset);
    const grid = this.createMonthGrid(displayDate);
    this.elements.monthCard.empty();
    this.elements.monthCard.appendChild(grid);
    const card = this.elements.monthCard.parentElement;
    if (card) {
      const futureList = card.querySelector(".tf-future-days-list");
      if (futureList) {
        this.updateFutureDaysList(futureList);
      }
    }
  }
  updateFutureDaysList(container) {
    const today = /* @__PURE__ */ new Date();
    const futureDays = [];
    Object.keys(this.data.holidays).forEach((dateStr) => {
      const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
      if (date >= today) {
        const holiday = this.data.holidays[dateStr];
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === holiday.type);
        if (behavior) {
          const translatedLabel = translateSpecialDayName(behavior.id, behavior.label);
          let displayLabel = holiday.description || translatedLabel;
          if (holiday.type === "annet") {
            const parts = [];
            if (holiday.annetTemplateId) {
              const template = this.settings.annetTemplates.find((t2) => t2.id === holiday.annetTemplateId);
              if (template) {
                parts.push(`${template.icon} ${translateAnnetTemplateName(template.id, template.label)}`);
              }
            }
            if (holiday.startTime && holiday.endTime) {
              parts.push(`${holiday.startTime}-${holiday.endTime}`);
            }
            if (holiday.description) {
              parts.push(holiday.description);
            }
            displayLabel = parts.length > 0 ? parts.join(" \xB7 ") : translatedLabel;
          }
          futureDays.push({
            date: dateStr,
            type: translatedLabel,
            label: displayLabel,
            color: behavior.color,
            textColor: behavior.textColor || "#000000"
          });
        }
      }
    });
    futureDays.sort((a, b) => a.date.localeCompare(b.date));
    const maxEntries = this.settings.hideEmptyStats ? 10 : 15;
    const displayDays = futureDays.slice(0, maxEntries);
    const hasMore = futureDays.length > maxEntries;
    if (displayDays.length === 0) {
      container.empty();
      return;
    }
    container.empty();
    container.createEl("h4", { text: t("ui.upcomingPlannedDays") });
    const innerContainer = container.createDiv({ cls: `tf-future-days-inner${hasMore ? " has-more" : ""}` });
    displayDays.forEach((day) => {
      const date = /* @__PURE__ */ new Date(day.date + "T00:00:00");
      const dateStr = formatDate(date, "long");
      const itemDiv = innerContainer.createDiv({ cls: "tf-future-day-item" });
      itemDiv.createSpan({ cls: "tf-future-day-date", text: dateStr });
      const typeSpan = itemDiv.createSpan({ cls: "tf-future-day-type tf-dynamic-bg-color", text: day.label });
      typeSpan.setCssProps({ "--tf-bg": day.color, "--tf-color": day.textColor });
    });
  }
  createMonthGrid(displayDate) {
    var _a, _b;
    const year = displayDate.getFullYear();
    const month = displayDate.getMonth();
    const monthName = getMonthName(displayDate);
    const showWeekNumbers = (_a = this.settings.showWeekNumbers) != null ? _a : true;
    const container = document.createElement("div");
    const monthTitle = document.createElement("div");
    monthTitle.textContent = monthName;
    monthTitle.className = "tf-month-title";
    container.appendChild(monthTitle);
    const grid = document.createElement("div");
    grid.className = showWeekNumbers ? "tf-month-grid with-week-numbers" : "tf-month-grid";
    if (showWeekNumbers) {
      const weekHeader = document.createElement("div");
      weekHeader.className = "tf-week-number-header";
      weekHeader.textContent = t("ui.week");
      grid.appendChild(weekHeader);
    }
    const dayNames = getDayNamesShort();
    dayNames.forEach((name) => {
      const header = document.createElement("div");
      header.textContent = name;
      header.className = "tf-day-header";
      grid.appendChild(header);
    });
    const firstDay = new Date(year, month, 1);
    let firstDayOfWeek = firstDay.getDay() - 1;
    if (firstDayOfWeek === -1) firstDayOfWeek = 6;
    if (showWeekNumbers) {
      const weekNumCell = document.createElement("div");
      const dayOfWeek = firstDay.getDay();
      const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      const mondayOfWeek = new Date(firstDay);
      mondayOfWeek.setDate(firstDay.getDate() - daysFromMonday);
      const complianceClass = this.getWeekComplianceClass(mondayOfWeek);
      weekNumCell.className = `tf-week-number-cell ${complianceClass}`;
      weekNumCell.textContent = Utils.getWeekNumber(firstDay).toString();
      if (complianceClass && complianceClass !== "week-future") {
        weekNumCell.addClass("tf-cursor-pointer");
        const monday = new Date(mondayOfWeek);
        weekNumCell.onclick = (e) => {
          e.stopPropagation();
          this.showWeekCompliancePanel(weekNumCell.getBoundingClientRect(), monday);
        };
      }
      grid.appendChild(weekNumCell);
    }
    for (let i = 0; i < firstDayOfWeek; i++) {
      const emptyCell = document.createElement("div");
      grid.appendChild(emptyCell);
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const todayKey = Utils.toLocalDateStr(/* @__PURE__ */ new Date());
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = Utils.toLocalDateStr(date);
      if (showWeekNumbers && day > 1 && date.getDay() === 1) {
        const weekNumCell = document.createElement("div");
        const complianceClass = this.getWeekComplianceClass(date);
        weekNumCell.className = `tf-week-number-cell ${complianceClass}`;
        weekNumCell.textContent = Utils.getWeekNumber(date).toString();
        if (complianceClass && complianceClass !== "week-future") {
          weekNumCell.addClass("tf-cursor-pointer");
          const monday = new Date(date);
          weekNumCell.onclick = (e) => {
            e.stopPropagation();
            this.showWeekCompliancePanel(weekNumCell.getBoundingClientRect(), monday);
          };
        }
        grid.appendChild(weekNumCell);
      }
      const cell = document.createElement("div");
      cell.className = "tf-day-cell";
      cell.textContent = day.toString();
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      const dayEntries = this.data.daily[dateKey];
      const specialDayColors = getSpecialDayColors(this.settings);
      const specialDayTextColors = getSpecialDayTextColors(this.settings);
      const specialEntry = dayEntries == null ? void 0 : dayEntries.find((e) => {
        const entryName = e.name.toLowerCase();
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === entryName);
        return specialDayColors[entryName] && (!behavior || !behavior.isWorkType);
      });
      let workDuration = 0;
      let specialDuration = 0;
      let dominantSpecialType = null;
      let hasFullDaySpecial = false;
      if (dayEntries) {
        const specialDurations = /* @__PURE__ */ new Map();
        for (const entry of dayEntries) {
          const entryName = entry.name.toLowerCase();
          const behavior = this.settings.specialDayBehaviors.find((b) => b.id === entryName);
          const duration = entry.duration || 0;
          if (behavior == null ? void 0 : behavior.isWorkType) {
            workDuration += duration;
          } else if (specialDayColors[entryName] || (behavior == null ? void 0 : behavior.color)) {
            specialDuration += duration;
            specialDurations.set(entryName, (specialDurations.get(entryName) || 0) + duration);
            if ((behavior == null ? void 0 : behavior.noHoursRequired) || (behavior == null ? void 0 : behavior.countsAsWorkday)) {
              hasFullDaySpecial = true;
              if (!dominantSpecialType) {
                dominantSpecialType = entryName;
              }
            }
          }
        }
        if (!dominantSpecialType) {
          let maxSpecialDuration = 0;
          for (const [typeName, duration] of specialDurations) {
            if (duration > maxSpecialDuration) {
              maxSpecialDuration = duration;
              dominantSpecialType = typeName;
            }
          }
        }
      }
      const hasMixedTypes = workDuration > 0 && (specialDuration > 0 || hasFullDaySpecial);
      const workIsDominant = !hasFullDaySpecial && workDuration >= specialDuration;
      const hasEntry = !!(holidayInfo || specialEntry || dayEntries);
      if (holidayInfo) {
        const colorKey = holidayInfo.halfDay ? "halfday" : holidayInfo.type;
        cell.setCssProps({
          "--tf-bg": specialDayColors[colorKey] || specialDayColors[holidayInfo.type] || "var(--background-secondary)",
          "--tf-color": specialDayTextColors[colorKey] || specialDayTextColors[holidayInfo.type] || "var(--text-normal)"
        });
      } else if (hasMixedTypes && !workIsDominant && dominantSpecialType) {
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === dominantSpecialType);
        const bgColor = (behavior == null ? void 0 : behavior.color) || specialDayColors[dominantSpecialType];
        cell.setCssProps({
          "--tf-bg": bgColor,
          "--tf-color": (behavior == null ? void 0 : behavior.textColor) || specialDayTextColors[dominantSpecialType] || "var(--text-normal)"
        });
      } else if (specialEntry && !hasMixedTypes) {
        const entryKey = specialEntry.name.toLowerCase();
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === entryKey);
        cell.setCssProps({
          "--tf-bg": (behavior == null ? void 0 : behavior.color) || specialDayColors[entryKey],
          "--tf-color": (behavior == null ? void 0 : behavior.textColor) || specialDayTextColors[entryKey] || "var(--text-normal)"
        });
      } else if (dayEntries) {
        const isWeekendDay = Utils.isWeekend(date, this.settings);
        const halfWorkday = this.settings.baseWorkday * this.settings.workPercent / 2;
        const isMinimalWeekendWork = isWeekendDay && workDuration < halfWorkday;
        if (isMinimalWeekendWork) {
          cell.setCssProps({
            "--tf-bg": "var(--background-modifier-border)",
            "--tf-color": "var(--text-muted)"
          });
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          const stripeColor = !this.settings.enableGoalTracking ? ((_b = this.settings.specialDayBehaviors.find((b) => b.isWorkType)) == null ? void 0 : _b.simpleColor) || "#90caf9" : this.flextimeColor(dayFlextime);
          const stripe = document.createElement("div");
          stripe.className = "secondary-type-stripe";
          stripe.setCssProps({ "--tf-bg": stripeColor });
          cell.appendChild(stripe);
        } else if (!this.settings.enableGoalTracking) {
          const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
          cell.setCssProps({
            "--tf-bg": (workType == null ? void 0 : workType.simpleColor) || "#90caf9",
            "--tf-color": (workType == null ? void 0 : workType.simpleTextColor) || "#000000"
          });
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.setCssProps({
            "--tf-bg": this.flextimeColor(dayFlextime),
            "--tf-color": this.flextimeTextColor(dayFlextime)
          });
        }
      } else if (Utils.isWeekend(date, this.settings)) {
        cell.setCssProps({ "--tf-bg": "var(--background-modifier-border)" });
      } else {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const cellDate = new Date(date);
        cellDate.setHours(0, 0, 0, 0);
        if (cellDate < today) {
          cell.setCssProps({ "--tf-bg": "var(--background-secondary)" });
        } else {
          cell.setCssProps({ "--tf-bg": "transparent" });
        }
      }
      if (hasMixedTypes) {
        let stripeColor = null;
        if (workIsDominant && dominantSpecialType) {
          const behavior = this.settings.specialDayBehaviors.find((b) => b.id === dominantSpecialType);
          stripeColor = (behavior == null ? void 0 : behavior.color) || specialDayColors[dominantSpecialType];
        } else {
          const dayFlextime = (dayEntries == null ? void 0 : dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0)) || 0;
          stripeColor = this.flextimeColor(dayFlextime);
        }
        if (stripeColor) {
          const stripe = document.createElement("div");
          stripe.className = "secondary-type-stripe";
          stripe.setCssProps({ "--tf-bg": stripeColor });
          cell.appendChild(stripe);
        }
      }
      if (hasEntry) {
        cell.classList.add("has-entry");
      } else {
        cell.classList.add("no-entry");
        cell.setCssProps({ "--tf-color": "var(--text-muted)" });
      }
      if (dateKey === todayKey) {
        cell.classList.add("today");
      }
      const hasActiveEntry = dayEntries == null ? void 0 : dayEntries.some((e) => !e.endTime);
      if (hasActiveEntry) {
        const indicator = document.createElement("div");
        indicator.className = "tf-active-entry-indicator";
        cell.appendChild(indicator);
      }
      cell.onclick = (e) => {
        e.stopPropagation();
        const cellRect = cell.getBoundingClientRect();
        this.showNoteTypeMenu(cellRect, date);
      };
      grid.appendChild(cell);
    }
    container.appendChild(grid);
    return container;
  }
  flextimeColor(val) {
    var _a, _b, _c;
    const workBehavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.isWorkType);
    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 128, g: 128, b: 128 };
    };
    const dailyLimit = (_c = (_b = this.settings.complianceSettings) == null ? void 0 : _b.dailyHoursLimit) != null ? _c : 9;
    const baseWorkday = this.settings.baseWorkday * this.settings.workPercent;
    const scale = Math.max(dailyLimit - baseWorkday, 0.5);
    if (val < 0) {
      const baseColor = (workBehavior == null ? void 0 : workBehavior.negativeColor) || "#64b5f6";
      const rgb = hexToRgb(baseColor);
      const t2 = Math.min(Math.abs(val) / scale, 1);
      const darkFactor = t2 * 0.5;
      const r = Math.floor(rgb.r * (1 - darkFactor));
      const g = Math.floor(rgb.g * (1 - darkFactor));
      const b = Math.floor(rgb.b * (1 - darkFactor));
      return `rgb(${r},${g},${b})`;
    } else {
      const baseColor = (workBehavior == null ? void 0 : workBehavior.color) || "#4caf50";
      const rgb = hexToRgb(baseColor);
      const t2 = Math.min(val / scale, 1);
      const darkFactor = t2 * 0.5;
      const r = Math.floor(rgb.r * (1 - darkFactor));
      const g = Math.floor(rgb.g * (1 - darkFactor));
      const b = Math.floor(rgb.b * (1 - darkFactor));
      return `rgb(${r},${g},${b})`;
    }
  }
  flextimeTextColor(val) {
    var _a;
    const workBehavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.isWorkType);
    if (val < 0) {
      return (workBehavior == null ? void 0 : workBehavior.negativeTextColor) || "#ffffff";
    } else {
      return (workBehavior == null ? void 0 : workBehavior.textColor) || "#ffffff";
    }
  }
  /**
   * Generate description for a special day behavior based on its flextimeEffect setting
   */
  getFlextimeEffectDescription(behavior) {
    if (behavior.id === "helligdag") {
      return t("info.publicHolidayDesc");
    }
    if (behavior.id === "halfday") {
      const halfDayHours = this.settings.halfDayMode === "percentage" ? this.settings.baseWorkday / 2 : this.settings.halfDayHours;
      const halfDayReduction = this.settings.baseWorkday - halfDayHours;
      return t("info.halfDayDesc").replace("{hours}", halfDayHours.toString()).replace("{reduction}", halfDayReduction.toString());
    }
    switch (behavior.flextimeEffect) {
      case "withdraw":
        return t("info.withdrawFromFlextime");
      case "accumulate":
        return t("info.countsAsFlextime").replace("{hours}", this.settings.baseWorkday.toString());
      case "none":
      default:
        return t("info.noFlextimeEffect");
    }
  }
  /**
   * Check if week compliance indicators should be shown
   */
  shouldShowWeekCompliance() {
    var _a, _b;
    return this.settings.enableGoalTracking && ((_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.enableWarnings) != null ? _b : true);
  }
  /**
   * Get the compliance status for a given week
   * Returns: 'ok' (met goal), 'over' (exceeded), 'under' (below goal), 'partial' (incomplete week), 'future', or '' if disabled
   */
  getWeekComplianceClass(mondayOfWeek) {
    if (!this.shouldShowWeekCompliance()) {
      return "";
    }
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const balanceStartDate = /* @__PURE__ */ new Date(this.settings.balanceStartDate + "T00:00:00");
    const sundayOfWeek = new Date(mondayOfWeek);
    sundayOfWeek.setDate(mondayOfWeek.getDate() + 6);
    if (sundayOfWeek < balanceStartDate) {
      return "";
    }
    if (mondayOfWeek > today) {
      return "week-future";
    }
    let totalHours = 0;
    let workDaysInWeek = 0;
    let workDaysPassed = 0;
    for (let i = 0; i < 7; i++) {
      const day = new Date(mondayOfWeek);
      day.setDate(mondayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(day);
      if (day < balanceStartDate) {
        continue;
      }
      const isWorkDay = this.settings.workDays.includes(day.getDay());
      if (isWorkDay) {
        const holidayInfo = this.data.getHolidayInfo(dayKey);
        const behavior = holidayInfo ? this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type) : null;
        const isNoHoursDay = (behavior == null ? void 0 : behavior.noHoursRequired) === true;
        if (!isNoHoursDay) {
          workDaysInWeek++;
          if (day <= today) {
            workDaysPassed++;
          }
        }
      }
      const dayEntries = this.data.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "ferie" && name !== "egenmelding" && name !== "sykemelding" && name !== "velferdspermisjon") {
          totalHours += entry.duration || 0;
        }
      });
    }
    if (workDaysPassed === 0) {
      return "week-future";
    }
    const expectedHoursPerDay = this.settings.baseWorkday;
    const expectedHours = workDaysPassed * expectedHoursPerDay * this.settings.workPercent;
    const tolerance = 0.5;
    if (totalHours >= expectedHours - tolerance && totalHours <= expectedHours + tolerance) {
      return "week-ok";
    } else if (totalHours > expectedHours + tolerance) {
      return "week-over";
    } else if (workDaysPassed < workDaysInWeek && sundayOfWeek >= today) {
      return "week-partial";
    } else {
      return "week-under";
    }
  }
  /**
   * Get detailed week compliance data for popup
   */
  getWeekComplianceData(mondayOfWeek) {
    var _a, _b, _c, _d;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const balanceStartDate = /* @__PURE__ */ new Date(this.settings.balanceStartDate + "T00:00:00");
    const sundayOfWeek = new Date(mondayOfWeek);
    sundayOfWeek.setDate(mondayOfWeek.getDate() + 6);
    let totalHours = 0;
    let workDaysInWeek = 0;
    let workDaysPassed = 0;
    for (let i = 0; i < 7; i++) {
      const day = new Date(mondayOfWeek);
      day.setDate(mondayOfWeek.getDate() + i);
      const dayKey = Utils.toLocalDateStr(day);
      if (day < balanceStartDate) continue;
      const isWorkDay = this.settings.workDays.includes(day.getDay());
      if (isWorkDay) {
        const holidayInfo = this.data.getHolidayInfo(dayKey);
        const behavior = holidayInfo ? this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type) : null;
        const isNoHoursDay = (behavior == null ? void 0 : behavior.noHoursRequired) === true;
        if (!isNoHoursDay) {
          workDaysInWeek++;
          if (day <= today) {
            workDaysPassed++;
          }
        }
      }
      const dayEntries = this.data.daily[dayKey] || [];
      dayEntries.forEach((entry) => {
        const name = entry.name.toLowerCase();
        if (name !== "avspasering" && name !== "ferie" && name !== "egenmelding" && name !== "sykemelding" && name !== "velferdspermisjon") {
          totalHours += entry.duration || 0;
        }
      });
    }
    const expectedHoursPerDay = this.settings.baseWorkday;
    const expectedHours = workDaysPassed * expectedHoursPerDay * this.settings.workPercent;
    const isComplete = workDaysPassed >= workDaysInWeek || sundayOfWeek < today;
    let status = "ok";
    const tolerance = 0.5;
    if (totalHours < expectedHours - tolerance) {
      status = isComplete ? "under" : "partial";
    } else if (totalHours > expectedHours + tolerance) {
      status = "over";
    }
    return {
      weekNumber: Utils.getWeekNumber(mondayOfWeek),
      totalHours,
      expectedHours,
      workDaysPassed,
      workDaysInWeek,
      dailyLimit: (_b = (_a = this.settings.complianceSettings) == null ? void 0 : _a.dailyHoursLimit) != null ? _b : 9,
      weeklyLimit: (_d = (_c = this.settings.complianceSettings) == null ? void 0 : _c.weeklyHoursLimit) != null ? _d : 40,
      status,
      isComplete
    };
  }
  /**
   * Show week compliance info panel when clicking on a week number
   */
  showWeekCompliancePanel(cellRect, mondayOfWeek) {
    const existingPanel = document.querySelector(".tf-week-compliance-panel");
    if (existingPanel) {
      const existingWeek = existingPanel.dataset.weekMonday;
      existingPanel.remove();
      if (existingWeek === Utils.toLocalDateStr(mondayOfWeek)) {
        return;
      }
    }
    const data = this.getWeekComplianceData(mondayOfWeek);
    const panel = document.createElement("div");
    panel.className = "tf-week-compliance-panel";
    panel.dataset.weekMonday = Utils.toLocalDateStr(mondayOfWeek);
    let statusIcon = "\u{1F7E9}";
    let statusText = t("status.onTarget");
    let statusColor = "#4caf50";
    if (data.status === "over") {
      statusIcon = "\u{1F7E5}";
      statusText = t("status.overTarget");
      statusColor = "#f44336";
    } else if (data.status === "under") {
      statusIcon = "\u{1F7E8}";
      statusText = t("status.underTarget");
      statusColor = "#ff9800";
    } else if (data.status === "partial") {
      statusIcon = "\u23F3";
      statusText = t("status.inProgress");
      statusColor = "#9e9e9e";
    }
    const diff = data.totalHours - data.expectedHours;
    const diffText = diff >= 0 ? `+${diff.toFixed(1)}` : diff.toFixed(1);
    const headerRow = panel.createDiv({ cls: "tf-panel-header-row" });
    headerRow.createEl("strong", { text: `${t("ui.week")} ${data.weekNumber}`, cls: "tf-week-title" });
    const statusSpan = headerRow.createSpan({ text: `${statusIcon} ${statusText}`, cls: "tf-font-bold tf-dynamic-color" });
    statusSpan.setCssProps({ "--tf-color": statusColor });
    const contentDiv = panel.createDiv({ cls: "tf-panel-content-col" });
    const hoursRow = contentDiv.createDiv({ cls: "tf-panel-row" });
    hoursRow.createSpan({ text: `${t("ui.hoursLogged")}:` });
    hoursRow.createEl("strong", { text: `${data.totalHours.toFixed(1)}t` });
    const expectedRow = contentDiv.createDiv({ cls: "tf-panel-row" });
    expectedRow.createSpan({ text: `${t("ui.expected")}:` });
    expectedRow.createSpan({ text: `${data.expectedHours.toFixed(1)}t (${data.workDaysPassed}/${data.workDaysInWeek} ${t("ui.days")})` });
    const diffRow = contentDiv.createDiv({ cls: "tf-panel-row-border" });
    diffRow.createSpan({ text: `${t("ui.difference")}:` });
    const diffValue = diffRow.createEl("strong", { text: `${diffText}t`, cls: "tf-dynamic-color" });
    diffValue.setCssProps({ "--tf-color": statusColor });
    if (data.totalHours > data.weeklyLimit) {
      contentDiv.createDiv({ text: `\u26A0\uFE0F ${t("ui.overWeekLimit")} (${data.weeklyLimit}t)`, cls: "tf-warning-text" });
    }
    panel.style.left = `${cellRect.right + 8}px`;
    panel.style.top = `${cellRect.top}px`;
    document.body.appendChild(panel);
    const panelRect = panel.getBoundingClientRect();
    if (panelRect.right > window.innerWidth - 10) {
      panel.style.left = `${cellRect.left - panelRect.width - 8}px`;
    }
    if (panelRect.bottom > window.innerHeight - 10) {
      panel.style.top = `${window.innerHeight - panelRect.height - 10}px`;
    }
    const closeHandler = (e) => {
      if (!panel.contains(e.target)) {
        panel.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  showNoteTypeMenu(cellRect, dateObj) {
    var _a, _b, _c, _d, _e;
    const existingMenu = document.querySelector(".tf-context-menu");
    if (existingMenu) {
      const existingDate = existingMenu.dataset.menuDate;
      existingMenu.remove();
      if (existingDate === Utils.toLocalDateStr(dateObj)) {
        return;
      }
    }
    const menu = document.createElement("div");
    menu.className = "tf-context-menu";
    menu.dataset.menuDate = Utils.toLocalDateStr(dateObj);
    const menuMain = document.createElement("div");
    menuMain.className = "tf-context-menu-main";
    let menuLeft = cellRect.right;
    let menuTop = cellRect.top;
    document.body.appendChild(menu);
    const isMobile = window.innerWidth <= 500;
    if (isMobile) {
      menuLeft = 10;
      menu.setCssProps({ "--tf-left": `${menuLeft}px`, "--tf-right": "10px", "--tf-width": "calc(100vw - 20px)" });
    } else {
      const menuWidth = 450;
      if (menuLeft + menuWidth > window.innerWidth) {
        menuLeft = cellRect.left - menuWidth;
        if (menuLeft < 10) {
          menuLeft = 10;
        }
      }
      menu.style.left = `${menuLeft}px`;
    }
    setTimeout(() => {
      const menuHeight = menu.offsetHeight;
      if (menuTop + menuHeight > window.innerHeight) {
        menuTop = Math.max(10, window.innerHeight - menuHeight - 10);
      }
      if (menuTop < 10) {
        menuTop = 10;
      }
      menu.style.top = `${menuTop}px`;
    }, 0);
    menu.style.top = `${menuTop}px`;
    const dateStr = Utils.toLocalDateStr(dateObj);
    const dateEntries = this.data.daily[dateStr];
    const hasWorkEntriesInDaily = dateEntries && dateEntries.some((e) => e.name.toLowerCase() === "jobb");
    const hasRunningTimerForDate = this.timerManager.data.entries.some((entry) => {
      if (!entry.startTime || entry.name.toLowerCase() !== "jobb") return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr;
    });
    const hasWorkEntries = hasWorkEntriesInDaily || hasRunningTimerForDate;
    const workTimeItem = document.createElement("div");
    workTimeItem.className = "tf-menu-item";
    workTimeItem.createSpan({ text: "\u23F1\uFE0F" });
    workTimeItem.createSpan({ text: t("menu.logWork") });
    workTimeItem.onclick = () => {
      menu.remove();
      this.showWorkTimeModal(dateObj);
    };
    menuMain.appendChild(workTimeItem);
    if (hasWorkEntries) {
      const editItem = document.createElement("div");
      editItem.className = "tf-menu-item";
      editItem.createSpan({ text: "\u270F\uFE0F" });
      editItem.createSpan({ text: t("menu.editWork") });
      editItem.onclick = () => {
        menu.remove();
        this.showEditEntriesModal(dateObj);
      };
      menuMain.appendChild(editItem);
    }
    const specialDayItem = document.createElement("div");
    specialDayItem.className = "tf-menu-item";
    specialDayItem.createSpan({ text: "\u{1F4C5}" });
    specialDayItem.createSpan({ text: t("menu.registerSpecialDay") });
    specialDayItem.onclick = () => {
      menu.remove();
      this.showSpecialDayModal(dateObj);
    };
    menuMain.appendChild(specialDayItem);
    const plannedDayInfo = this.data.getHolidayInfo(dateStr);
    if (plannedDayInfo) {
      let typeName = translateSpecialDayName(plannedDayInfo.type);
      if (plannedDayInfo.type === "annet" && plannedDayInfo.annetTemplateId) {
        const template = (_a = this.settings.annetTemplates) == null ? void 0 : _a.find((tmpl) => tmpl.id === plannedDayInfo.annetTemplateId);
        if (template) {
          typeName = translateAnnetTemplateName(template.id, template.label);
        }
      }
      const editPlannedItem = document.createElement("div");
      editPlannedItem.className = "tf-menu-item";
      editPlannedItem.createSpan({ text: "\u270F\uFE0F" });
      editPlannedItem.createSpan({ text: `${t("menu.editPlannedDay")} ${typeName}` });
      editPlannedItem.onclick = () => {
        menu.remove();
        this.showEditPlannedDayModal(dateObj, plannedDayInfo);
      };
      menuMain.appendChild(editPlannedItem);
    }
    const separator1 = document.createElement("div");
    separator1.className = "tf-menu-separator";
    menuMain.appendChild(separator1);
    this.settings.noteTypes.forEach((noteType) => {
      const item = document.createElement("div");
      item.className = "tf-menu-item";
      item.createSpan({ text: noteType.icon });
      item.createSpan({ text: translateNoteTypeName(noteType.id, noteType.label) });
      item.onclick = async () => {
        await this.createNoteFromType(dateObj, noteType);
        menu.remove();
      };
      menuMain.appendChild(item);
    });
    menu.appendChild(menuMain);
    const menuInfo = document.createElement("div");
    menuInfo.className = "tf-context-menu-info";
    const allEntries = dateEntries || [];
    const plannedInfo = this.data.getHolidayInfo(dateStr);
    const isPlannedDay = plannedInfo !== null;
    const isPastDay = dateObj < /* @__PURE__ */ new Date();
    const isFutureDay = dateObj > /* @__PURE__ */ new Date();
    const runningTimersForDate = this.timerManager.data.entries.filter((entry) => {
      if (!entry.startTime || !entry.endTime === false || entry.name.toLowerCase() !== "jobb") return false;
      const entryDate = new Date(entry.startTime);
      return Utils.toLocalDateStr(entryDate) === dateStr && !entry.endTime;
    });
    menuInfo.createEl("h4", { text: "\u{1F4C5} " + dateStr });
    if (isPlannedDay && plannedInfo) {
      const emoji = Utils.getEmoji({ name: plannedInfo.type, date: dateObj });
      let typeName = translateSpecialDayName(plannedInfo.type);
      if (plannedInfo.type === "annet" && plannedInfo.annetTemplateId) {
        const template = (_b = this.settings.annetTemplates) == null ? void 0 : _b.find((tmpl) => tmpl.id === plannedInfo.annetTemplateId);
        if (template) {
          typeName = `${template.icon} ${translateAnnetTemplateName(template.id, template.label)}`;
        }
      }
      const plannedP = menuInfo.createEl("p");
      let displayText = plannedInfo.description ? `${emoji} ${typeName}: ${plannedInfo.description}` : `${emoji} ${typeName}`;
      if (plannedInfo.halfDay) {
        displayText += " (\xBD)";
      }
      plannedP.createEl("strong", { text: displayText });
    }
    if (runningTimersForDate.length > 0) {
      const timersP = menuInfo.createEl("p");
      timersP.createEl("strong", { text: t("timer.runningTimers") + ":" });
      runningTimersForDate.forEach((timer) => {
        const startTime = new Date(timer.startTime);
        const startTimeStr = `${startTime.getHours().toString().padStart(2, "0")}:${startTime.getMinutes().toString().padStart(2, "0")}`;
        const now = /* @__PURE__ */ new Date();
        const elapsed = ((now.getTime() - startTime.getTime()) / (1e3 * 60 * 60)).toFixed(1);
        menuInfo.createEl("p", { text: "\u23F1\uFE0F " + timer.name + ": " + startTimeStr + " - P\xE5g\xE5r (" + elapsed + "t)", cls: "tf-ml-8" });
      });
    }
    const completedEntries = allEntries.filter((e) => {
      if (e.duration && e.duration > 0) return true;
      const behavior = this.data.getSpecialDayBehavior(e.name);
      return behavior && (behavior.noHoursRequired || behavior.countsAsWorkday || behavior.flextimeEffect === "reduce_goal");
    });
    if (completedEntries.length > 0) {
      const historyP = menuInfo.createEl("p");
      historyP.createEl("strong", { text: t("ui.history") + ":" });
      const rawEntriesForDate = this.timerManager.data.entries.filter((entry) => {
        if (!entry.startTime) return false;
        const entryDate = new Date(entry.startTime);
        return Utils.toLocalDateStr(entryDate) === dateStr;
      });
      const usedRawEntries = /* @__PURE__ */ new Set();
      completedEntries.forEach((e) => {
        const emoji = Utils.getEmoji(e);
        const behavior = this.data.getSpecialDayBehavior(e.name);
        const isFullDayReduceGoal = (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal" && (!e.duration || e.duration === 0);
        const durationText = e.duration && e.duration > 0 ? `: ${e.duration.toFixed(1)}${this.settings.hourUnit}` : isFullDayReduceGoal ? ` (${t("ui.fullDay")})` : "";
        const matchingRaw = rawEntriesForDate.find(
          (raw) => !usedRawEntries.has(raw) && raw.name.toLowerCase() === e.name.toLowerCase() && raw.startTime === e.startTime
        ) || rawEntriesForDate.find(
          (raw) => !usedRawEntries.has(raw) && raw.name.toLowerCase() === e.name.toLowerCase()
        );
        if (matchingRaw) usedRawEntries.add(matchingRaw);
        const entryP = menuInfo.createEl("p", { cls: "tf-ml-8" });
        entryP.appendText(emoji + " " + translateSpecialDayName(e.name.toLowerCase(), e.name) + durationText);
        if (matchingRaw == null ? void 0 : matchingRaw.comment) {
          const commentSpan = entryP.createEl("span", { cls: "tf-context-menu-comment" });
          commentSpan.appendText(" \u{1F4AC} " + (matchingRaw.comment.length > 40 ? matchingRaw.comment.substring(0, 37) + "..." : matchingRaw.comment));
          commentSpan.title = matchingRaw.comment;
        }
      });
      if (!isFutureDay) {
        const dayGoal = this.data.getDailyGoal(dateStr);
        const dailyDelta = allEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
        const runningBalance = this.data.getBalanceUpToDate(dateStr);
        const goalP = menuInfo.createEl("p", { cls: "tf-menu-goal" });
        goalP.createEl("strong", { text: t("ui.goal") + ":" });
        goalP.appendText(" " + dayGoal.toFixed(1) + "t");
        const dailyP = menuInfo.createEl("p");
        dailyP.createEl("strong", { text: t("ui.dailyBalance") + ":" });
        dailyP.appendText(" " + (dailyDelta >= 0 ? "+" : "") + dailyDelta.toFixed(1) + "t");
        const balanceP = menuInfo.createEl("p");
        balanceP.createEl("strong", { text: t("ui.runningBalance") + ":" });
        balanceP.appendText(" " + (runningBalance >= 0 ? "+" : "") + Utils.formatHoursToHM(runningBalance, this.settings.hourUnit));
      }
    } else if (isPastDay && !isPlannedDay && runningTimersForDate.length === 0) {
      menuInfo.createEl("p", { text: t("ui.noRegistration"), cls: "tf-text-muted" });
    }
    if (((_c = this.settings.complianceSettings) == null ? void 0 : _c.enableWarnings) && !isFutureDay && completedEntries.length > 0) {
      const restCheck = this.data.checkRestPeriodViolation(dateStr);
      if (restCheck.violated && restCheck.restHours !== null) {
        const minimumRest = (_e = (_d = this.settings.complianceSettings) == null ? void 0 : _d.minimumRestHours) != null ? _e : 11;
        const warningDiv = menuInfo.createDiv({ cls: "tf-rest-period-warning" });
        warningDiv.createSpan({ cls: "warning-icon", text: "\u26A0\uFE0F" });
        warningDiv.createSpan({ text: t("ui.restPeriod") + ": " + restCheck.restHours.toFixed(1) + "h (" + t("ui.minimum") + " " + minimumRest + "h)" });
      }
    }
    menuInfo.createEl("p", { text: `\u{1F4A1} ${t("menu.selectOption")}`, cls: "tf-tip-paragraph" });
    menu.appendChild(menuInfo);
    setTimeout(() => {
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  /**
   * Show confirmation dialog for overnight shift detection.
   */
  showOvernightShiftConfirmation(onConfirm) {
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z1001";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-content-350";
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = t("confirm.overnightShiftTitle");
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    const message = document.createElement("p");
    message.textContent = t("confirm.overnightShift");
    content.appendChild(message);
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-btn-row-end-mt";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const confirmBtn = document.createElement("button");
    confirmBtn.textContent = t("buttons.confirm");
    confirmBtn.className = "mod-cta";
    confirmBtn.onclick = () => {
      modal.remove();
      onConfirm();
    };
    buttonDiv.appendChild(confirmBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  /**
   * Show a generic confirmation dialog that replaces browser confirm().
   * @param message The message to display
   * @param onConfirm Callback when user confirms
   * @param title Optional title (defaults to "Confirm")
   */
  showConfirmDialog(message, onConfirm, title) {
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z1001";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => modal.remove();
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-content-350";
    const titleEl = document.createElement("div");
    titleEl.className = "modal-title";
    titleEl.textContent = title || t("buttons.confirm");
    modalContent.appendChild(titleEl);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    const messageEl = document.createElement("p");
    messageEl.textContent = message;
    content.appendChild(messageEl);
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-btn-row-end-mt";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => modal.remove();
    buttonDiv.appendChild(cancelBtn);
    const confirmBtn = document.createElement("button");
    confirmBtn.textContent = t("buttons.confirm");
    confirmBtn.className = "mod-cta mod-warning";
    confirmBtn.onclick = () => {
      modal.remove();
      void onConfirm();
    };
    buttonDiv.appendChild(confirmBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  /**
   * Check if a new/edited entry would create a prohibited overlap.
   * Blocks: same-type overlaps AND overlaps between accumulate-type entries.
   */
  checkProhibitedOverlap(dateStr, entryType, startTime, endTime, excludeEntry) {
    const newBehavior = this.settings.specialDayBehaviors.find((b) => b.id === entryType.toLowerCase());
    const newIsAccumulate = (newBehavior == null ? void 0 : newBehavior.flextimeEffect) === "accumulate";
    const dayEntries = this.timerManager.data.entries.filter((e) => {
      if (e === excludeEntry) return false;
      if (!e.startTime || !e.endTime) return false;
      return Utils.toLocalDateStr(new Date(e.startTime)) === dateStr;
    });
    for (const entry of dayEntries) {
      const existingStart = new Date(entry.startTime);
      const existingEnd = new Date(entry.endTime);
      if (startTime < existingEnd && endTime > existingStart) {
        const existingType = entry.name.toLowerCase();
        const existingBehavior = this.settings.specialDayBehaviors.find((b) => b.id === existingType);
        const existingIsAccumulate = (existingBehavior == null ? void 0 : existingBehavior.flextimeEffect) === "accumulate";
        if (entryType.toLowerCase() === existingType) return true;
        if (newIsAccumulate && existingIsAccumulate) return true;
      }
    }
    return false;
  }
  showWorkTimeModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-w-400";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    modalContent.addEventListener("beforeinput", (e) => e.stopPropagation());
    modalContent.addEventListener("input", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.logWorkTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    const startLabel = document.createElement("div");
    startLabel.textContent = t("modals.startTimeFormat");
    startLabel.className = "tf-form-label-bold";
    content.appendChild(startLabel);
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.value = "08:00";
    startInput.placeholder = "Hh:mm";
    startInput.className = "tf-form-input-full tf-form-input-mb";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = t("modals.endTimeFormat");
    endLabel.className = "tf-form-label-bold";
    content.appendChild(endLabel);
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.value = "15:30";
    endInput.placeholder = "Hh:mm";
    endInput.className = "tf-form-input-full tf-form-input-mb-lg";
    content.appendChild(endInput);
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-btn-row-end";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = t("buttons.add");
    addBtn.className = "mod-cta";
    addBtn.onclick = () => {
      const startTime = startInput.value.trim();
      const endTime = endInput.value.trim();
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
        new import_obsidian5.Notice(`\u274C ${t("validation.invalidTimeFormat")}`);
        return;
      }
      const [startHour, startMin] = startTime.split(":").map(Number);
      const [endHour, endMin] = endTime.split(":").map(Number);
      const startDate = new Date(dateObj);
      startDate.setHours(startHour, startMin, 0, 0);
      const endDate = new Date(dateObj);
      endDate.setHours(endHour, endMin, 0, 0);
      const addEntry = async (finalEndDate) => {
        if (this.checkProhibitedOverlap(dateStr, "jobb", startDate, finalEndDate)) {
          new import_obsidian5.Notice(`\u274C ${t("validation.overlappingEntry")}`);
          return;
        }
        try {
          this.timerManager.data.entries.push({
            name: "jobb",
            startTime: startDate.toISOString(),
            endTime: finalEndDate.toISOString(),
            subEntries: null,
            collapsed: false
          });
          await this.saveWithErrorHandling();
          const duration = (finalEndDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
          new import_obsidian5.Notice(`\u2705 ${t("notifications.addedWorkTime").replace("{duration}", duration.toFixed(1)).replace("{date}", dateStr)}`);
          this.data.rawEntries = this.timerManager.convertToTimeEntries();
          this.data.processEntries();
          this.updateDayCard();
          this.updateWeekCard();
          this.updateStatsCard();
          this.updateMonthCard();
          this.isModalOpen = false;
          modal.remove();
        } catch (error) {
          console.error("Failed to add work time:", error);
          new import_obsidian5.Notice(`\u274C ${t("notifications.errorAddingWorkTime")}`);
        }
      };
      if (endDate <= startDate) {
        this.showOvernightShiftConfirmation(() => {
          const nextDayEndDate = new Date(endDate);
          nextDayEndDate.setDate(nextDayEndDate.getDate() + 1);
          void addEntry(nextDayEndDate);
        });
      } else {
        void addEntry(endDate);
      }
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    startInput.focus();
    startInput.select();
  }
  showEditEntriesModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    const allEntries = this.timerManager.data.entries;
    const workEntries = [];
    allEntries.forEach((entry) => {
      if (entry.collapsed && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub, idx) => {
          if (sub.startTime) {
            const entryDate = new Date(sub.startTime);
            if (Utils.toLocalDateStr(entryDate) === dateStr) {
              workEntries.push({ entry: sub, parent: entry, subIndex: idx });
            }
          }
        });
      } else if (entry.startTime) {
        const entryDate = new Date(entry.startTime);
        if (Utils.toLocalDateStr(entryDate) === dateStr) {
          workEntries.push({ entry });
        }
      }
    });
    if (workEntries.length === 0) {
      new import_obsidian5.Notice(t("notifications.noWorkEntriesFound"));
      return;
    }
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-w-500";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    modalContent.addEventListener("beforeinput", (e) => e.stopPropagation());
    modalContent.addEventListener("input", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.editWorkTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    workEntries.forEach((item, index) => {
      const entry = item.entry;
      const entryDiv = document.createElement("div");
      entryDiv.className = "tf-entry-card";
      const startDate = new Date(entry.startTime);
      const endDate = entry.endTime ? new Date(entry.endTime) : null;
      const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
      const endTimeStr = endDate ? `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}` : t("ui.ongoing");
      const startDateStr = Utils.toLocalDateStr(startDate);
      const endDateStr = endDate ? Utils.toLocalDateStr(endDate) : null;
      const isMultiDay = endDate && startDateStr !== endDateStr;
      const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(1) : "N/A";
      const infoDiv = document.createElement("div");
      infoDiv.className = "tf-info-mb";
      const entryLabel = item.parent ? `${item.parent.name} - ${entry.name}` : `Oppf\xF8ring ${index + 1}`;
      infoDiv.createDiv({ text: entryLabel, cls: "tf-title-bold" });
      const timeDisplay = isMultiDay ? `\u23F0 ${startDateStr} ${startTimeStr} \u2192 ${endDateStr} ${endTimeStr}` : `\u23F0 ${startTimeStr} - ${endTimeStr}`;
      infoDiv.createDiv({ text: timeDisplay });
      infoDiv.createDiv({ text: `\u23F1\uFE0F ${duration} timer` });
      entryDiv.appendChild(infoDiv);
      const editDiv = document.createElement("div");
      editDiv.className = "tf-edit-section tf-hidden";
      const startLabel = document.createElement("div");
      startLabel.textContent = `${t("modals.startTime")}:`;
      startLabel.className = "tf-label-bold-mb";
      editDiv.appendChild(startLabel);
      const startRow = document.createElement("div");
      startRow.className = "tf-datetime-row";
      const startDateInput = document.createElement("input");
      startDateInput.type = "date";
      startDateInput.value = startDateStr;
      startDateInput.className = "tf-input-flex-p";
      startRow.appendChild(startDateInput);
      const startTimeInput = this.createTimeInput(startTimeStr, () => {
      });
      startTimeInput.className = "tf-input-flex-p";
      startRow.appendChild(startTimeInput);
      editDiv.appendChild(startRow);
      const endLabel = document.createElement("div");
      endLabel.textContent = `${t("modals.endTime")}:`;
      endLabel.className = "tf-label-bold-mb";
      editDiv.appendChild(endLabel);
      const endRow = document.createElement("div");
      endRow.className = "tf-datetime-row";
      const endDateInput = document.createElement("input");
      endDateInput.type = "date";
      endDateInput.value = endDateStr || startDateStr;
      endDateInput.className = "tf-input-flex-p";
      endRow.appendChild(endDateInput);
      const endTimeInput = this.createTimeInput(endTimeStr !== t("ui.ongoing") ? endTimeStr : "", () => {
      });
      endTimeInput.className = "tf-input-flex-p";
      endRow.appendChild(endTimeInput);
      editDiv.appendChild(endRow);
      entryDiv.appendChild(editDiv);
      const buttonDiv = document.createElement("div");
      buttonDiv.className = "tf-modal-btn-row";
      const editBtn = document.createElement("button");
      editBtn.textContent = `\u270F\uFE0F ${t("buttons.edit")}`;
      editBtn.onclick = () => {
        if (editDiv.hasClass("tf-hidden")) {
          editDiv.removeClass("tf-hidden");
          editBtn.textContent = `\u{1F4BE} ${t("buttons.save")}`;
        } else {
          const newStartDateValue = startDateInput.value;
          const newStartTimeValue = startTimeInput.value;
          const newEndDateValue = endDateInput.value;
          const newEndTimeValue = endTimeInput.value;
          if (!newStartDateValue || !newStartTimeValue) {
            new import_obsidian5.Notice(`\u274C ${t("validation.startTimeRequired")}`);
            return;
          }
          const newStartDate = /* @__PURE__ */ new Date(`${newStartDateValue}T${newStartTimeValue}:00`);
          if (isNaN(newStartDate.getTime())) {
            new import_obsidian5.Notice(`\u274C ${t("validation.invalidStartDateTime")}`);
            return;
          }
          const saveUpdate = async (finalEndDate) => {
            if (finalEndDate) {
              const checkDateStr = Utils.toLocalDateStr(newStartDate);
              if (this.checkProhibitedOverlap(checkDateStr, entry.name, newStartDate, finalEndDate, entry)) {
                new import_obsidian5.Notice(`\u274C ${t("validation.overlappingEntry")}`);
                return;
              }
            }
            entry.startTime = Utils.toLocalISOString(newStartDate);
            entry.endTime = finalEndDate ? Utils.toLocalISOString(finalEndDate) : null;
            await this.saveWithErrorHandling();
            new import_obsidian5.Notice(`\u2705 ${t("notifications.entryUpdated")}`);
            this.data.rawEntries = this.timerManager.convertToTimeEntries();
            this.data.processEntries();
            this.updateDayCard();
            this.updateWeekCard();
            this.updateStatsCard();
            this.updateMonthCard();
            this.isModalOpen = false;
            modal.remove();
          };
          if (newEndTimeValue) {
            const newEndDate = /* @__PURE__ */ new Date(`${newEndDateValue}T${newEndTimeValue}:00`);
            if (isNaN(newEndDate.getTime())) {
              new import_obsidian5.Notice(`\u274C ${t("validation.invalidEndDateTime")}`);
              return;
            }
            if (newEndDate <= newStartDate) {
              new import_obsidian5.Notice(`\u274C ${t("validation.endAfterStart")}`);
              return;
            }
            void saveUpdate(newEndDate);
          } else {
            void saveUpdate(null);
          }
        }
      };
      buttonDiv.appendChild(editBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = `\u{1F5D1}\uFE0F ${t("buttons.delete")}`;
      deleteBtn.onclick = () => {
        this.showDeleteConfirmation(entry, dateObj, async () => {
          let deleted = false;
          if (item.parent && item.subIndex !== void 0) {
            if (item.parent.subEntries) {
              item.parent.subEntries.splice(item.subIndex, 1);
              if (item.parent.subEntries.length === 0) {
                const parentIndex = this.timerManager.data.entries.indexOf(item.parent);
                if (parentIndex > -1) {
                  this.timerManager.data.entries.splice(parentIndex, 1);
                }
              }
              deleted = true;
            }
          } else {
            const entryIndex = this.timerManager.data.entries.indexOf(entry);
            if (entryIndex > -1) {
              this.timerManager.data.entries.splice(entryIndex, 1);
              deleted = true;
            }
          }
          if (deleted) {
            await this.saveWithErrorHandling();
            new import_obsidian5.Notice(`\u2705 ${t("notifications.deleted")}`);
            this.data.rawEntries = this.timerManager.convertToTimeEntries();
            this.data.processEntries();
            this.updateDayCard();
            this.updateWeekCard();
            this.updateStatsCard();
            this.updateMonthCard();
            this.isModalOpen = false;
            modal.remove();
          }
        });
      };
      buttonDiv.appendChild(deleteBtn);
      entryDiv.appendChild(buttonDiv);
      content.appendChild(entryDiv);
    });
    const closeDiv = document.createElement("div");
    closeDiv.className = "tf-modal-close-row";
    const closeBtn = document.createElement("button");
    closeBtn.textContent = t("buttons.close");
    closeBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    closeDiv.appendChild(closeBtn);
    content.appendChild(closeDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  showSpecialDayModal(dateObj) {
    const dateStr = Utils.toLocalDateStr(dateObj);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-w-400";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    modalContent.addEventListener("beforeinput", (e) => e.stopPropagation());
    modalContent.addEventListener("input", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = t("modals.registerSpecialDayTitle");
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    const dateDisplay = document.createElement("div");
    dateDisplay.textContent = `${t("ui.date")}: ${dateStr}`;
    dateDisplay.className = "tf-date-display";
    content.appendChild(dateDisplay);
    const multiDayContainer = document.createElement("div");
    multiDayContainer.className = "tf-mb-15";
    const multiDayRow = document.createElement("div");
    multiDayRow.className = "tf-checkbox-row";
    const multiDayCheckbox = document.createElement("input");
    multiDayCheckbox.type = "checkbox";
    multiDayCheckbox.id = "multiDayCheckbox";
    multiDayRow.appendChild(multiDayCheckbox);
    const multiDayLabel = document.createElement("label");
    multiDayLabel.htmlFor = "multiDayCheckbox";
    multiDayLabel.textContent = t("ui.multipleDays");
    multiDayLabel.className = "tf-cursor-pointer";
    multiDayRow.appendChild(multiDayLabel);
    multiDayContainer.appendChild(multiDayRow);
    const dateRangeContainer = document.createElement("div");
    dateRangeContainer.className = "tf-hidden";
    const startDateRow = document.createElement("div");
    startDateRow.className = "tf-date-row";
    const startDateLabel = document.createElement("span");
    startDateLabel.textContent = t("ui.startDate") + ":";
    startDateLabel.className = "tf-date-label";
    startDateRow.appendChild(startDateLabel);
    const startDateInput = document.createElement("input");
    startDateInput.type = "date";
    startDateInput.value = dateStr;
    startDateInput.className = "tf-input-grow";
    startDateRow.appendChild(startDateInput);
    dateRangeContainer.appendChild(startDateRow);
    const endDateRow = document.createElement("div");
    endDateRow.className = "tf-date-row tf-mb-0";
    const endDateLabel = document.createElement("span");
    endDateLabel.textContent = t("ui.endDate") + ":";
    endDateLabel.className = "tf-date-label";
    endDateRow.appendChild(endDateLabel);
    const endDateInput = document.createElement("input");
    endDateInput.type = "date";
    endDateInput.value = dateStr;
    endDateInput.className = "tf-input-grow";
    endDateRow.appendChild(endDateInput);
    dateRangeContainer.appendChild(endDateRow);
    const daysCountDisplay = document.createElement("div");
    daysCountDisplay.className = "tf-days-count";
    const updateDaysCount = () => {
      const start = new Date(startDateInput.value);
      const end = new Date(endDateInput.value);
      if (start && end && end >= start) {
        const days = Math.floor((end.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) + 1;
        daysCountDisplay.textContent = `${days} ${days === 1 ? t("units.day") : t("units.days")}`;
      } else {
        daysCountDisplay.textContent = t("validation.invalidDateRange") || "Invalid date range";
      }
    };
    updateDaysCount();
    startDateInput.addEventListener("change", updateDaysCount);
    endDateInput.addEventListener("change", updateDaysCount);
    dateRangeContainer.appendChild(daysCountDisplay);
    multiDayContainer.appendChild(dateRangeContainer);
    const updateMultiDayVisibility = () => {
      const isMultiDay = multiDayCheckbox.checked;
      if (isMultiDay) {
        dateDisplay.addClass("tf-hidden");
        dateRangeContainer.removeClass("tf-hidden");
      } else {
        dateDisplay.removeClass("tf-hidden");
        dateRangeContainer.addClass("tf-hidden");
      }
    };
    multiDayCheckbox.addEventListener("change", updateMultiDayVisibility);
    content.appendChild(multiDayContainer);
    const typeLabel = document.createElement("div");
    typeLabel.textContent = t("modals.dayType");
    typeLabel.className = "tf-label-bold-mb";
    content.appendChild(typeLabel);
    const dayTypes = this.settings.specialDayBehaviors.filter((behavior) => !behavior.isWorkType).map((behavior) => ({
      type: behavior.id,
      label: `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`
    }));
    const typeSelect = document.createElement("select");
    typeSelect.className = "tf-select-full";
    dayTypes.forEach(({ type, label }) => {
      const option = document.createElement("option");
      option.value = type;
      option.textContent = label;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const isReduceGoalType = (typeId) => {
      const behavior = this.settings.specialDayBehaviors.find((b) => b.id === typeId);
      return (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal";
    };
    const timeContainer = document.createElement("div");
    timeContainer.className = "tf-mb-15 tf-hidden";
    const timeLabel = document.createElement("div");
    timeLabel.textContent = "Tidsperiode:";
    timeLabel.className = "tf-label-bold-mb";
    timeContainer.appendChild(timeLabel);
    const timeInputRow = document.createElement("div");
    timeInputRow.className = "tf-time-input-row";
    const fromLabel = document.createElement("span");
    fromLabel.textContent = "Fra:";
    timeInputRow.appendChild(fromLabel);
    const workdayHours = this.settings.baseWorkday * this.settings.workPercent;
    const defaultEndHour = 8 + workdayHours;
    const endH = Math.floor(defaultEndHour);
    const endM = Math.round((defaultEndHour - endH) * 60);
    const defaultEndTime = `${endH.toString().padStart(2, "0")}:${endM.toString().padStart(2, "0")}`;
    const fromTimeInput = this.createTimeInput("08:00", () => {
    });
    fromTimeInput.className = "tf-time-input-styled";
    timeInputRow.appendChild(fromTimeInput);
    const toLabel = document.createElement("span");
    toLabel.textContent = "Til:";
    timeInputRow.appendChild(toLabel);
    const toTimeInput = this.createTimeInput(defaultEndTime, () => {
    });
    toTimeInput.className = "tf-time-input-styled";
    timeInputRow.appendChild(toTimeInput);
    timeContainer.appendChild(timeInputRow);
    const durationDisplay = document.createElement("div");
    durationDisplay.className = "tf-duration-display";
    const updateDuration = () => {
      const from = fromTimeInput.value;
      const to = toTimeInput.value;
      if (from && to) {
        const [fH, fM] = from.split(":").map(Number);
        const [tH, tM] = to.split(":").map(Number);
        const hours = tH + tM / 60 - (fH + fM / 60);
        if (hours > 0) {
          durationDisplay.textContent = `Varighet: ${hours.toFixed(1)} timer`;
        } else {
          durationDisplay.textContent = "Ugyldig tidsperiode";
        }
      }
    };
    updateDuration();
    fromTimeInput.addEventListener("change", updateDuration);
    toTimeInput.addEventListener("change", updateDuration);
    timeContainer.appendChild(durationDisplay);
    content.appendChild(timeContainer);
    const sickTimeContainer = document.createElement("div");
    sickTimeContainer.className = "tf-mb-15 tf-hidden";
    const sickTimeLabel = document.createElement("div");
    sickTimeLabel.textContent = t("modals.timePeriod") || "Tidsperiode:";
    sickTimeLabel.className = "tf-label-bold-mb";
    sickTimeContainer.appendChild(sickTimeLabel);
    const sickTimeInputRow = document.createElement("div");
    sickTimeInputRow.className = "tf-time-input-row";
    const sickFromLabel = document.createElement("span");
    sickFromLabel.textContent = t("modals.from") || "Fra:";
    sickTimeInputRow.appendChild(sickFromLabel);
    const sickDateStr = Utils.toLocalDateStr(dateObj);
    let autoSickFromTime = "14:00";
    let autoSickToTime = defaultEndTime;
    const workEntries = this.timerManager.data.entries.filter((entry) => {
      var _a;
      if (!entry.endTime) return false;
      const entryDate = Utils.toLocalDateStr(new Date(entry.startTime || ""));
      const behavior = (_a = this.settings.specialDayBehaviors) == null ? void 0 : _a.find((b) => b.id === entry.name.toLowerCase());
      const isWorkType = (behavior == null ? void 0 : behavior.isWorkType) || entry.name.toLowerCase() === "jobb";
      return entryDate === sickDateStr && isWorkType;
    });
    if (workEntries.length > 0) {
      let totalWorkedHours = 0;
      let earliestStartTime = /* @__PURE__ */ new Date();
      let latestEndTime = /* @__PURE__ */ new Date(0);
      for (const entry of workEntries) {
        const startDate = new Date(entry.startTime);
        const endDate = new Date(entry.endTime);
        totalWorkedHours += (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
        if (startDate < earliestStartTime) {
          earliestStartTime = startDate;
        }
        if (endDate > latestEndTime) {
          latestEndTime = endDate;
        }
      }
      const endH2 = latestEndTime.getHours();
      const endM2 = latestEndTime.getMinutes();
      autoSickFromTime = `${endH2.toString().padStart(2, "0")}:${endM2.toString().padStart(2, "0")}`;
      const dailyGoal = this.settings.baseWorkday * this.settings.workPercent;
      const remainingHours = Math.max(0, dailyGoal - totalWorkedHours);
      if (remainingHours > 0) {
        const sickEndDate = new Date(latestEndTime.getTime() + remainingHours * 60 * 60 * 1e3);
        const sickEndH = sickEndDate.getHours();
        const sickEndM = sickEndDate.getMinutes();
        autoSickToTime = `${sickEndH.toString().padStart(2, "0")}:${sickEndM.toString().padStart(2, "0")}`;
      }
    }
    const sickFromTimeInput = this.createTimeInput(autoSickFromTime, () => {
    });
    sickFromTimeInput.className = "tf-time-input-styled";
    sickTimeInputRow.appendChild(sickFromTimeInput);
    const sickToLabel = document.createElement("span");
    sickToLabel.textContent = t("modals.to") || "Til:";
    sickTimeInputRow.appendChild(sickToLabel);
    const sickToTimeInput = this.createTimeInput(autoSickToTime, () => {
    });
    sickToTimeInput.className = "tf-time-input-styled";
    sickTimeInputRow.appendChild(sickToTimeInput);
    sickTimeContainer.appendChild(sickTimeInputRow);
    const sickDurationDisplay = document.createElement("div");
    sickDurationDisplay.className = "tf-duration-display";
    const updateSickDuration = () => {
      const from = sickFromTimeInput.value;
      const to = sickToTimeInput.value;
      if (from && to) {
        const [fH, fM] = from.split(":").map(Number);
        const [tH, tM] = to.split(":").map(Number);
        const hours = tH + tM / 60 - (fH + fM / 60);
        if (hours > 0) {
          sickDurationDisplay.textContent = `${t("ui.duration") || "Varighet"}: ${hours.toFixed(1)} ${this.settings.hourUnit || "t"}`;
        } else if (hours === 0) {
          sickDurationDisplay.textContent = t("modals.fullDayHint") || "La st\xE5 tom for hel dag";
        } else {
          sickDurationDisplay.textContent = t("validation.invalidTimePeriod") || "Ugyldig tidsperiode";
        }
      }
    };
    updateSickDuration();
    sickFromTimeInput.addEventListener("change", updateSickDuration);
    sickToTimeInput.addEventListener("change", updateSickDuration);
    sickTimeContainer.appendChild(sickDurationDisplay);
    const fullDayRow = document.createElement("div");
    fullDayRow.className = "tf-checkbox-row-mt";
    const fullDayCheckbox = document.createElement("input");
    fullDayCheckbox.type = "checkbox";
    fullDayCheckbox.id = "fullDayCheckbox";
    fullDayCheckbox.checked = workEntries.length === 0;
    fullDayRow.appendChild(fullDayCheckbox);
    const fullDayLabel = document.createElement("label");
    fullDayLabel.htmlFor = "fullDayCheckbox";
    fullDayLabel.textContent = t("ui.fullDay") || "Hel dag";
    fullDayLabel.className = "tf-cursor-pointer";
    fullDayRow.appendChild(fullDayLabel);
    sickTimeContainer.appendChild(fullDayRow);
    const updateSickTimeInputs = () => {
      const isFullDay = fullDayCheckbox.checked;
      if (isFullDay) {
        sickTimeInputRow.addClass("tf-hidden");
        sickDurationDisplay.addClass("tf-hidden");
      } else {
        sickTimeInputRow.removeClass("tf-hidden");
        sickDurationDisplay.removeClass("tf-hidden");
      }
    };
    fullDayCheckbox.addEventListener("change", updateSickTimeInputs);
    updateSickTimeInputs();
    content.appendChild(sickTimeContainer);
    const annetContainer = document.createElement("div");
    annetContainer.className = "tf-mb-15 tf-hidden";
    const annetTemplateLabel = document.createElement("div");
    annetTemplateLabel.textContent = t("annet.selectTemplate");
    annetTemplateLabel.className = "tf-label-bold-mb-8";
    annetContainer.appendChild(annetTemplateLabel);
    const annetTemplateButtons = document.createElement("div");
    annetTemplateButtons.className = "tf-template-btn-container";
    let selectedAnnetTemplate = null;
    const annetTemplates = this.settings.annetTemplates || [];
    const templateButtonRefs = [];
    annetTemplates.forEach((template) => {
      const btn = document.createElement("button");
      btn.textContent = `${template.icon} ${translateAnnetTemplateName(template.id, template.label)}`;
      btn.className = "tf-template-btn";
      btn.dataset.templateId = template.id;
      templateButtonRefs.push(btn);
      annetTemplateButtons.appendChild(btn);
    });
    const customBtn = document.createElement("button");
    customBtn.textContent = `\u{1F4CB} ${t("annet.custom")}`;
    customBtn.className = "tf-template-btn";
    customBtn.onclick = () => {
      annetTemplateButtons.querySelectorAll("button").forEach((b) => {
        b.classList.remove("mod-cta");
      });
      customBtn.classList.add("mod-cta");
      selectedAnnetTemplate = null;
      saveAsTemplateContainer.removeClass("tf-hidden");
    };
    annetTemplateButtons.appendChild(customBtn);
    annetContainer.appendChild(annetTemplateButtons);
    const saveAsTemplateContainer = document.createElement("div");
    saveAsTemplateContainer.className = "tf-save-template-container tf-hidden";
    const templateNameRow = document.createElement("div");
    templateNameRow.className = "tf-flex-input-row";
    const templateNameLabel = document.createElement("span");
    templateNameLabel.textContent = t("annet.templateName") + ":";
    templateNameLabel.className = "tf-date-label";
    templateNameRow.appendChild(templateNameLabel);
    const templateNameInput = document.createElement("input");
    templateNameInput.type = "text";
    templateNameInput.className = "tf-input-grow";
    templateNameInput.placeholder = t("annet.labelPlaceholder");
    templateNameRow.appendChild(templateNameInput);
    saveAsTemplateContainer.appendChild(templateNameRow);
    const templateIconRow = document.createElement("div");
    templateIconRow.className = "tf-flex-input-row";
    const templateIconLabel = document.createElement("span");
    templateIconLabel.textContent = t("annet.templateIcon") + ":";
    templateIconLabel.className = "tf-date-label";
    templateIconRow.appendChild(templateIconLabel);
    const templateIconInput = document.createElement("input");
    templateIconInput.type = "text";
    templateIconInput.className = "tf-icon-input";
    templateIconInput.placeholder = "\u{1F3E5}";
    templateIconRow.appendChild(templateIconInput);
    saveAsTemplateContainer.appendChild(templateIconRow);
    const saveAsTemplateRow = document.createElement("div");
    saveAsTemplateRow.className = "tf-save-template-row";
    const saveAsTemplateCheckbox = document.createElement("input");
    saveAsTemplateCheckbox.type = "checkbox";
    saveAsTemplateCheckbox.id = "saveAsTemplateCheckbox";
    saveAsTemplateRow.appendChild(saveAsTemplateCheckbox);
    const saveAsTemplateLabel = document.createElement("label");
    saveAsTemplateLabel.htmlFor = "saveAsTemplateCheckbox";
    saveAsTemplateLabel.textContent = t("annet.saveAsTemplate");
    saveAsTemplateLabel.className = "tf-cursor-pointer";
    saveAsTemplateRow.appendChild(saveAsTemplateLabel);
    saveAsTemplateContainer.appendChild(saveAsTemplateRow);
    annetContainer.appendChild(saveAsTemplateContainer);
    templateButtonRefs.forEach((btn) => {
      const templateId = btn.dataset.templateId;
      btn.onclick = () => {
        annetTemplateButtons.querySelectorAll("button").forEach((b) => {
          b.classList.remove("mod-cta");
        });
        btn.classList.add("mod-cta");
        selectedAnnetTemplate = templateId || null;
        saveAsTemplateContainer.addClass("tf-hidden");
        saveAsTemplateCheckbox.checked = false;
        templateNameInput.value = "";
        templateIconInput.value = "";
      };
    });
    const annetFullDayRow = document.createElement("div");
    annetFullDayRow.className = "tf-checkbox-row-mb";
    const annetFullDayCheckbox = document.createElement("input");
    annetFullDayCheckbox.type = "checkbox";
    annetFullDayCheckbox.id = "annetFullDayCheckbox";
    annetFullDayCheckbox.checked = true;
    annetFullDayRow.appendChild(annetFullDayCheckbox);
    const annetFullDayLabel = document.createElement("label");
    annetFullDayLabel.htmlFor = "annetFullDayCheckbox";
    annetFullDayLabel.textContent = t("annet.fullDay");
    annetFullDayLabel.className = "tf-cursor-pointer";
    annetFullDayRow.appendChild(annetFullDayLabel);
    annetContainer.appendChild(annetFullDayRow);
    const annetTimeInputRow = document.createElement("div");
    annetTimeInputRow.className = "tf-time-input-row tf-mb-12 tf-hidden";
    const annetFromLabel = document.createElement("span");
    annetFromLabel.textContent = t("annet.fromTime") + ":";
    annetTimeInputRow.appendChild(annetFromLabel);
    const annetFromTimeInput = this.createTimeInput("09:00", () => {
    });
    annetFromTimeInput.className = "tf-time-input-styled";
    annetTimeInputRow.appendChild(annetFromTimeInput);
    const annetToLabel = document.createElement("span");
    annetToLabel.textContent = t("annet.toTime") + ":";
    annetTimeInputRow.appendChild(annetToLabel);
    const annetToTimeInput = this.createTimeInput("11:00", () => {
    });
    annetToTimeInput.className = "tf-time-input-styled";
    annetTimeInputRow.appendChild(annetToTimeInput);
    annetContainer.appendChild(annetTimeInputRow);
    const annetDurationDisplay = document.createElement("div");
    annetDurationDisplay.className = "tf-duration-display-mb tf-hidden";
    const updateAnnetDuration = () => {
      const from = annetFromTimeInput.value;
      const to = annetToTimeInput.value;
      if (from && to) {
        const [fH, fM] = from.split(":").map(Number);
        const [tH, tM] = to.split(":").map(Number);
        const hours = tH + tM / 60 - (fH + fM / 60);
        if (hours > 0) {
          annetDurationDisplay.textContent = `${t("modals.duration") || "Varighet"}: ${hours.toFixed(1)} ${t("units.hours") || "timer"}`;
        } else {
          annetDurationDisplay.textContent = t("validation.invalidTimePeriod") || "Ugyldig tidsperiode";
        }
      }
    };
    updateAnnetDuration();
    annetFromTimeInput.addEventListener("change", updateAnnetDuration);
    annetToTimeInput.addEventListener("change", updateAnnetDuration);
    annetContainer.appendChild(annetDurationDisplay);
    const updateAnnetTimeInputs = () => {
      const isFullDay = annetFullDayCheckbox.checked;
      if (isFullDay) {
        annetTimeInputRow.addClass("tf-hidden");
        annetDurationDisplay.addClass("tf-hidden");
      } else {
        annetTimeInputRow.removeClass("tf-hidden");
        annetDurationDisplay.removeClass("tf-hidden");
      }
    };
    annetFullDayCheckbox.addEventListener("change", updateAnnetTimeInputs);
    updateAnnetTimeInputs();
    content.appendChild(annetContainer);
    const noteLabel = document.createElement("div");
    noteLabel.textContent = t("modals.commentOptional");
    noteLabel.className = "tf-label-bold-mb";
    content.appendChild(noteLabel);
    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.className = "tf-text-input-full";
    content.appendChild(noteInput);
    const getPlaceholderForType = (type) => {
      const placeholders = t("modals.commentPlaceholders");
      return placeholders[type] || placeholders["default"] || t("modals.commentPlaceholder");
    };
    const updateFieldVisibility = () => {
      const selectedType = typeSelect.value;
      if (selectedType === "avspasering") {
        timeContainer.removeClass("tf-hidden");
      } else {
        timeContainer.addClass("tf-hidden");
      }
      if (isReduceGoalType(selectedType) && selectedType !== "annet") {
        sickTimeContainer.removeClass("tf-hidden");
      } else {
        sickTimeContainer.addClass("tf-hidden");
      }
      if (selectedType === "annet") {
        annetContainer.removeClass("tf-hidden");
      } else {
        annetContainer.addClass("tf-hidden");
      }
      if (selectedType === "annet") {
        multiDayContainer.addClass("tf-hidden");
      } else {
        multiDayContainer.removeClass("tf-hidden");
      }
      if (selectedType === "annet") {
        multiDayCheckbox.checked = false;
        updateMultiDayVisibility();
      }
      noteInput.placeholder = getPlaceholderForType(selectedType);
    };
    typeSelect.addEventListener("change", updateFieldVisibility);
    updateFieldVisibility();
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-btn-container";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(cancelBtn);
    const addBtn = document.createElement("button");
    addBtn.textContent = t("buttons.add");
    addBtn.className = "mod-cta";
    addBtn.onclick = async () => {
      var _a, _b;
      const dayType = typeSelect.value;
      const note = noteInput.value.trim();
      const startTime = dayType === "avspasering" ? fromTimeInput.value : void 0;
      const endTime = dayType === "avspasering" ? toTimeInput.value : void 0;
      if (dayType === "annet") {
        const isFullDay = annetFullDayCheckbox.checked;
        let templateId = selectedAnnetTemplate;
        let entryDescription = note;
        if (selectedAnnetTemplate === null) {
          const customName = templateNameInput.value.trim();
          const customIcon = templateIconInput.value.trim() || "\u{1F4CB}";
          if (saveAsTemplateCheckbox.checked) {
            if (!customName) {
              new import_obsidian5.Notice(`\u274C ${t("annet.labelRequired")}`);
              return;
            }
            const newTemplateId = customName.toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
            if (this.settings.annetTemplates.some((tmpl) => tmpl.id === newTemplateId)) {
              new import_obsidian5.Notice(`\u274C ${t("annet.duplicateId")}`);
              return;
            }
            this.settings.annetTemplates.push({
              id: newTemplateId,
              label: customName,
              icon: customIcon
            });
            await this.plugin.saveSettings();
            new import_obsidian5.Notice(`\u2705 ${t("annet.addTemplate")}: ${customIcon} ${customName}`);
            templateId = newTemplateId;
          } else if (customName) {
            const prefix = `${customIcon} ${customName}`;
            entryDescription = note ? `${prefix}: ${note}` : prefix;
          }
        }
        if (!isFullDay) {
          const from = annetFromTimeInput.value;
          const to = annetToTimeInput.value;
          const [fH, fM] = from.split(":").map(Number);
          const [tH, tM] = to.split(":").map(Number);
          const hours = tH + tM / 60 - (fH + fM / 60);
          if (hours <= 0) {
            new import_obsidian5.Notice(`\u274C ${t("validation.invalidTimePeriod") || "Ugyldig tidsperiode"}`);
            return;
          }
          await this.addAnnetEntry(dateObj, templateId, from, to, entryDescription);
        } else {
          await this.addAnnetEntry(dateObj, templateId, null, null, entryDescription);
        }
      } else if (isReduceGoalType(dayType)) {
        const isFullDay = fullDayCheckbox.checked;
        if (!isFullDay) {
          const from = sickFromTimeInput.value;
          const to = sickToTimeInput.value;
          const [fH, fM] = from.split(":").map(Number);
          const [tH, tM] = to.split(":").map(Number);
          const sickHours = tH + tM / 60 - (fH + fM / 60);
          if (sickHours > 0) {
            const entryStartDate = new Date(dateObj);
            entryStartDate.setHours(fH, fM, 0, 0);
            const entryEndDate = new Date(dateObj);
            entryEndDate.setHours(tH, tM, 0, 0);
            this.timerManager.data.entries.push({
              name: dayType,
              startTime: Utils.toLocalISOString(entryStartDate),
              endTime: Utils.toLocalISOString(entryEndDate),
              subEntries: null
            });
            await this.saveWithErrorHandling();
            new import_obsidian5.Notice(`\u2705 ${translateSpecialDayName(dayType)}: ${sickHours.toFixed(1)}${this.settings.hourUnit || "t"} for ${Utils.toLocalDateStr(dateObj)}`);
            (_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a);
          } else {
            new import_obsidian5.Notice(`\u274C ${t("validation.invalidTimePeriod") || "Ugyldig tidsperiode"}`);
            return;
          }
        } else {
          await this.addSpecialDay(dateObj, dayType, note);
        }
      } else {
        if (multiDayCheckbox.checked) {
          const startDate = new Date(startDateInput.value);
          const endDate = new Date(endDateInput.value);
          if (endDate < startDate) {
            new import_obsidian5.Notice(`\u274C ${t("validation.invalidDateRange") || "Invalid date range"}`);
            return;
          }
          const currentDate = new Date(startDate);
          let daysAdded = 0;
          while (currentDate <= endDate) {
            if (!Utils.isWeekend(currentDate, this.settings)) {
              await this.addSpecialDay(new Date(currentDate), dayType, note, startTime, endTime);
              daysAdded++;
            }
            currentDate.setDate(currentDate.getDate() + 1);
          }
          const behavior = this.settings.specialDayBehaviors.find((b) => b.id === dayType);
          const typeName = behavior ? translateSpecialDayName(behavior.id, behavior.label) : dayType;
          new import_obsidian5.Notice(`\u2705 ${typeName}: ${daysAdded} ${daysAdded === 1 ? t("units.day") : t("units.days")}`);
        } else {
          await this.addSpecialDay(dateObj, dayType, note, startTime, endTime);
        }
      }
      this.isModalOpen = false;
      modal.remove();
    };
    buttonDiv.appendChild(addBtn);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    typeSelect.focus();
  }
  async addSpecialDay(dateObj, dayType, note = "", startTime, endTime) {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(filePath));
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.fileNotFound").replace("{path}", filePath)}`);
        return;
      }
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      const dateStr = `${year}-${month}-${day}`;
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.sectionNotFound")}`);
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.codeBlockNotFound")}`);
        return;
      }
      let typeWithModifier = dayType;
      if (dayType === "avspasering" && startTime && endTime) {
        typeWithModifier = `${dayType}:${startTime}-${endTime}`;
      }
      const newEntry = `- ${dateStr}: ${typeWithModifier}: ${note}`;
      const beforeClosing = content.substring(0, codeBlockEnd);
      const afterClosing = content.substring(codeBlockEnd);
      const needsNewline = !beforeClosing.endsWith("\n");
      content = beforeClosing + (needsNewline ? "\n" : "") + newEntry + "\n" + afterClosing;
      await this.app.vault.modify(file, content);
      const label = translateSpecialDayName(dayType);
      new import_obsidian5.Notice(`\u2705 ${t("notifications.added")} ${dateStr} (${label})`);
      await this.data.loadHolidays();
      this.updateMonthCard();
    } catch (error) {
      console.error("Failed to add special day:", error);
      new import_obsidian5.Notice(`\u274C ${t("notifications.errorAddingSpecialDay")}`);
    }
  }
  /**
   * Add an annet (other) entry to the holidays file
   * Format: - YYYY-MM-DD: annet:templateId:HH:MM-HH:MM: description
   *    or:  - YYYY-MM-DD: annet:templateId: description (full day)
   *    or:  - YYYY-MM-DD: annet:HH:MM-HH:MM: description (partial, no template)
   *    or:  - YYYY-MM-DD: annet: description (full day, no template)
   */
  async addAnnetEntry(dateObj, templateId, startTime, endTime, note) {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(filePath));
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.fileNotFound").replace("{path}", filePath)}`);
        return;
      }
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      const dateStr = `${year}-${month}-${day}`;
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.sectionNotFound")}`);
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.codeBlockNotFound")}`);
        return;
      }
      let annetType = "annet";
      if (templateId) {
        annetType += `:${templateId}`;
      }
      if (startTime && endTime) {
        annetType += `:${startTime}-${endTime}`;
      }
      const newEntry = `- ${dateStr}: ${annetType}: ${note}`;
      const beforeClosing = content.substring(0, codeBlockEnd);
      const afterClosing = content.substring(codeBlockEnd);
      const needsNewline = !beforeClosing.endsWith("\n");
      content = beforeClosing + (needsNewline ? "\n" : "") + newEntry + "\n" + afterClosing;
      await this.app.vault.modify(file, content);
      let label = t("annet.title");
      if (templateId) {
        const template = this.settings.annetTemplates.find((t2) => t2.id === templateId);
        if (template) {
          label = `${template.icon} ${translateAnnetTemplateName(template.id, template.label)}`;
        }
      }
      if (startTime && endTime) {
        new import_obsidian5.Notice(`\u2705 ${t("notifications.added")} ${dateStr} (${label} ${startTime}-${endTime})`);
      } else {
        new import_obsidian5.Notice(`\u2705 ${t("notifications.added")} ${dateStr} (${label})`);
      }
      await this.data.loadHolidays();
      this.updateMonthCard();
    } catch (error) {
      console.error("Failed to add annet entry:", error);
      new import_obsidian5.Notice(`\u274C ${t("notifications.errorAddingSpecialDay")}`);
    }
  }
  /**
   * Show modal to edit or delete an existing planned day
   */
  showEditPlannedDayModal(dateObj, plannedInfo) {
    var _a;
    const dateStr = Utils.toLocalDateStr(dateObj);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-content-400";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    modalContent.addEventListener("beforeinput", (e) => e.stopPropagation());
    modalContent.addEventListener("input", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    const emoji = Utils.getEmoji({ name: plannedInfo.type, date: dateObj });
    let typeName = translateSpecialDayName(plannedInfo.type);
    if (plannedInfo.type === "annet" && plannedInfo.annetTemplateId) {
      const template = (_a = this.settings.annetTemplates) == null ? void 0 : _a.find((tmpl) => tmpl.id === plannedInfo.annetTemplateId);
      if (template) {
        typeName = translateAnnetTemplateName(template.id, template.label);
      }
    }
    title.textContent = `${t("menu.editPlannedDay")} ${emoji} ${typeName}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-modal-content-padded";
    const dateDisplay = document.createElement("div");
    dateDisplay.textContent = `${t("ui.date")}: ${dateStr}`;
    dateDisplay.className = "tf-date-display";
    content.appendChild(dateDisplay);
    const typeDisplay = document.createElement("div");
    typeDisplay.className = "tf-type-display";
    const typeLabel = document.createElement("strong");
    typeLabel.textContent = `${t("ui.type")}:`;
    typeDisplay.appendChild(typeLabel);
    typeDisplay.appendText(` ${emoji} ${typeName}`);
    if (plannedInfo.halfDay) {
      typeDisplay.appendText(" (\xBD)");
    }
    content.appendChild(typeDisplay);
    if (plannedInfo.startTime && plannedInfo.endTime) {
      const timeDisplay = document.createElement("div");
      timeDisplay.className = "tf-mb-15";
      const timeLabel = document.createElement("strong");
      timeLabel.textContent = `${t("ui.start")} - ${t("ui.end")}:`;
      timeDisplay.appendChild(timeLabel);
      timeDisplay.appendText(` ${plannedInfo.startTime} - ${plannedInfo.endTime}`);
      content.appendChild(timeDisplay);
    }
    const descRow = document.createElement("div");
    descRow.className = "tf-desc-row";
    const descLabel = document.createElement("label");
    descLabel.textContent = `${t("ui.comment")} (${t("ui.optional")}):`;
    descLabel.className = "tf-label-block";
    descRow.appendChild(descLabel);
    const descInput = document.createElement("input");
    descInput.type = "text";
    descInput.value = plannedInfo.description || "";
    descInput.className = "tf-input-full";
    descRow.appendChild(descInput);
    content.appendChild(descRow);
    const buttonDiv = document.createElement("div");
    buttonDiv.className = "tf-btn-space-between";
    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = `\u{1F5D1}\uFE0F ${t("buttons.delete")}`;
    deleteBtn.className = "mod-warning tf-delete-btn";
    deleteBtn.onclick = () => {
      this.showConfirmDialog(t("confirm.deleteEntry"), async () => {
        await this.deletePlannedDay(dateStr);
        this.isModalOpen = false;
        modal.remove();
      });
    };
    buttonDiv.appendChild(deleteBtn);
    const rightButtons = document.createElement("div");
    rightButtons.className = "tf-flex tf-gap-10";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    rightButtons.appendChild(cancelBtn);
    const saveBtn = document.createElement("button");
    saveBtn.textContent = t("buttons.save");
    saveBtn.className = "mod-cta";
    saveBtn.onclick = async () => {
      const newDescription = descInput.value.trim();
      await this.updatePlannedDayDescription(dateStr, newDescription);
      this.isModalOpen = false;
      modal.remove();
    };
    rightButtons.appendChild(saveBtn);
    buttonDiv.appendChild(rightButtons);
    content.appendChild(buttonDiv);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    descInput.focus();
  }
  /**
   * Delete a planned day entry from the holidays file
   */
  async deletePlannedDay(dateStr) {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(filePath));
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.fileNotFound").replace("{path}", filePath)}`);
        return;
      }
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.sectionNotFound")}`);
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.codeBlockNotFound")}`);
        return;
      }
      const codeBlockContent = content.substring(codeBlockStart, codeBlockEnd + 3);
      const lines = codeBlockContent.split("\n");
      const filteredLines = lines.filter((line) => !line.includes(`- ${dateStr}:`));
      if (filteredLines.length === lines.length) {
        new import_obsidian5.Notice(`\u274C Entry not found for ${dateStr}`);
        return;
      }
      const newCodeBlock = filteredLines.join("\n");
      content = content.substring(0, codeBlockStart) + newCodeBlock + content.substring(codeBlockEnd + 3);
      await this.app.vault.modify(file, content);
      new import_obsidian5.Notice(`\u2705 ${t("notifications.deleted")} ${dateStr}`);
      await this.data.loadHolidays();
      this.data.processEntries();
      this.updateMonthCard();
      this.updateStatsCard();
      this.updateWeekCard();
      this.updateDayCard();
    } catch (error) {
      console.error("Failed to delete planned day:", error);
      new import_obsidian5.Notice(`\u274C ${t("notifications.errorDeletingEntry")}`);
    }
  }
  /**
   * Update the description of a planned day entry
   */
  async updatePlannedDayDescription(dateStr, newDescription) {
    try {
      const filePath = this.settings.holidaysFilePath;
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(filePath));
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.fileNotFound").replace("{path}", filePath)}`);
        return;
      }
      let content = await this.app.vault.read(file);
      const sectionMarker = "## Planlagte egne fridager";
      const sectionIndex = content.indexOf(sectionMarker);
      if (sectionIndex === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.sectionNotFound")}`);
        return;
      }
      const codeBlockStart = content.indexOf("```", sectionIndex);
      const codeBlockEnd = content.indexOf("```", codeBlockStart + 3);
      if (codeBlockStart === -1 || codeBlockEnd === -1) {
        new import_obsidian5.Notice(`\u274C ${t("notifications.codeBlockNotFound")}`);
        return;
      }
      const codeBlockContent = content.substring(codeBlockStart, codeBlockEnd + 3);
      const lines = codeBlockContent.split("\n");
      let updated = false;
      const updatedLines = lines.map((line) => {
        if (line.includes(`- ${dateStr}:`)) {
          updated = true;
          const match = line.match(/^- (\d{4}-\d{2}-\d{2}): ([^:]+(?::[^:]+)*): ?(.*)$/);
          if (match) {
            const [, date, typeWithModifiers] = match;
            return `- ${date}: ${typeWithModifiers}: ${newDescription}`;
          }
          return line;
        }
        return line;
      });
      if (!updated) {
        new import_obsidian5.Notice(`\u274C Entry not found for ${dateStr}`);
        return;
      }
      const newCodeBlock = updatedLines.join("\n");
      content = content.substring(0, codeBlockStart) + newCodeBlock + content.substring(codeBlockEnd + 3);
      await this.app.vault.modify(file, content);
      new import_obsidian5.Notice(`\u2705 ${t("notifications.updated")} ${dateStr}`);
      await this.data.loadHolidays();
      this.data.processEntries();
      this.updateMonthCard();
      this.updateStatsCard();
      this.updateWeekCard();
      this.updateDayCard();
    } catch (error) {
      console.error("Failed to update planned day:", error);
      new import_obsidian5.Notice(`\u274C ${t("notifications.errorUpdatingEntry")}`);
    }
  }
  async createNoteFromType(dateObj, noteType) {
    try {
      const dateStr = Utils.toLocalDateStr(dateObj);
      const weekNum = Utils.getWeekNumber(dateObj);
      let filename = noteType.filenamePattern.replace("{YYYY}", dateObj.getFullYear().toString()).replace("{MM}", (dateObj.getMonth() + 1).toString().padStart(2, "0")).replace("{DD}", dateObj.getDate().toString().padStart(2, "0")).replace("{WEEK}", weekNum.toString());
      const filePath = (0, import_obsidian5.normalizePath)(`${noteType.folder}/${filename}.md`);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian5.TFile) {
        await this.app.workspace.getLeaf(false).openFile(existingFile);
        new import_obsidian5.Notice(t("notifications.openedExistingNote").replace("{filename}", filename));
        return;
      }
      const folderPath = noteType.folder;
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      let content = "";
      const templateFile = this.app.vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(noteType.template));
      if (templateFile && templateFile instanceof import_obsidian5.TFile) {
        content = await this.app.vault.read(templateFile);
      }
      content = content.replace(/{date}/g, dateStr).replace(/{time}/g, (/* @__PURE__ */ new Date()).toLocaleTimeString("nb-NO")).replace(/{week}/g, weekNum.toString());
      if (noteType.tags && noteType.tags.length > 0) {
        content += `

${noteType.tags.join(" ")}`;
      }
      const file = await this.app.vault.create(filePath, content);
      await this.app.workspace.getLeaf(false).openFile(file);
      new import_obsidian5.Notice(t("notifications.createdNote").replace("{filename}", filename));
    } catch (error) {
      new import_obsidian5.Notice(t("notifications.errorCreatingNote").replace("{error}", error instanceof Error ? error.message : String(error)));
      console.error("Error creating note:", error);
    }
  }
  refreshHistoryView(container) {
    container.empty();
    const activeEntries = [];
    const years = {};
    Object.keys(this.data.daily).sort().reverse().forEach((dateKey) => {
      const year = dateKey.split("-")[0];
      if (!years[year]) years[year] = {};
      const month = dateKey.split("-")[1];
      if (!years[year][month]) years[year][month] = [];
      const dayEntries = this.data.daily[dateKey];
      dayEntries.forEach((entry) => {
        if (this.historyView === "list" && this.historyFilter.length > 0) {
          const entryType = entry.name.toLowerCase();
          if (!this.historyFilter.includes(entryType)) {
            return;
          }
        }
        if (entry.isActive && this.historyView === "list") {
          activeEntries.push(entry);
        } else {
          years[year][month].push(entry);
        }
      });
    });
    Object.keys(years).forEach((year) => {
      Object.keys(years[year]).forEach((month) => {
        if (years[year][month].length === 0) {
          delete years[year][month];
        }
      });
      if (Object.keys(years[year]).length === 0) {
        delete years[year];
      }
    });
    if (this.historyView === "list") {
      this.renderListView(container, years, activeEntries);
    } else if (this.historyView === "weekly") {
      this.renderWeeklyView(container, years);
    } else if (this.historyView === "heatmap") {
      this.renderHeatmapView(container, years);
    }
    this.updateEditToggleVisibility(container);
  }
  updateEditToggleVisibility(container) {
    const historyCard = container.closest(".tf-card-history");
    if (!historyCard) return;
    const editToggle = historyCard.querySelector(".tf-history-edit-toggle");
    if (!editToggle) return;
    const isWide = container.offsetWidth >= 450;
    const isListView = this.historyView === "list";
    if (isWide && isListView) {
      editToggle.removeClass("tf-hidden");
    } else {
      editToggle.addClass("tf-hidden");
    }
    editToggle.textContent = this.inlineEditMode ? `\u2713 ${t("buttons.done")}` : `\u270F\uFE0F ${t("buttons.edit")}`;
    editToggle.classList.toggle("active", this.inlineEditMode);
  }
  renderListView(container, years, activeEntries = []) {
    this.renderFilterBar(container);
    if (activeEntries.length > 0) {
      this.renderActiveEntriesSection(container, activeEntries);
    }
    const isWide = container.offsetWidth >= 450;
    if (isWide) {
      this.renderWideListView(container, years);
    } else {
      this.renderNarrowListView(container, years);
    }
    requestAnimationFrame(() => {
      const actualWidth = container.offsetWidth;
      const shouldBeWide = actualWidth >= 450;
      if (shouldBeWide !== isWide) {
        container.empty();
        this.renderFilterBar(container);
        if (activeEntries.length > 0) {
          this.renderActiveEntriesSection(container, activeEntries);
        }
        if (shouldBeWide) {
          this.renderWideListView(container, years);
        } else {
          this.renderNarrowListView(container, years);
        }
      }
    });
  }
  renderFilterBar(container) {
    const filterBar = document.createElement("div");
    filterBar.className = "tf-history-filters";
    const alleChip = document.createElement("button");
    alleChip.className = `tf-filter-chip ${this.historyFilter.length === 0 ? "active" : ""}`;
    alleChip.textContent = t("ui.all");
    alleChip.onclick = () => {
      this.historyFilter = [];
      this.refreshHistoryView(container);
    };
    filterBar.appendChild(alleChip);
    this.settings.specialDayBehaviors.forEach((behavior) => {
      const chip = document.createElement("button");
      const isActive = this.historyFilter.includes(behavior.id);
      chip.className = `tf-filter-chip ${isActive ? "active" : ""}`;
      chip.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
      chip.onclick = () => {
        if (isActive) {
          this.historyFilter = this.historyFilter.filter((f) => f !== behavior.id);
        } else {
          this.historyFilter = [...this.historyFilter, behavior.id];
        }
        this.refreshHistoryView(container);
      };
      filterBar.appendChild(chip);
    });
    container.appendChild(filterBar);
  }
  renderActiveEntriesSection(container, activeEntries) {
    const section = this.createActiveEntriesSection(activeEntries, container);
    container.appendChild(section);
  }
  createActiveEntriesSection(activeEntries, containerForWidth) {
    const section = document.createElement("div");
    section.className = "tf-active-entries-section tf-active-section-container";
    const header = document.createElement("div");
    header.className = "tf-active-section-header";
    header.textContent = `\u23F1\uFE0F ${t("ui.activeTimers")} (${activeEntries.length})`;
    section.appendChild(header);
    const isWide = containerForWidth ? containerForWidth.offsetWidth >= 450 : false;
    const table = document.createElement("table");
    table.className = isWide ? "tf-history-table-wide tf-w-full" : "tf-history-table-narrow tf-w-full";
    const rawEntries = this.timerManager.data.entries;
    const flatRawEntries = [];
    rawEntries.forEach((entry) => {
      if (entry.collapsed && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub, idx) => {
          if (sub.startTime) {
            flatRawEntries.push({ entry: sub, parent: entry, subIndex: idx });
          }
        });
      } else if (entry.startTime) {
        flatRawEntries.push({ entry });
      }
    });
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    const headers = isWide ? this.inlineEditMode ? [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.hours"), t("ui.flextime"), ""] : [t("ui.date"), t("ui.type"), t("ui.start"), t("ui.hours"), t("ui.flextime")] : [t("ui.date"), t("ui.type"), t("ui.hours"), ""];
    headers.forEach((h) => {
      const th = document.createElement("th");
      th.textContent = h;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    activeEntries.forEach((e) => {
      const row = document.createElement("tr");
      row.className = "tf-history-row-active";
      const dateStr = e.date ? Utils.toLocalDateStr(e.date) : "";
      const matchingItem = flatRawEntries.find(
        (item) => item.entry.name.toLowerCase() === e.name.toLowerCase() && !item.entry.endTime && Utils.toLocalDateStr(new Date(item.entry.startTime)) === dateStr
      );
      const matchingRaw = matchingItem == null ? void 0 : matchingItem.entry;
      const dateCell = document.createElement("td");
      const activeIcon = document.createElement("span");
      activeIcon.textContent = "\u23F1\uFE0F ";
      activeIcon.title = t("ui.activeTimer");
      activeIcon.className = "tf-cursor-help";
      dateCell.appendChild(activeIcon);
      dateCell.appendChild(document.createTextNode(dateStr));
      row.appendChild(dateCell);
      const typeCell = document.createElement("td");
      if (isWide && this.inlineEditMode && matchingRaw) {
        const select = document.createElement("select");
        this.settings.specialDayBehaviors.forEach((behavior) => {
          const option = document.createElement("option");
          option.value = behavior.id;
          option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
          if (behavior.id === e.name.toLowerCase()) {
            option.selected = true;
          }
          select.appendChild(option);
        });
        select.onchange = async () => {
          var _a, _b;
          matchingRaw.name = select.value;
          await this.saveWithErrorHandling();
          (_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a);
        };
        typeCell.appendChild(select);
      } else {
        typeCell.textContent = translateSpecialDayName(e.name.toLowerCase(), e.name);
      }
      row.appendChild(typeCell);
      if (isWide) {
        const startCell = document.createElement("td");
        if (matchingRaw == null ? void 0 : matchingRaw.startTime) {
          const startDate = new Date(matchingRaw.startTime);
          const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
          if (this.inlineEditMode) {
            const input = this.createTimeInput(startTimeStr, async (newValue) => {
              var _a, _b;
              const parsed = this.parseTimeInput(newValue);
              if (!parsed) return;
              const newStart = new Date(matchingRaw.startTime);
              newStart.setHours(parsed.hours, parsed.minutes, 0, 0);
              matchingRaw.startTime = Utils.toLocalISOString(newStart);
              await this.saveWithErrorHandling();
              (_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a);
            });
            startCell.appendChild(input);
          } else {
            startCell.textContent = startTimeStr;
          }
        } else {
          startCell.textContent = "-";
        }
        row.appendChild(startCell);
      }
      const hoursCell = document.createElement("td");
      const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
      hoursCell.textContent = `${hoursText}...`;
      row.appendChild(hoursCell);
      if (isWide) {
        const flextimeCell = document.createElement("td");
        flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
        row.appendChild(flextimeCell);
      }
      if (isWide && this.inlineEditMode) {
        const actionCell = document.createElement("td");
        if (matchingItem) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "tf-history-delete-btn";
          deleteBtn.textContent = "\u{1F5D1}\uFE0F";
          deleteBtn.title = t("menu.deleteEntry");
          deleteBtn.onclick = () => {
            this.showConfirmDialog(`${t("confirm.deleteEntryFor")} ${dateStr}?`, async () => {
              if (matchingItem.parent && matchingItem.subIndex !== void 0) {
                if (matchingItem.parent.subEntries) {
                  matchingItem.parent.subEntries.splice(matchingItem.subIndex, 1);
                  if (matchingItem.parent.subEntries.length === 0) {
                    const parentIndex = this.timerManager.data.entries.indexOf(matchingItem.parent);
                    if (parentIndex > -1) {
                      this.timerManager.data.entries.splice(parentIndex, 1);
                    }
                  }
                }
              } else {
                const entryIndex = this.timerManager.data.entries.indexOf(matchingRaw);
                if (entryIndex > -1) {
                  this.timerManager.data.entries.splice(entryIndex, 1);
                }
              }
              await this.saveWithErrorHandling();
              this.softRefreshHistory();
            });
          };
          actionCell.appendChild(deleteBtn);
        }
        row.appendChild(actionCell);
      } else if (!isWide) {
        const actionCell = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.textContent = "\u270F\uFE0F";
        editBtn.className = "tf-edit-btn";
        editBtn.title = t("menu.editWork");
        editBtn.onclick = () => {
          if (e.date) {
            this.showEditEntriesModal(e.date);
          }
        };
        actionCell.appendChild(editBtn);
        row.appendChild(actionCell);
      }
      tbody.appendChild(row);
    });
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }
  renderNarrowListView(container, years) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear().toString();
    Object.keys(years).sort().reverse().forEach((year, index) => {
      const yearSection = document.createElement("details");
      yearSection.className = "tf-history-year-section";
      yearSection.open = year === currentYear || index === 0 && !years[currentYear];
      const summary = document.createElement("summary");
      summary.className = "tf-year-summary";
      const arrow = document.createElement("span");
      arrow.className = "tf-mr-8";
      arrow.textContent = yearSection.open ? "\u25BC" : "\u25B6";
      summary.appendChild(arrow);
      summary.appendChild(document.createTextNode(year.toString()));
      yearSection.appendChild(summary);
      yearSection.addEventListener("toggle", () => {
        arrow.textContent = yearSection.open ? "\u25BC" : "\u25B6";
      });
      const yearDiv = document.createElement("div");
      yearDiv.className = "tf-year-content";
      Object.keys(years[year]).sort().reverse().forEach((month) => {
        const monthEntries = years[year][month];
        const monthHeader = document.createElement("h5");
        monthHeader.textContent = getMonthName(new Date(parseInt(year), parseInt(month) - 1, 1));
        monthHeader.className = "tf-month-header";
        yearDiv.appendChild(monthHeader);
        const table = document.createElement("table");
        table.className = "tf-history-table-narrow";
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        [t("ui.date"), t("ui.type"), t("ui.hours"), t("ui.flextime"), ""].forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        const rawEntries = this.timerManager.data.entries;
        const flatRawEntries = [];
        rawEntries.forEach((entry) => {
          if (entry.collapsed && Array.isArray(entry.subEntries)) {
            entry.subEntries.forEach((sub) => {
              if (sub.startTime) flatRawEntries.push(sub);
            });
          } else if (entry.startTime) {
            flatRawEntries.push(entry);
          }
        });
        monthEntries.forEach((e) => {
          const row = document.createElement("tr");
          if (e.isActive) {
            row.className = "tf-history-row-active";
          }
          const matchingRaw = flatRawEntries.find(
            (item) => item.name.toLowerCase() === e.name.toLowerCase() && item.startTime === e.startTime
          );
          const dateCell = document.createElement("td");
          const dateStr = e.date ? Utils.toLocalDateStr(e.date) : "";
          const holidayInfo = dateStr ? this.data.getHolidayInfo(dateStr) : null;
          const entryBehavior = this.settings.specialDayBehaviors.find(
            (b) => b.id === e.name.toLowerCase()
          );
          const isWorkEntry = (entryBehavior == null ? void 0 : entryBehavior.isWorkType) || ["jobb", "kurs", "studie"].includes(e.name.toLowerCase());
          const hasConflict = holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type) && isWorkEntry;
          if (e.isActive) {
            const activeIcon = document.createElement("span");
            activeIcon.textContent = "\u23F1\uFE0F ";
            activeIcon.title = t("ui.activeTimer");
            activeIcon.className = "tf-cursor-help";
            dateCell.appendChild(activeIcon);
          } else if (hasConflict && holidayInfo) {
            const flagIcon = document.createElement("span");
            flagIcon.textContent = "\u26A0\uFE0F ";
            flagIcon.title = t("info.workRegisteredOnSpecialDay").replace("{dayType}", translateSpecialDayName(holidayInfo.type));
            flagIcon.className = "tf-cursor-help";
            dateCell.appendChild(flagIcon);
          }
          dateCell.appendChild(document.createTextNode(dateStr));
          row.appendChild(dateCell);
          const typeCell = document.createElement("td");
          const entryNameLower = e.name.toLowerCase();
          typeCell.textContent = translateSpecialDayName(entryNameLower, e.name);
          row.appendChild(typeCell);
          const hoursCell = document.createElement("td");
          const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
          hoursCell.textContent = e.isActive ? `${hoursText}...` : hoursText;
          row.appendChild(hoursCell);
          const flextimeCell = document.createElement("td");
          flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
          row.appendChild(flextimeCell);
          const actionCell = document.createElement("td");
          const editBtn = document.createElement("button");
          editBtn.textContent = "\u270F\uFE0F";
          editBtn.className = "tf-edit-btn";
          editBtn.title = t("menu.editWork");
          editBtn.onclick = () => {
            if (e.date) {
              this.showEditEntriesModal(e.date);
            }
          };
          actionCell.appendChild(editBtn);
          row.appendChild(actionCell);
          tbody.appendChild(row);
          if (matchingRaw == null ? void 0 : matchingRaw.comment) {
            const commentRow = document.createElement("tr");
            const commentCell = document.createElement("td");
            commentCell.colSpan = 5;
            commentCell.className = "tf-comment-subtitle";
            commentCell.textContent = `\u{1F4AC} ${matchingRaw.comment}`;
            commentRow.appendChild(commentCell);
            tbody.appendChild(commentRow);
          }
        });
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      yearSection.appendChild(yearDiv);
      container.appendChild(yearSection);
    });
  }
  renderWideListView(container, years) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear().toString();
    Object.keys(years).sort().reverse().forEach((year, index) => {
      const yearSection = document.createElement("details");
      yearSection.className = "tf-history-year-section";
      yearSection.open = year === currentYear || index === 0 && !years[currentYear];
      const summary = document.createElement("summary");
      summary.className = "tf-year-summary";
      const arrow = document.createElement("span");
      arrow.className = "tf-mr-8";
      arrow.textContent = yearSection.open ? "\u25BC" : "\u25B6";
      summary.appendChild(arrow);
      summary.appendChild(document.createTextNode(year.toString()));
      yearSection.appendChild(summary);
      yearSection.addEventListener("toggle", () => {
        arrow.textContent = yearSection.open ? "\u25BC" : "\u25B6";
      });
      const yearDiv = document.createElement("div");
      yearDiv.className = "tf-year-content";
      Object.keys(years[year]).sort().reverse().forEach((month) => {
        const monthEntries = years[year][month];
        const monthHeader = document.createElement("h5");
        monthHeader.textContent = getMonthName(new Date(parseInt(year), parseInt(month) - 1, 1));
        monthHeader.className = "tf-month-header";
        yearDiv.appendChild(monthHeader);
        const table = document.createElement("table");
        table.className = "tf-history-table-wide";
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const headers = this.inlineEditMode ? [t("ui.date"), t("ui.type"), t("ui.comment"), t("ui.start"), t("ui.end"), t("ui.hours"), t("ui.flextime"), ""] : [t("ui.date"), t("ui.type"), t("ui.comment"), t("ui.start"), t("ui.end"), t("ui.hours"), t("ui.flextime")];
        headers.forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        const entriesByDate = {};
        monthEntries.forEach((e) => {
          const dateStr = e.date ? Utils.toLocalDateStr(e.date) : "";
          if (dateStr) {
            if (!entriesByDate[dateStr]) entriesByDate[dateStr] = [];
            entriesByDate[dateStr].push(e);
          }
        });
        const rawEntries = this.timerManager.data.entries;
        const flatRawEntries = [];
        rawEntries.forEach((entry) => {
          if (entry.collapsed && Array.isArray(entry.subEntries)) {
            entry.subEntries.forEach((sub, idx) => {
              if (sub.startTime) {
                flatRawEntries.push({ entry: sub, parent: entry, subIndex: idx });
              }
            });
          } else if (entry.startTime) {
            flatRawEntries.push({ entry });
          }
        });
        Object.keys(entriesByDate).sort().reverse().forEach((dateStr) => {
          const dayEntries = entriesByDate[dateStr];
          const rawDayEntries = flatRawEntries.filter((item) => {
            const entryDate = new Date(item.entry.startTime);
            return Utils.toLocalDateStr(entryDate) === dateStr;
          });
          const usedRawEntries = /* @__PURE__ */ new Set();
          dayEntries.forEach((e, idx) => {
            const row = document.createElement("tr");
            if (e.isActive) {
              row.className = "tf-history-row-active";
            }
            const matchingItem = rawDayEntries.find(
              (item) => !usedRawEntries.has(item.entry) && item.entry.name.toLowerCase() === e.name.toLowerCase() && item.entry.startTime === e.startTime
            ) || rawDayEntries.find(
              (item) => !usedRawEntries.has(item.entry) && item.entry.name.toLowerCase() === e.name.toLowerCase()
            );
            const matchingRaw = matchingItem == null ? void 0 : matchingItem.entry;
            if (matchingRaw) usedRawEntries.add(matchingRaw);
            const dateCell = document.createElement("td");
            const holidayInfo = this.data.getHolidayInfo(dateStr);
            const entryBehavior = this.settings.specialDayBehaviors.find(
              (b) => b.id === e.name.toLowerCase()
            );
            const isWorkEntry = (entryBehavior == null ? void 0 : entryBehavior.isWorkType) || ["jobb", "kurs", "studie"].includes(e.name.toLowerCase());
            const hasSpecialDayConflict = holidayInfo && ["ferie", "helligdag", "egenmelding", "sykemelding", "velferdspermisjon"].includes(holidayInfo.type) && isWorkEntry;
            let hasTimeOverlap = false;
            let overlapDetails = "";
            if ((matchingRaw == null ? void 0 : matchingRaw.startTime) && (matchingRaw == null ? void 0 : matchingRaw.endTime)) {
              const thisStart = new Date(matchingRaw.startTime).getTime();
              const thisEnd = new Date(matchingRaw.endTime).getTime();
              for (const otherItem of rawDayEntries) {
                if (otherItem.entry === matchingRaw) continue;
                if (!otherItem.entry.startTime || !otherItem.entry.endTime) continue;
                const otherStart = new Date(otherItem.entry.startTime).getTime();
                const otherEnd = new Date(otherItem.entry.endTime).getTime();
                if (thisStart < otherEnd && thisEnd > otherStart) {
                  hasTimeOverlap = true;
                  const otherStartTime = new Date(otherItem.entry.startTime);
                  const otherEndTime = new Date(otherItem.entry.endTime);
                  overlapDetails = `${otherItem.entry.name} (${otherStartTime.getHours().toString().padStart(2, "0")}:${otherStartTime.getMinutes().toString().padStart(2, "0")}-${otherEndTime.getHours().toString().padStart(2, "0")}:${otherEndTime.getMinutes().toString().padStart(2, "0")})`;
                  break;
                }
              }
            }
            if (e.isActive) {
              const activeIcon = document.createElement("span");
              activeIcon.textContent = "\u23F1\uFE0F ";
              activeIcon.title = t("ui.activeTimer");
              activeIcon.className = "tf-cursor-help";
              dateCell.appendChild(activeIcon);
            } else if (hasTimeOverlap) {
              const overlapIcon = document.createElement("span");
              overlapIcon.textContent = "\u{1F534} ";
              overlapIcon.title = `Overlapper med: ${overlapDetails}`;
              overlapIcon.className = "tf-cursor-help";
              dateCell.appendChild(overlapIcon);
            } else if (hasSpecialDayConflict && holidayInfo) {
              const flagIcon = document.createElement("span");
              flagIcon.textContent = "\u26A0\uFE0F ";
              flagIcon.title = t("info.workRegisteredOnSpecialDay").replace("{dayType}", translateSpecialDayName(holidayInfo.type));
              flagIcon.className = "tf-cursor-help";
              dateCell.appendChild(flagIcon);
            }
            dateCell.appendChild(document.createTextNode(dateStr));
            row.appendChild(dateCell);
            const typeCell = document.createElement("td");
            if (this.inlineEditMode && matchingRaw) {
              const select = document.createElement("select");
              this.settings.specialDayBehaviors.forEach((behavior) => {
                const option = document.createElement("option");
                option.value = behavior.id;
                option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
                if (behavior.id === e.name.toLowerCase()) {
                  option.selected = true;
                }
                select.appendChild(option);
              });
              select.onchange = async () => {
                matchingRaw.name = select.value;
                await this.saveWithErrorHandling();
                this.softRefreshHistory();
              };
              typeCell.appendChild(select);
            } else {
              const entryNameLower = e.name.toLowerCase();
              typeCell.textContent = translateSpecialDayName(entryNameLower, e.name);
            }
            row.appendChild(typeCell);
            const commentCell = document.createElement("td");
            if (this.inlineEditMode && matchingRaw) {
              const textarea = document.createElement("textarea");
              textarea.value = matchingRaw.comment || "";
              textarea.placeholder = t("ui.optional");
              textarea.rows = 1;
              textarea.className = "tf-comment-input";
              textarea.maxLength = 500;
              textarea.onfocus = () => {
                textarea.rows = 2;
              };
              textarea.onblur = async () => {
                textarea.rows = 1;
                const newComment = textarea.value.trim();
                if (newComment !== (matchingRaw.comment || "")) {
                  matchingRaw.comment = newComment || void 0;
                  await this.saveWithErrorHandling();
                }
              };
              commentCell.appendChild(textarea);
            } else {
              const comment = (matchingRaw == null ? void 0 : matchingRaw.comment) || "";
              if (comment) {
                const span = document.createElement("span");
                span.textContent = comment.length > 30 ? comment.substring(0, 27) + "..." : comment;
                span.title = comment;
                span.className = "tf-comment-display";
                commentCell.appendChild(span);
              } else {
                commentCell.textContent = "-";
              }
            }
            row.appendChild(commentCell);
            const startCell = document.createElement("td");
            if (matchingRaw == null ? void 0 : matchingRaw.startTime) {
              const startDate = new Date(matchingRaw.startTime);
              const startDateStr = Utils.toLocalDateStr(startDate);
              const startTimeStr = `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}`;
              const endDateForCheck = matchingRaw.endTime ? new Date(matchingRaw.endTime) : null;
              const isMultiDay = endDateForCheck && Utils.toLocalDateStr(startDate) !== Utils.toLocalDateStr(endDateForCheck);
              if (this.inlineEditMode) {
                const container2 = document.createElement("div");
                container2.className = "tf-inline-edit-container";
                if (isMultiDay) {
                  const dateInput = document.createElement("input");
                  dateInput.type = "date";
                  dateInput.value = startDateStr;
                  dateInput.className = "tf-text-12px";
                  dateInput.onchange = async () => {
                    const newStart = /* @__PURE__ */ new Date(`${dateInput.value}T${timeInput.value}:00`);
                    matchingRaw.startTime = Utils.toLocalISOString(newStart);
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  };
                  container2.appendChild(dateInput);
                }
                const timeInput = this.createTimeInput(startTimeStr, async (newValue) => {
                  const parsed = this.parseTimeInput(newValue);
                  if (!parsed) return;
                  const newStart = new Date(matchingRaw.startTime);
                  newStart.setHours(parsed.hours, parsed.minutes, 0, 0);
                  matchingRaw.startTime = Utils.toLocalISOString(newStart);
                  await this.saveWithErrorHandling();
                  this.softRefreshHistory();
                });
                container2.appendChild(timeInput);
                startCell.appendChild(container2);
              } else {
                startCell.textContent = isMultiDay ? `${startDateStr} ${startTimeStr}` : startTimeStr;
              }
            } else {
              startCell.textContent = "-";
            }
            row.appendChild(startCell);
            const endCell = document.createElement("td");
            const endDateParsed = (matchingRaw == null ? void 0 : matchingRaw.endTime) ? new Date(matchingRaw.endTime) : null;
            const hasValidEndTime = endDateParsed && !isNaN(endDateParsed.getTime());
            if (hasValidEndTime && matchingRaw) {
              const endDate = endDateParsed;
              const endDateStr = Utils.toLocalDateStr(endDate);
              const endTimeStr = `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}`;
              const startDateForCheck = matchingRaw.startTime ? new Date(matchingRaw.startTime) : null;
              const isMultiDay = startDateForCheck && Utils.toLocalDateStr(startDateForCheck) !== Utils.toLocalDateStr(endDate);
              if (this.inlineEditMode) {
                const container2 = document.createElement("div");
                container2.className = "tf-time-input-container";
                if (isMultiDay) {
                  const dateInput = document.createElement("input");
                  dateInput.type = "date";
                  dateInput.value = endDateStr;
                  dateInput.className = "tf-date-input-sm";
                  dateInput.onchange = async () => {
                    const newEnd = /* @__PURE__ */ new Date(`${dateInput.value}T${timeInput.value}:00`);
                    matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  };
                  container2.appendChild(dateInput);
                }
                const timeInput = this.createTimeInput(endTimeStr, async (newValue) => {
                  const parsed = this.parseTimeInput(newValue);
                  if (!parsed) return;
                  const newEnd = new Date(matchingRaw.endTime);
                  newEnd.setHours(parsed.hours, parsed.minutes, 0, 0);
                  matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                  await this.saveWithErrorHandling();
                  this.softRefreshHistory();
                });
                container2.appendChild(timeInput);
                endCell.appendChild(container2);
              } else {
                endCell.textContent = isMultiDay ? `${endDateStr} ${endTimeStr}` : endTimeStr;
              }
            } else if (this.inlineEditMode && matchingRaw) {
              const startDate = matchingRaw.startTime ? new Date(matchingRaw.startTime) : /* @__PURE__ */ new Date();
              const container2 = document.createElement("div");
              container2.className = "tf-time-input-container";
              const timeInput = this.createTimeInput("", async (newValue) => {
                const parsed = this.parseTimeInput(newValue);
                if (!parsed) return;
                const newEnd = new Date(startDate);
                newEnd.setHours(parsed.hours, parsed.minutes, 0, 0);
                if (newEnd <= startDate) {
                  newEnd.setDate(newEnd.getDate() + 1);
                  new import_obsidian5.Notice(t("validation.endTimeNextDay"));
                }
                matchingRaw.endTime = Utils.toLocalISOString(newEnd);
                await this.saveWithErrorHandling();
                this.softRefreshHistory();
              });
              container2.appendChild(timeInput);
              endCell.appendChild(container2);
            } else {
              endCell.textContent = matchingRaw ? t("ui.ongoing") : "-";
            }
            row.appendChild(endCell);
            const hoursCell = document.createElement("td");
            const hoursText = Utils.formatHoursToHM(e.duration || 0, this.settings.hourUnit);
            hoursCell.textContent = e.isActive ? `${hoursText}...` : hoursText;
            row.appendChild(hoursCell);
            const flextimeCell = document.createElement("td");
            flextimeCell.textContent = Utils.formatHoursToHM(e.flextime || 0, this.settings.hourUnit);
            row.appendChild(flextimeCell);
            if (this.inlineEditMode) {
              const actionCell = document.createElement("td");
              if (matchingItem) {
                const deleteBtn = document.createElement("button");
                deleteBtn.className = "tf-history-delete-btn";
                deleteBtn.textContent = "\u{1F5D1}\uFE0F";
                deleteBtn.title = t("menu.deleteEntry");
                deleteBtn.onclick = () => {
                  this.showConfirmDialog(`${t("confirm.deleteEntryFor")} ${dateStr}?`, async () => {
                    if (matchingItem.parent && matchingItem.subIndex !== void 0) {
                      if (matchingItem.parent.subEntries) {
                        matchingItem.parent.subEntries.splice(matchingItem.subIndex, 1);
                        if (matchingItem.parent.subEntries.length === 0) {
                          const parentIndex = this.timerManager.data.entries.indexOf(matchingItem.parent);
                          if (parentIndex > -1) {
                            this.timerManager.data.entries.splice(parentIndex, 1);
                          }
                        }
                      }
                    } else {
                      const entryIndex = this.timerManager.data.entries.indexOf(matchingRaw);
                      if (entryIndex > -1) {
                        this.timerManager.data.entries.splice(entryIndex, 1);
                      }
                    }
                    await this.saveWithErrorHandling();
                    this.softRefreshHistory();
                  });
                };
                actionCell.appendChild(deleteBtn);
              }
              row.appendChild(actionCell);
            }
            tbody.appendChild(row);
          });
        });
        if (this.inlineEditMode) {
          const addRow = document.createElement("tr");
          addRow.className = "tf-history-add-row";
          const addCell = document.createElement("td");
          addCell.colSpan = 7;
          addCell.textContent = t("ui.addNewEntry");
          addCell.onclick = () => {
            const lastEntry = monthEntries[0];
            const targetDate = (lastEntry == null ? void 0 : lastEntry.date) || /* @__PURE__ */ new Date();
            this.showAddEntryModal(targetDate);
          };
          addRow.appendChild(addCell);
          tbody.appendChild(addRow);
        }
        table.appendChild(tbody);
        yearDiv.appendChild(table);
      });
      yearSection.appendChild(yearDiv);
      container.appendChild(yearSection);
    });
  }
  showAddEntryModal(targetDate) {
    const dateStr = Utils.toLocalDateStr(targetDate);
    this.isModalOpen = true;
    const modal = document.createElement("div");
    modal.className = "modal-container mod-dim tf-modal-z1000";
    const modalBg = document.createElement("div");
    modalBg.className = "modal-bg";
    modalBg.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    modal.appendChild(modalBg);
    const modalContent = document.createElement("div");
    modalContent.className = "modal tf-modal-content-400";
    modalContent.addEventListener("keydown", (e) => e.stopPropagation());
    modalContent.addEventListener("keyup", (e) => e.stopPropagation());
    modalContent.addEventListener("keypress", (e) => e.stopPropagation());
    modalContent.addEventListener("beforeinput", (e) => e.stopPropagation());
    modalContent.addEventListener("input", (e) => e.stopPropagation());
    const title = document.createElement("div");
    title.className = "modal-title";
    title.textContent = `${t("modals.addEntryTitle")} ${dateStr}`;
    modalContent.appendChild(title);
    const content = document.createElement("div");
    content.className = "modal-content tf-p-20";
    const typeLabel = document.createElement("div");
    typeLabel.textContent = t("ui.type") + ":";
    typeLabel.className = "tf-form-label";
    content.appendChild(typeLabel);
    const typeSelect = document.createElement("select");
    typeSelect.className = "tf-form-input-mb";
    this.settings.specialDayBehaviors.forEach((behavior) => {
      const option = document.createElement("option");
      option.value = behavior.id;
      option.textContent = `${behavior.icon} ${translateSpecialDayName(behavior.id, behavior.label)}`;
      typeSelect.appendChild(option);
    });
    content.appendChild(typeSelect);
    const startLabel = document.createElement("div");
    startLabel.textContent = `${t("modals.startTime")}:`;
    startLabel.className = "tf-form-label";
    content.appendChild(startLabel);
    const startInput = this.createTimeInput("08:00", () => {
    });
    startInput.className = "tf-form-input-mb";
    content.appendChild(startInput);
    const endLabel = document.createElement("div");
    endLabel.textContent = `${t("modals.endTime")}:`;
    endLabel.className = "tf-form-label";
    content.appendChild(endLabel);
    const endInput = this.createTimeInput("16:00", () => {
    });
    endInput.className = "tf-form-input-mb-lg";
    content.appendChild(endInput);
    const durationContainer = document.createElement("div");
    durationContainer.className = "tf-duration-container tf-hidden";
    const durationLabel = document.createElement("div");
    durationLabel.textContent = t("ui.duration") + ":";
    durationLabel.className = "tf-form-label";
    durationContainer.appendChild(durationLabel);
    const durationInput = document.createElement("input");
    durationInput.type = "number";
    durationInput.step = "0.5";
    durationInput.min = "0.5";
    durationInput.max = "24";
    durationInput.value = "3.5";
    durationInput.className = "tf-form-input";
    durationContainer.appendChild(durationInput);
    const durationHint = document.createElement("div");
    durationHint.className = "tf-duration-hint";
    durationHint.textContent = t("modals.durationHint") || "Antall timer (f.eks. 3.5 for resten av dagen etter sykdom)";
    durationContainer.appendChild(durationHint);
    content.appendChild(durationContainer);
    const isReduceGoalType = (typeId) => {
      const behavior = this.settings.specialDayBehaviors.find((b) => b.id === typeId);
      return (behavior == null ? void 0 : behavior.flextimeEffect) === "reduce_goal";
    };
    const updateInputVisibility = () => {
      const showDuration = isReduceGoalType(typeSelect.value);
      if (showDuration) {
        startLabel.addClass("tf-hidden");
        startInput.addClass("tf-hidden");
        endLabel.addClass("tf-hidden");
        endInput.addClass("tf-hidden");
        durationContainer.removeClass("tf-hidden");
      } else {
        startLabel.removeClass("tf-hidden");
        startInput.removeClass("tf-hidden");
        endLabel.removeClass("tf-hidden");
        endInput.removeClass("tf-hidden");
        durationContainer.addClass("tf-hidden");
      }
    };
    typeSelect.onchange = updateInputVisibility;
    updateInputVisibility();
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "tf-btn-container";
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => {
      this.isModalOpen = false;
      modal.remove();
    };
    buttonContainer.appendChild(cancelBtn);
    const saveBtn = document.createElement("button");
    saveBtn.className = "mod-cta";
    saveBtn.textContent = t("buttons.save");
    saveBtn.onclick = async () => {
      var _a, _b;
      let startDate;
      let endDate;
      if (isReduceGoalType(typeSelect.value)) {
        const duration2 = parseFloat(durationInput.value);
        if (isNaN(duration2) || duration2 <= 0) {
          new import_obsidian5.Notice(t("validation.invalidDuration") || "Ugyldig varighet");
          return;
        }
        startDate = new Date(targetDate);
        startDate.setHours(12, 0, 0, 0);
        endDate = new Date(startDate.getTime() + duration2 * 60 * 60 * 1e3);
      } else {
        const parsedStart = this.parseTimeInput(startInput.value);
        const parsedEnd = this.parseTimeInput(endInput.value);
        if (!parsedStart || !parsedEnd) {
          new import_obsidian5.Notice(t("validation.invalidTime"));
          return;
        }
        startDate = new Date(targetDate);
        startDate.setHours(parsedStart.hours, parsedStart.minutes, 0, 0);
        endDate = new Date(targetDate);
        endDate.setHours(parsedEnd.hours, parsedEnd.minutes, 0, 0);
        if (endDate <= startDate) {
          new import_obsidian5.Notice(t("validation.endAfterStart"));
          return;
        }
      }
      this.timerManager.data.entries.push({
        name: typeSelect.value,
        startTime: Utils.toLocalISOString(startDate),
        endTime: Utils.toLocalISOString(endDate),
        subEntries: null
      });
      await this.saveWithErrorHandling();
      this.isModalOpen = false;
      modal.remove();
      const duration = (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60);
      new import_obsidian5.Notice(`\u2705 ${t("notifications.addedHours").replace("{duration}", duration.toFixed(1)).replace("{date}", dateStr)}`);
      (_b = (_a = this.plugin.timerManager).onTimerChange) == null ? void 0 : _b.call(_a);
    };
    buttonContainer.appendChild(saveBtn);
    content.appendChild(buttonContainer);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  }
  renderWeeklyView(container, years) {
    container.empty();
    const div = container.createDiv();
    div.className = "tf-heatmap-no-data";
    div.textContent = t("ui.weeklyViewComingSoon");
  }
  renderHeatmapView(container, years) {
    const heatmap = document.createElement("div");
    heatmap.className = "tf-heatmap";
    heatmap.style.gridTemplateColumns = `repeat(${this.settings.heatmapColumns}, 1fr)`;
    const today = /* @__PURE__ */ new Date();
    const daysToShow = this.settings.heatmapColumns * 8;
    for (let i = daysToShow; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      const dateKey = Utils.toLocalDateStr(date);
      const cell = document.createElement("div");
      cell.className = "tf-heatmap-cell";
      cell.title = dateKey;
      const dayEntries = this.data.daily[dateKey];
      const holidayInfo = this.data.getHolidayInfo(dateKey);
      if (this.settings.heatmapShowSpecialDayColors) {
        let specialDayBehavior = void 0;
        if (holidayInfo) {
          specialDayBehavior = this.settings.specialDayBehaviors.find((b) => b.id === holidayInfo.type);
        }
        if (!specialDayBehavior && dayEntries) {
          for (const entry of dayEntries) {
            const entryName = entry.name.toLowerCase();
            if (entryName === "jobb") continue;
            const entryBehavior = this.settings.specialDayBehaviors.find(
              (b) => b.id === entryName
            );
            if (entryBehavior) {
              specialDayBehavior = entryBehavior;
              break;
            }
          }
        }
        if (specialDayBehavior) {
          cell.setCssProps({ "--tf-bg": specialDayBehavior.color, "--tf-color": specialDayBehavior.textColor || "#000000" });
          cell.addClass("tf-dynamic-bg-color");
          cell.title = `${dateKey} - ${specialDayBehavior.icon} ${specialDayBehavior.label}`;
        } else if (dayEntries) {
          if (!this.settings.enableGoalTracking) {
            const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
            cell.setCssProps({ "--tf-bg": (workType == null ? void 0 : workType.simpleColor) || "#90caf9", "--tf-color": (workType == null ? void 0 : workType.simpleTextColor) || "#000000" });
            cell.addClass("tf-dynamic-bg-color");
          } else {
            const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
            cell.setCssProps({ "--tf-bg": this.flextimeColor(dayFlextime), "--tf-color": this.flextimeTextColor(dayFlextime) });
            cell.addClass("tf-dynamic-bg-color");
          }
        } else {
          cell.setCssProps({ "--tf-bg": "var(--background-modifier-border)" });
          cell.addClass("tf-dynamic-bg");
        }
      } else if (dayEntries) {
        if (!this.settings.enableGoalTracking) {
          const workType = this.settings.specialDayBehaviors.find((b) => b.isWorkType);
          cell.setCssProps({ "--tf-bg": (workType == null ? void 0 : workType.simpleColor) || "#90caf9", "--tf-color": (workType == null ? void 0 : workType.simpleTextColor) || "#000000" });
          cell.addClass("tf-dynamic-bg-color");
        } else {
          const dayFlextime = dayEntries.reduce((sum, e) => sum + (e.flextime || 0), 0);
          cell.setCssProps({ "--tf-bg": this.flextimeColor(dayFlextime), "--tf-color": this.flextimeTextColor(dayFlextime) });
          cell.addClass("tf-dynamic-bg-color");
        }
      } else {
        cell.setCssProps({ "--tf-bg": "var(--background-modifier-border)" });
        cell.addClass("tf-dynamic-bg");
      }
      heatmap.appendChild(cell);
    }
    container.appendChild(heatmap);
  }
  exportCurrentView() {
    const rows = [["Date", "Type", "Hours", "Flextime"]];
    Object.keys(this.data.daily).sort().forEach((dateKey) => {
      this.data.daily[dateKey].forEach((entry) => {
        rows.push([
          dateKey,
          entry.name,
          (entry.duration || 0).toFixed(2),
          (entry.flextime || 0).toFixed(2)
        ]);
      });
    });
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `timeflow-export-${Utils.toLocalDateStr(/* @__PURE__ */ new Date())}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian5.Notice(t("notifications.exported"));
  }
  startUpdates() {
    const clockMs = (this.settings.clockInterval || 1) * 1e3;
    const clockInterval = window.setInterval(() => {
      this.updateClock();
    }, clockMs);
    this.intervals.push(clockInterval);
    const updateMs = (this.settings.updateInterval || 30) * 1e3;
    const dataInterval = window.setInterval(() => {
      this.updateAll();
    }, updateMs);
    this.intervals.push(dataInterval);
  }
  updateAll() {
    if (this.isModalOpen) return;
    this.data.rawEntries = this.timerManager.convertToTimeEntries();
    this.data.processEntries();
    this.updateBadge();
    this.updateTimerBadge();
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
    this.updateMonthCard();
    const activeSection = this.container.querySelector(".tf-active-entries-section");
    if (activeSection && this.data.activeEntries.length > 0) {
      const tbody = activeSection.querySelector("tbody");
      if (tbody) {
        const rows = tbody.querySelectorAll("tr");
        const now = /* @__PURE__ */ new Date();
        rows.forEach((row, index) => {
          if (index < this.data.activeEntries.length) {
            const entry = this.data.activeEntries[index];
            const start = Utils.parseDate(entry.startTime);
            let duration = start ? Utils.hoursDiff(start, now) : 0;
            if (entry.name.toLowerCase() === "jobb" && this.settings.lunchBreakMinutes > 0) {
              duration = Math.max(0, duration - this.settings.lunchBreakMinutes / 60);
            }
            const cells = row.querySelectorAll("td");
            const isWide = cells.length >= 5;
            const hoursCell = isWide ? cells[3] : cells[2];
            if (hoursCell) {
              const hoursText = Utils.formatHoursToHM(duration, this.settings.hourUnit);
              hoursCell.textContent = `${hoursText}...`;
            }
            if (isWide && cells[4]) {
              const dateStr = Utils.toLocalDateStr(start || /* @__PURE__ */ new Date());
              const dayGoal = this.data.getDailyGoal(dateStr);
              let completedHoursToday = 0;
              const todayEntries = this.data.daily[dateStr] || [];
              todayEntries.forEach((e) => {
                if (!e.isActive) {
                  const behavior = this.data.getSpecialDayBehavior(e.name);
                  if (!behavior || behavior.isWorkType || behavior.flextimeEffect === "accumulate") {
                    completedHoursToday += e.duration || 0;
                  }
                }
              });
              const totalWorkToday = completedHoursToday + duration;
              const flextime = totalWorkToday - dayGoal;
              cells[4].textContent = Utils.formatHoursToHM(flextime, this.settings.hourUnit);
            }
          }
        });
      }
    } else if (activeSection && this.data.activeEntries.length === 0) {
      activeSection.remove();
    }
    const historyContainer = this.container.querySelector(".tf-history-content");
    if (historyContainer) {
      this.updateEditToggleVisibility(historyContainer);
    }
  }
  /**
   * Soft refresh for inline editing - updates data and history view
   * without rebuilding the entire dashboard. Preserves edit mode state.
   */
  softRefreshHistory() {
    this.data.rawEntries = this.timerManager.convertToTimeEntries();
    this.data.processEntries();
    const activeSection = this.container.querySelector(".tf-active-entries-section");
    if (activeSection && this.data.activeEntries.length > 0) {
      const parent = activeSection.parentElement;
      if (parent) {
        const newSection = this.createActiveEntriesSection(this.data.activeEntries, parent);
        activeSection.replaceWith(newSection);
      }
    } else if (activeSection && this.data.activeEntries.length === 0) {
      activeSection.remove();
    }
    const historyContainer = this.container.querySelector(".tf-history-content");
    if (historyContainer) {
      this.refreshHistoryView(historyContainer);
    }
    this.updateDayCard();
    this.updateWeekCard();
    this.updateStatsCard();
  }
  showDeleteConfirmation(entry, dateObj, onConfirm) {
    const overlay = document.createElement("div");
    overlay.className = "tf-confirm-overlay";
    const dialog = document.createElement("div");
    dialog.className = "tf-confirm-dialog";
    const title = document.createElement("div");
    title.className = "tf-confirm-title";
    title.textContent = "\u{1F5D1}\uFE0F " + t("modals.deleteEntryTitle");
    dialog.appendChild(title);
    const message = document.createElement("div");
    message.className = "tf-confirm-message";
    message.textContent = t("confirm.deleteEntry");
    dialog.appendChild(message);
    const details = document.createElement("div");
    details.className = "tf-confirm-details";
    const startDate = entry.startTime ? new Date(entry.startTime) : /* @__PURE__ */ new Date();
    const endDate = entry.endTime ? new Date(entry.endTime) : null;
    const duration = endDate ? ((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)).toFixed(2) : t("ui.ongoing");
    const dateRow = details.createDiv();
    dateRow.createEl("strong", { text: t("ui.date") + ":" });
    dateRow.appendText(" " + Utils.toLocalDateStr(dateObj));
    const typeRow = details.createDiv();
    typeRow.createEl("strong", { text: t("ui.type") + ":" });
    typeRow.appendText(" " + translateSpecialDayName(entry.name.toLowerCase(), entry.name));
    const startRow = details.createDiv();
    startRow.createEl("strong", { text: t("ui.start") + ":" });
    startRow.appendText(" " + formatTime(startDate));
    if (endDate) {
      const endRow = details.createDiv();
      endRow.createEl("strong", { text: t("ui.end") + ":" });
      endRow.appendText(" " + formatTime(endDate));
    }
    const durationRow = details.createDiv();
    durationRow.createEl("strong", { text: t("ui.duration") + ":" });
    const durationDisplay = endDate ? `${duration} ${t("ui.hours").toLowerCase()}` : duration;
    durationRow.appendText(" " + durationDisplay);
    dialog.appendChild(details);
    const buttons = document.createElement("div");
    buttons.className = "tf-confirm-buttons";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "tf-confirm-cancel";
    cancelBtn.textContent = t("buttons.cancel");
    cancelBtn.onclick = () => overlay.remove();
    buttons.appendChild(cancelBtn);
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "tf-confirm-delete";
    deleteBtn.textContent = "Slett";
    deleteBtn.onclick = () => {
      overlay.remove();
      void onConfirm();
    };
    buttons.appendChild(deleteBtn);
    dialog.appendChild(buttons);
    overlay.appendChild(dialog);
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    };
    document.body.appendChild(overlay);
  }
  /**
   * Show export modal to select month
   */
  exportHistoryToCSV() {
    const availableMonths = [];
    Object.keys(this.data.daily).forEach((dateKey) => {
      const yearMonth = dateKey.substring(0, 7);
      if (!availableMonths.includes(yearMonth)) {
        availableMonths.push(yearMonth);
      }
    });
    if (availableMonths.length === 0) {
      new import_obsidian5.Notice(t("export.noData"));
      return;
    }
    availableMonths.sort().reverse();
    const now = /* @__PURE__ */ new Date();
    const currentYearMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    const defaultMonth = availableMonths.includes(currentYearMonth) ? currentYearMonth : availableMonths[0];
    const overlay = document.createElement("div");
    overlay.className = "modal-container mod-dim";
    const modal = document.createElement("div");
    modal.className = "modal tf-export-modal";
    modal.createEl("h3", { text: t("export.selectMonth"), cls: "tf-export-modal-title" });
    const selectContainer = modal.createDiv({ cls: "tf-export-select-container" });
    selectContainer.createEl("label", { text: t("export.month") + ":" });
    const select = selectContainer.createEl("select", { cls: "tf-export-select" });
    select.createEl("option", { text: t("export.allMonths"), value: "all" });
    availableMonths.forEach((yearMonth) => {
      const [year, month] = yearMonth.split("-").map(Number);
      const monthName = getMonthName(new Date(year, month - 1, 1));
      const option = select.createEl("option", { text: monthName, value: yearMonth });
      if (yearMonth === defaultMonth) option.selected = true;
    });
    const buttonDiv = modal.createDiv({ cls: "tf-export-buttons" });
    const cancelBtn = buttonDiv.createEl("button", { text: t("buttons.cancel") });
    cancelBtn.onclick = () => overlay.remove();
    const exportBtn = buttonDiv.createEl("button", { text: `\u{1F4E5} ${t("buttons.export")}`, cls: "mod-cta" });
    exportBtn.onclick = () => {
      const selectedMonth = select.value;
      overlay.remove();
      this.downloadMonthCSV(selectedMonth);
    };
    overlay.appendChild(modal);
    overlay.onclick = (e) => {
      if (e.target === overlay) overlay.remove();
    };
    document.body.appendChild(overlay);
  }
  /**
   * Download CSV for a specific month or all months
   */
  downloadMonthCSV(yearMonth) {
    const BOM = "\uFEFF";
    let csvContent = "";
    let filename;
    let noticeText;
    if (yearMonth === "all") {
      const availableMonths = [];
      Object.keys(this.data.daily).forEach((dateKey) => {
        const ym = dateKey.substring(0, 7);
        if (!availableMonths.includes(ym)) availableMonths.push(ym);
      });
      availableMonths.sort().reverse();
      if (availableMonths.length === 0) {
        new import_obsidian5.Notice(t("export.noData"));
        return;
      }
      availableMonths.forEach((ym, index) => {
        if (index > 0) csvContent += "\n\n";
        csvContent += this.generateMonthCSV(ym);
      });
      filename = `timeflow-${t("export.allMonths").toLowerCase().replace(/\s+/g, "-")}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
      noticeText = t("export.allMonths");
    } else {
      csvContent = this.generateMonthCSV(yearMonth);
      if (!csvContent) {
        new import_obsidian5.Notice(t("export.noData"));
        return;
      }
      const [year, month] = yearMonth.split("-").map(Number);
      filename = `timeflow-${yearMonth}.csv`;
      noticeText = getMonthName(new Date(year, month - 1, 1));
    }
    const blob = new Blob([BOM + csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
    new import_obsidian5.Notice(`\u2705 ${t("export.success")}: ${noticeText}`);
  }
  /**
   * Generate CSV content for a single month
   */
  generateMonthCSV(yearMonth) {
    const [year, month] = yearMonth.split("-").map(Number);
    const monthEntries = [];
    Object.keys(this.data.daily).forEach((dateKey) => {
      if (dateKey.startsWith(yearMonth)) {
        monthEntries.push(...this.data.daily[dateKey]);
      }
    });
    if (monthEntries.length === 0) return "";
    const rawEntries = this.timerManager.data.entries.filter((entry) => {
      if (!entry.startTime) return false;
      const date = new Date(entry.startTime);
      return date.getFullYear() === year && date.getMonth() === month - 1;
    });
    const monthName = getMonthName(new Date(year, month - 1, 1));
    const stats = this.data.getStatistics("month", year, month - 1);
    let csvContent = "";
    csvContent += `"${monthName}"

`;
    csvContent += `"${t("export.date")}","${t("export.type")}","${t("export.start")}","${t("export.end")}","${t("export.hours")}","${t("export.flextime")}","${t("export.comment")}"
`;
    const sortedEntries = [...monthEntries].sort((a, b) => {
      const dateA = a.startTime || "";
      const dateB = b.startTime || "";
      return dateA.localeCompare(dateB);
    });
    const usedRawEntries = /* @__PURE__ */ new Set();
    sortedEntries.forEach((entry) => {
      const startDate = entry.startTime ? new Date(entry.startTime) : null;
      const endDate = entry.endTime ? new Date(entry.endTime) : null;
      const dateStr = startDate ? Utils.toLocalDateStr(startDate) : "";
      const startTime = startDate ? `${startDate.getHours().toString().padStart(2, "0")}:${startDate.getMinutes().toString().padStart(2, "0")}` : "";
      const endTime = endDate ? `${endDate.getHours().toString().padStart(2, "0")}:${endDate.getMinutes().toString().padStart(2, "0")}` : "";
      const hours = entry.duration ? entry.duration.toFixed(2) : "0.00";
      const flextime = entry.flextime ? entry.flextime.toFixed(2) : "0.00";
      const matchingRaw = rawEntries.find(
        (raw) => !usedRawEntries.has(raw) && raw.name.toLowerCase() === entry.name.toLowerCase() && raw.startTime === entry.startTime
      ) || rawEntries.find(
        (raw) => !usedRawEntries.has(raw) && raw.name.toLowerCase() === entry.name.toLowerCase()
      );
      if (matchingRaw) usedRawEntries.add(matchingRaw);
      const comment = (matchingRaw == null ? void 0 : matchingRaw.comment) || "";
      const escapedComment = comment.replace(/"/g, '""');
      const typeName = translateSpecialDayName(entry.name.toLowerCase(), entry.name);
      csvContent += `"${dateStr}","${typeName}","${startTime}","${endTime}","${hours}","${flextime}","${escapedComment}"
`;
    });
    csvContent += "\n";
    csvContent += `"${t("export.monthlySummary")}"
`;
    csvContent += `"${t("export.totalHours")}","${stats.totalHours.toFixed(2)}"
`;
    csvContent += `"${t("export.totalFlextime")}","${stats.totalFlextime.toFixed(2)}"
`;
    csvContent += `"${t("export.workDays")}","${stats.workDays}"
`;
    csvContent += `"${t("export.avgDaily")}","${stats.avgDailyHours.toFixed(2)}"
`;
    csvContent += "\n";
    csvContent += `"${t("export.typeBreakdown")}"
`;
    csvContent += `"${t("export.typeHeader")}","${t("export.daysHeader")}","${t("export.hoursHeader")}"
`;
    const types = ["jobb", "kurs", "studie", "ferie", "avspasering", "egenmelding", "sykemelding", "velferdspermisjon"];
    types.forEach((type) => {
      const typeStat = stats[type];
      if (typeStat && typeof typeStat === "object" && "count" in typeStat) {
        if (typeStat.count > 0 || typeStat.hours > 0) {
          csvContent += `"${translateSpecialDayName(type)}","${typeStat.count}","${typeStat.hours.toFixed(2)}"
`;
        }
      }
    });
    return csvContent;
  }
  cleanup() {
    this.intervals.forEach((interval) => clearInterval(interval));
    this.intervals = [];
  }
  build() {
    this.container.appendChild(this.buildBadgeSection());
    const mainCardsWrapper = document.createElement("div");
    mainCardsWrapper.className = "tf-main-cards-wrapper";
    mainCardsWrapper.appendChild(this.createDayCard());
    mainCardsWrapper.appendChild(this.createWeekCard());
    mainCardsWrapper.appendChild(this.createMonthCard());
    mainCardsWrapper.appendChild(this.createStatsCard());
    this.container.appendChild(mainCardsWrapper);
    this.container.appendChild(this.buildInfoCard());
    this.container.appendChild(this.buildHistoryCard());
    this.container.appendChild(this.buildStatusBar());
    this.container.appendChild(this.buildViewToggle());
    return this.container;
  }
};

// src/view.ts
var VIEW_TYPE_TIMEFLOW = "timeflow-view";
var TimeFlowView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dataManager = null;
    this.uiBuilder = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TIMEFLOW;
  }
  getDisplayText() {
    return "Timeflow dashboard";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeflow-dashboard");
    await this.loadDashboard(container);
  }
  async onClose() {
    if (this.uiBuilder) {
      this.uiBuilder.cleanup();
    }
    return Promise.resolve();
  }
  async loadDashboard(container) {
    try {
      const allEntries = this.plugin.timerManager.convertToTimeEntries();
      if (allEntries.length === 0) {
        container.createDiv({
          text: "No timer data yet. Start a timer to begin tracking!",
          cls: "timeflow-warning"
        });
      }
      this.dataManager = new DataManager(allEntries, this.plugin.settings, this.app);
      const holidayStatus = await this.dataManager.loadHolidays();
      const converted = await this.plugin.timerManager.convertPastPlannedDays(
        this.dataManager.holidays,
        this.plugin.settings
      );
      if (converted > 0) {
        const updatedEntries = this.plugin.timerManager.convertToTimeEntries();
        this.dataManager = new DataManager(updatedEntries, this.plugin.settings, this.app);
        await this.dataManager.loadHolidays();
      }
      this.dataManager.processEntries();
      const validationResults = this.dataManager.validateData();
      const systemStatus = {
        holiday: holidayStatus,
        validation: validationResults,
        activeTimers: this.dataManager.activeEntries.length
      };
      this.uiBuilder = new UIBuilder(
        this.dataManager,
        systemStatus,
        this.plugin.settings,
        this.app,
        this.plugin.timerManager,
        this.plugin
      );
      this.plugin.timerManager.onTimerChange = () => {
        void this.refresh();
      };
      const dashboardEl = this.uiBuilder.build();
      container.empty();
      container.appendChild(dashboardEl);
      this.uiBuilder.startUpdates();
    } catch (error) {
      console.error("Error loading TimeFlow dashboard:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      container.createDiv({
        text: t("notifications.errorLoadingDashboard").replace("{error}", errorMessage),
        cls: "timeflow-error"
      });
    }
  }
  // Method to refresh the dashboard
  async refresh() {
    const container = this.containerEl.children[1];
    await this.loadDashboard(container);
  }
};

// src/timerManager.ts
var import_obsidian7 = require("obsidian");
var TimerManager = class {
  constructor(app, settings) {
    this.isSaving = false;
    this.lastSaveTime = 0;
    this.app = app;
    this.settings = settings;
    this.dataFile = settings.dataFilePath;
    this.data = { entries: [] };
  }
  /**
   * Check if we should reload data from file.
   * Returns false if we're currently saving or just saved (within 500ms)
   * to prevent race conditions with the file watcher.
   */
  shouldReloadFromFile() {
    if (this.isSaving) return false;
    if (Date.now() - this.lastSaveTime < 500) return false;
    return true;
  }
  async load() {
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dataFile);
        const parsed = this.parseTimekeepData(content);
        if (parsed) {
          this.data = parsed;
          const needsSave = this.normalizeEntryTimestamps();
          if (needsSave) {
            await this.save();
          }
          if (parsed.settings) {
            return parsed.settings;
          }
        } else {
          console.warn("TimeFlow: Could not parse data from", this.dataFile);
          this.data = { entries: [] };
        }
      } else {
        await this.createDataFile();
      }
    } catch (error) {
      console.error("TimeFlow: Error loading timer data:", error);
      this.data = { entries: [] };
    }
    return null;
  }
  async createDataFile() {
    const entriesOnly = { entries: this.data.entries };
    const timekeepBlock = `\`\`\`timekeep
${JSON.stringify(entriesOnly, null, 2)}
\`\`\``;
    const settingsBlock = this.data.settings ? `

\`\`\`timeflow-settings
${JSON.stringify(this.data.settings, null, 2)}
\`\`\`` : "";
    const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

${timekeepBlock}${settingsBlock}
`;
    const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
    const folderExists = await this.app.vault.adapter.exists(folderPath);
    if (!folderExists) {
      await this.app.vault.createFolder(folderPath);
    }
    await this.app.vault.create(this.dataFile, content);
  }
  parseTimekeepData(content) {
    try {
      const timekeepMatch = content.match(/```timekeep\s*\n([\s\S]*?)\n```/);
      if (!timekeepMatch || !timekeepMatch[1]) {
        return null;
      }
      const timekeepData = JSON.parse(timekeepMatch[1]);
      const result = {
        entries: timekeepData.entries || []
      };
      const settingsMatch = content.match(/```timeflow-settings\s*\n([\s\S]*?)\n```/);
      if (settingsMatch && settingsMatch[1]) {
        result.settings = JSON.parse(settingsMatch[1]);
      } else if (timekeepData.settings) {
        result.settings = timekeepData.settings;
      }
      return result;
    } catch (error) {
      console.error("Error parsing timekeep data:", error);
    }
    return null;
  }
  async save() {
    var _a;
    this.isSaving = true;
    this.lastSaveTime = Date.now();
    try {
      const entriesOnly = { entries: this.data.entries };
      const timekeepBlock = `\`\`\`timekeep
${JSON.stringify(entriesOnly, null, 2)}
\`\`\``;
      const settingsBlock = this.data.settings ? `

\`\`\`timeflow-settings
${JSON.stringify(this.data.settings, null, 2)}
\`\`\`` : "";
      const content = `# timeflow data

This file contains your time tracking data in Timekeep-compatible format.

${timekeepBlock}${settingsBlock}
`;
      const fileExists = await this.app.vault.adapter.exists(this.dataFile);
      if (fileExists) {
        const file = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(this.dataFile));
        if (file && file instanceof import_obsidian7.TFile) {
          await this.app.vault.modify(file, content);
        } else {
          await this.app.vault.adapter.write(this.dataFile, content);
        }
      } else {
        const folderPath = this.dataFile.substring(0, this.dataFile.lastIndexOf("/"));
        const folderExists = await this.app.vault.adapter.exists(folderPath);
        if (!folderExists) {
          await this.app.vault.createFolder(folderPath);
        }
        try {
          await this.app.vault.create(this.dataFile, content);
        } catch (createError) {
          if (createError instanceof Error && ((_a = createError.message) == null ? void 0 : _a.includes("File already exists"))) {
            await this.app.vault.adapter.write(this.dataFile, content);
          } else {
            throw createError;
          }
        }
      }
    } catch (error) {
      console.error("TimeFlow: Error saving timer data:", error);
    } finally {
      this.isSaving = false;
    }
  }
  // Save settings to the data file for cross-device sync
  async saveSettings(settings) {
    this.settings = settings;
    this.data.settings = settings;
    await this.save();
  }
  async startTimer(name = "jobb") {
    const timer = {
      name,
      startTime: Utils.toLocalISOString(/* @__PURE__ */ new Date()),
      endTime: null,
      subEntries: null
    };
    this.data.entries.push(timer);
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    new import_obsidian7.Notice(`\u23F1\uFE0F ${t("timer.started").replace("{name}", name)}`);
    return timer;
  }
  async stopTimer(timer) {
    if (!timer.startTime || timer.endTime) {
      return null;
    }
    timer.endTime = Utils.toLocalISOString(/* @__PURE__ */ new Date());
    await this.save();
    if (this.onTimerChange) {
      this.onTimerChange();
    }
    const duration = Utils.hoursDiff(
      new Date(timer.startTime),
      new Date(timer.endTime)
    );
    new import_obsidian7.Notice(`\u2705 ${t("timer.stopped").replace("{name}", timer.name).replace("{duration}", Utils.formatHoursToHM(duration))}`);
    return timer;
  }
  async stopAllTimers() {
    const activeTimers = this.getActiveTimers();
    for (const timer of activeTimers) {
      await this.stopTimer(timer);
    }
  }
  async deleteTimer(timer) {
    const index = this.data.entries.indexOf(timer);
    if (index !== -1) {
      this.data.entries.splice(index, 1);
      await this.save();
      if (this.onTimerChange) {
        this.onTimerChange();
      }
      new import_obsidian7.Notice(t("timer.deleted"));
      return true;
    }
    return false;
  }
  /**
   * Normalize entry timestamps:
   * - Convert UTC 'Z' format to local ISO format
   * - Convert midnight T00:00:00 to T08:00:00 to avoid timezone parsing issues
   * Returns true if any entries were modified and need saving.
   */
  normalizeEntryTimestamps() {
    let modified = false;
    const normalizeTimestamp = (timestamp) => {
      if (!timestamp) return null;
      if (timestamp.endsWith("Z")) {
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
          const pad = (n) => n.toString().padStart(2, "0");
          const localISO = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
          modified = true;
          return localISO;
        }
      }
      if (timestamp.endsWith("T00:00:00")) {
        modified = true;
        return timestamp.replace("T00:00:00", "T08:00:00");
      }
      return timestamp;
    };
    const normalizeEntry = (entry) => {
      if (entry.startTime) {
        const normalized = normalizeTimestamp(entry.startTime);
        if (normalized !== entry.startTime) {
          entry.startTime = normalized;
        }
      }
      if (entry.endTime) {
        const normalized = normalizeTimestamp(entry.endTime);
        if (normalized !== entry.endTime) {
          entry.endTime = normalized;
        }
      }
      if (entry.subEntries && Array.isArray(entry.subEntries)) {
        entry.subEntries.forEach((sub) => normalizeEntry(sub));
      }
    };
    this.data.entries.forEach((entry) => normalizeEntry(entry));
    return modified;
  }
  getActiveTimers() {
    return this.data.entries.filter((e) => e.startTime && !e.endTime && !e.collapsed);
  }
  getCompletedTimers() {
    return this.data.entries.filter((e) => e.startTime && e.endTime);
  }
  getAllTimers() {
    return this.data.entries;
  }
  // Flatten all entries including subEntries for DataManager
  convertToTimeEntries() {
    const flatEntries = [];
    const flattenEntry = (entry) => {
      var _a;
      if (entry.collapsed && entry.subEntries) {
        entry.subEntries.forEach((sub) => flattenEntry(sub));
      } else if (entry.startTime) {
        flatEntries.push({
          name: entry.name,
          startTime: entry.startTime,
          endTime: (_a = entry.endTime) != null ? _a : void 0,
          subEntries: void 0
        });
      }
    };
    this.data.entries.forEach((entry) => flattenEntry(entry));
    return flatEntries;
  }
  // Get running time for active timer
  getRunningTime(timer) {
    if (!timer.startTime || timer.endTime) return 0;
    const now = /* @__PURE__ */ new Date();
    const start = new Date(timer.startTime);
    return Utils.hoursDiff(start, now);
  }
  // Get total running time for all active timers
  getTotalRunningTime() {
    return this.getActiveTimers().reduce((total, timer) => {
      return total + this.getRunningTime(timer);
    }, 0);
  }
  // Load data from multiple sources (daily notes with timekeep codeblocks)
  async loadFromDailyNotes() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const dailyNotesFolder = this.settings.dailyNotesFolder;
      let allEntries = [];
      for (const file of files) {
        if (file.path.startsWith(dailyNotesFolder)) {
          const content = await this.app.vault.read(file);
          const parsed = this.parseTimekeepData(content);
          if (parsed && parsed.entries) {
            allEntries = allEntries.concat(parsed.entries);
          }
        }
      }
      const currentEntries = this.data.entries;
      allEntries.forEach((entry) => {
        const isDuplicate = currentEntries.some(
          (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
        );
        if (!isDuplicate) {
          currentEntries.push(entry);
        }
      });
      this.data.entries = currentEntries;
      await this.save();
    } catch (error) {
      console.error("Error loading from daily notes:", error);
    }
  }
  // Export to Timekeep format for other tools
  exportTimekeepFormat() {
    return JSON.stringify(this.data, null, 2);
  }
  // Import from Timekeep JSON
  async importTimekeepData(jsonData) {
    try {
      const parsed = JSON.parse(jsonData);
      if (parsed && parsed.entries) {
        const currentEntries = this.data.entries;
        let addedCount = 0;
        let skippedCount = 0;
        parsed.entries.forEach((entry) => {
          const isDuplicate = currentEntries.some(
            (e) => e.name === entry.name && e.startTime === entry.startTime && e.endTime === entry.endTime
          );
          if (!isDuplicate) {
            currentEntries.push(entry);
            addedCount++;
          } else {
            skippedCount++;
          }
        });
        this.data.entries = currentEntries;
        await this.save();
        if (this.onTimerChange) {
          this.onTimerChange();
        }
        if (skippedCount > 0) {
          new import_obsidian7.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}, ${t("import.skippedDuplicates")} ${skippedCount} ${t("import.duplicates")}`);
        } else {
          new import_obsidian7.Notice(`\u2705 ${t("import.imported")} ${addedCount} ${t("import.entries")}`);
        }
        return true;
      }
    } catch (error) {
      console.error("Error importing timekeep data:", error);
      new import_obsidian7.Notice(`\u274C ${t("notifications.errorImporting")}`);
    }
    return false;
  }
  // Convert past planned days (from holidays.md) to timer entries
  // This ensures planned days like ferie, avspasering appear in Historikk
  async convertPastPlannedDays(holidays, settings) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    let converted = 0;
    for (const [dateStr, info] of Object.entries(holidays)) {
      const plannedDate = new Date(dateStr);
      if (plannedDate >= today) continue;
      let shouldConvert = false;
      if (info.type === "annet") {
        shouldConvert = true;
      } else {
        const behavior2 = settings.specialDayBehaviors.find((b) => b.id === info.type);
        shouldConvert = (behavior2 == null ? void 0 : behavior2.noHoursRequired) || (behavior2 == null ? void 0 : behavior2.flextimeEffect) === "reduce_goal";
      }
      if (!shouldConvert) continue;
      if (info.type === "helligdag") continue;
      const hasEntry = this.data.entries.some((e) => {
        if (!e.startTime) return false;
        const entryDate = new Date(e.startTime);
        return Utils.toLocalDateStr(entryDate) === dateStr && e.name.toLowerCase() === info.type;
      });
      if (hasEntry) continue;
      let startTime = `${dateStr}T08:00:00`;
      let endTime = `${dateStr}T08:00:00`;
      const behavior = settings.specialDayBehaviors.find((b) => b.id === info.type);
      if ((behavior == null ? void 0 : behavior.flextimeEffect) === "withdraw") {
        if (info.startTime && info.endTime) {
          startTime = `${dateStr}T${info.startTime}:00`;
          endTime = `${dateStr}T${info.endTime}:00`;
        } else {
          const hours = settings.baseWorkday * settings.workPercent;
          const h = Math.floor(hours);
          const m = Math.round((hours - h) * 60);
          endTime = `${dateStr}T${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}:00`;
        }
      } else if (info.type === "annet" && info.startTime && info.endTime) {
        startTime = `${dateStr}T${info.startTime}:00`;
        endTime = `${dateStr}T${info.endTime}:00`;
      }
      const entry = {
        name: info.type,
        startTime,
        endTime,
        subEntries: null
      };
      this.data.entries.push(entry);
      converted++;
    }
    if (converted > 0) {
      await this.save();
    }
    return converted;
  }
};

// src/main.ts
var TimeFlowPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    var _a;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.timerManager = new TimerManager(this.app, this.settings);
    const syncedSettings = await this.timerManager.load();
    if (syncedSettings) {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, this.settings, syncedSettings);
      this.timerManager.settings = this.settings;
    }
    const needsSave = this.migrateWorkDaysSettings() || this.migrateSpecialDayBehaviors() || this.migrateWorkScheduleHistory() || this.migrateIntervalSettings();
    const timestampMigrated = await this.migrateTimestamps();
    if (needsSave || timestampMigrated) {
      await this.saveSettings();
    }
    setLanguage((_a = this.settings.language) != null ? _a : "nb");
    this.registerView(
      VIEW_TYPE_TIMEFLOW,
      (leaf) => new TimeFlowView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open timeflow", () => {
      void this.activateView();
    });
    this.addCommand({
      id: "open-dashboard",
      name: "Open dashboard",
      callback: () => {
        void this.activateView();
      }
    });
    this.addCommand({
      id: "start-timer",
      name: "Start timer",
      callback: async () => {
        await this.timerManager.startTimer("jobb");
      }
    });
    this.addCommand({
      id: "stop-all-timers",
      name: "Stop all timers",
      callback: async () => {
        await this.timerManager.stopAllTimers();
      }
    });
    this.addCommand({
      id: "import-timekeep-data",
      name: "Import timekeep data",
      callback: () => {
        new ImportModal(this.app, this.timerManager, () => {
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
          leaves.forEach((leaf) => {
            const view = leaf.view;
            if (view && view.refresh) {
              void view.refresh();
            }
          });
        }).open();
      }
    });
    this.addSettingTab(new TimeFlowSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (file.path === this.settings.dataFilePath) {
            if (!this.timerManager.shouldReloadFromFile()) return;
            await this.timerManager.load();
            const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
            leaves.forEach((leaf) => {
              const view = leaf.view;
              if (view && view.refresh) {
                void view.refresh();
              }
            });
          }
        })
      );
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  migrateSpecialDayBehaviors() {
    let changed = false;
    if (!this.settings.specialDayBehaviors || this.settings.specialDayBehaviors.length === 0) {
      this.settings.specialDayBehaviors = DEFAULT_SPECIAL_DAY_BEHAVIORS.map((defaultBehavior) => {
        var _a, _b;
        return {
          ...defaultBehavior,
          label: ((_a = this.settings.specialDayLabels) == null ? void 0 : _a[defaultBehavior.id]) || defaultBehavior.label,
          color: ((_b = this.settings.specialDayColors) == null ? void 0 : _b[defaultBehavior.id]) || defaultBehavior.color
        };
      });
      changed = true;
    } else {
      DEFAULT_SPECIAL_DAY_BEHAVIORS.forEach((defaultBehavior) => {
        const existingIndex = this.settings.specialDayBehaviors.findIndex((b) => b.id === defaultBehavior.id);
        if (existingIndex === -1) {
          if (defaultBehavior.isWorkType) {
            this.settings.specialDayBehaviors.unshift({ ...defaultBehavior });
          } else {
            this.settings.specialDayBehaviors.push({ ...defaultBehavior });
          }
          changed = true;
        } else if (defaultBehavior.isWorkType && !this.settings.specialDayBehaviors[existingIndex].isWorkType) {
          this.settings.specialDayBehaviors[existingIndex].isWorkType = true;
          changed = true;
        }
      });
      const reduceGoalTypes = ["egenmelding", "sykemelding", "velferdspermisjon"];
      reduceGoalTypes.forEach((typeId) => {
        const behavior = this.settings.specialDayBehaviors.find((b) => b.id === typeId);
        if (behavior && behavior.flextimeEffect !== "reduce_goal") {
          behavior.flextimeEffect = "reduce_goal";
          behavior.noHoursRequired = false;
          changed = true;
        }
      });
    }
    return changed;
  }
  /**
   * Migrate UTC timestamps (ending with Z) to local ISO format.
   * This ensures times display correctly regardless of timezone.
   */
  async migrateTimestamps() {
    if (this.settings.hasTimestampMigration) {
      return false;
    }
    let changed = false;
    const convertTimestamp = (timestamp) => {
      if (!timestamp) return null;
      if (timestamp.endsWith("Z")) {
        const date = new Date(timestamp);
        return Utils.toLocalISOString(date);
      }
      return timestamp;
    };
    const migrateEntry = (entry) => {
      const newStart = convertTimestamp(entry.startTime);
      const newEnd = convertTimestamp(entry.endTime);
      if (newStart !== entry.startTime || newEnd !== entry.endTime) {
        entry.startTime = newStart;
        entry.endTime = newEnd;
        changed = true;
      }
      if (entry.subEntries) {
        entry.subEntries.forEach((sub) => migrateEntry(sub));
      }
    };
    this.timerManager.data.entries.forEach((entry) => migrateEntry(entry));
    if (changed) {
      await this.timerManager.save();
    }
    this.settings.hasTimestampMigration = true;
    return changed;
  }
  migrateWorkDaysSettings() {
    let changed = false;
    if (!this.settings.workDays || this.settings.workDays.length === 0) {
      const workDays = [1, 2, 3, 4, 5];
      if (this.settings.includeSaturdayInWorkWeek) {
        workDays.push(6);
      }
      if (this.settings.includeSundayInWorkWeek) {
        workDays.push(0);
      }
      this.settings.workDays = workDays.sort((a, b) => a - b);
      changed = true;
    }
    if (!this.settings.alternatingWeekWorkDays || this.settings.alternatingWeekWorkDays.length === 0) {
      this.settings.alternatingWeekWorkDays = [...this.settings.workDays];
      changed = true;
    }
    return changed;
  }
  /**
   * Migrate to work schedule history by creating an initial period from current settings.
   * This preserves the current schedule for historical calculations when the user
   * first adds a new period with different settings.
   */
  migrateWorkScheduleHistory() {
    if (this.settings.workScheduleHistory && this.settings.workScheduleHistory.length > 0) {
      return false;
    }
    const initialPeriod = {
      effectiveFrom: this.settings.balanceStartDate || "2025-01-01",
      workPercent: this.settings.workPercent,
      baseWorkday: this.settings.baseWorkday,
      baseWorkweek: this.settings.baseWorkweek,
      workDays: [...this.settings.workDays],
      halfDayHours: this.settings.halfDayHours
    };
    this.settings.workScheduleHistory = [initialPeriod];
    return true;
  }
  /**
   * Migrate interval settings from milliseconds to seconds.
   * Old versions stored intervals in ms, new versions expect seconds.
   */
  migrateIntervalSettings() {
    let changed = false;
    if (this.settings.updateInterval > 1e3) {
      this.settings.updateInterval = Math.round(this.settings.updateInterval / 1e3);
      changed = true;
    }
    if (this.settings.clockInterval > 100) {
      this.settings.clockInterval = Math.round(this.settings.clockInterval / 1e3);
      changed = true;
    }
    return changed;
  }
  /**
   * Validate and clamp settings to sensible bounds to prevent division by zero
   * and other edge cases. Shows notices when auto-corrections are made.
   */
  validateSettings() {
    var _a, _b;
    const corrections = [];
    this.settings.workPercent = Math.max(0.01, Math.min(2, this.settings.workPercent));
    this.settings.baseWorkday = Math.max(0.5, Math.min(24, this.settings.baseWorkday));
    this.settings.baseWorkweek = Math.max(1, Math.min(168, this.settings.baseWorkweek));
    this.settings.workdaysPerWeek = Math.max(1, Math.min(7, this.settings.workdaysPerWeek));
    this.settings.workdaysPerMonth = Math.max(1, Math.min(31, this.settings.workdaysPerMonth));
    this.settings.workdaysPerYear = Math.max(1, Math.min(366, this.settings.workdaysPerYear));
    this.settings.lunchBreakMinutes = Math.max(0, Math.min(120, this.settings.lunchBreakMinutes));
    this.settings.maxEgenmeldingDays = Math.max(0, Math.min(365, this.settings.maxEgenmeldingDays));
    this.settings.maxFerieDays = Math.max(0, Math.min(365, this.settings.maxFerieDays));
    this.settings.heatmapColumns = Math.max(12, Math.min(96, this.settings.heatmapColumns));
    const oldHalfDay = this.settings.halfDayHours;
    this.settings.halfDayHours = Math.max(0.5, Math.min(this.settings.baseWorkday, this.settings.halfDayHours));
    if (oldHalfDay > this.settings.baseWorkday) {
      this.settings.halfDayHours = this.settings.baseWorkday / 2;
      corrections.push(`Half-day hours capped to ${this.settings.halfDayHours}h (cannot exceed base workday)`);
    }
    if (this.settings.workPercent < 0) {
      this.settings.workPercent = 0;
      corrections.push("Work percent cannot be negative, set to 0");
    } else if (this.settings.workPercent > 1) {
      this.settings.workPercent = Math.min(2, this.settings.workPercent);
    }
    const expectedWorkweek = this.settings.baseWorkday * (((_a = this.settings.workDays) == null ? void 0 : _a.length) || 5);
    if (Math.abs(this.settings.baseWorkweek - expectedWorkweek) > 0.5) {
      const oldWorkweek = this.settings.baseWorkweek;
      this.settings.baseWorkweek = expectedWorkweek;
      corrections.push(`Base workweek adjusted from ${oldWorkweek}h to ${expectedWorkweek}h (${this.settings.baseWorkday}h \xD7 ${((_b = this.settings.workDays) == null ? void 0 : _b.length) || 5} days)`);
    }
    const t2 = this.settings.balanceThresholds;
    if (t2.criticalLow >= t2.warningLow) t2.warningLow = t2.criticalLow + 1;
    if (t2.warningLow >= t2.warningHigh) t2.warningHigh = t2.warningLow + 1;
    if (t2.warningHigh >= t2.criticalHigh) t2.criticalHigh = t2.warningHigh + 1;
    if (!this.settings.workDays || this.settings.workDays.length === 0) {
      this.settings.workDays = [1, 2, 3, 4, 5];
      corrections.push("Work days reset to Monday-Friday (at least one day required)");
    }
    if (corrections.length > 0) {
      new import_obsidian8.Notice(`Settings auto-corrected:
${corrections.join("\n")}`, 5e3);
    }
  }
  async saveSettings() {
    this.validateSettings();
    await this.saveData(this.settings);
    await this.timerManager.saveSettings(this.settings);
  }
  async activateView(location) {
    const targetLocation = location != null ? location : this.settings.defaultViewLocation;
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      if (targetLocation === "main") {
        leaf = workspace.getLeaf("tab");
      } else {
        leaf = workspace.getRightLeaf(false);
      }
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_TIMEFLOW, active: true });
      }
    }
    if (leaf) {
      void workspace.revealLeaf(leaf);
    }
  }
  async moveViewToLocation(location) {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMEFLOW);
    for (const leaf of leaves) {
      leaf.detach();
    }
    await this.activateView(location);
  }
};
